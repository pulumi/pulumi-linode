// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.linode.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.linode.inputs.GetNodebalancerConfigsNodebalancerConfigNodeStatusArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;


public final class GetNodebalancerConfigsNodebalancerConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final GetNodebalancerConfigsNodebalancerConfigArgs Empty = new GetNodebalancerConfigsNodebalancerConfigArgs();

    /**
     * What algorithm this NodeBalancer should use for routing traffic to backends (`roundrobin`, `leastconn`, `source`)
     * 
     */
    @Import(name="algorithm", required=true)
    private Output<String> algorithm;

    /**
     * @return What algorithm this NodeBalancer should use for routing traffic to backends (`roundrobin`, `leastconn`, `source`)
     * 
     */
    public Output<String> algorithm() {
        return this.algorithm;
    }

    /**
     * The type of check to perform against backends to ensure they are serving requests. This is used to determine if backends are up or down. If none no check is performed. connection requires only a connection to the backend to succeed. http and http_body rely on the backend serving HTTP, and that the response returned matches what is expected. (`none`, `connection`, `http`, `http_body`)
     * 
     */
    @Import(name="check", required=true)
    private Output<String> check;

    /**
     * @return The type of check to perform against backends to ensure they are serving requests. This is used to determine if backends are up or down. If none no check is performed. connection requires only a connection to the backend to succeed. http and http_body rely on the backend serving HTTP, and that the response returned matches what is expected. (`none`, `connection`, `http`, `http_body`)
     * 
     */
    public Output<String> check() {
        return this.check;
    }

    /**
     * How many times to attempt a check before considering a backend to be down. (1-30)
     * 
     */
    @Import(name="checkAttempts", required=true)
    private Output<Integer> checkAttempts;

    /**
     * @return How many times to attempt a check before considering a backend to be down. (1-30)
     * 
     */
    public Output<Integer> checkAttempts() {
        return this.checkAttempts;
    }

    /**
     * This value must be present in the response body of the check in order for it to pass. If this value is not present in the response body of a check request, the backend is considered to be down
     * 
     */
    @Import(name="checkBody", required=true)
    private Output<String> checkBody;

    /**
     * @return This value must be present in the response body of the check in order for it to pass. If this value is not present in the response body of a check request, the backend is considered to be down
     * 
     */
    public Output<String> checkBody() {
        return this.checkBody;
    }

    /**
     * How often, in seconds, to check that backends are up and serving requests.
     * 
     */
    @Import(name="checkInterval", required=true)
    private Output<Integer> checkInterval;

    /**
     * @return How often, in seconds, to check that backends are up and serving requests.
     * 
     */
    public Output<Integer> checkInterval() {
        return this.checkInterval;
    }

    /**
     * If true, any response from this backend with a 5xx status code will be enough for it to be considered unhealthy and taken out of rotation.
     * 
     */
    @Import(name="checkPassive", required=true)
    private Output<Boolean> checkPassive;

    /**
     * @return If true, any response from this backend with a 5xx status code will be enough for it to be considered unhealthy and taken out of rotation.
     * 
     */
    public Output<Boolean> checkPassive() {
        return this.checkPassive;
    }

    /**
     * The URL path to check on each backend. If the backend does not respond to this request it is considered to be down.
     * 
     */
    @Import(name="checkPath", required=true)
    private Output<String> checkPath;

    /**
     * @return The URL path to check on each backend. If the backend does not respond to this request it is considered to be down.
     * 
     */
    public Output<String> checkPath() {
        return this.checkPath;
    }

    /**
     * How long, in seconds, to wait for a check attempt before considering it failed. (1-30)
     * 
     */
    @Import(name="checkTimeout", required=true)
    private Output<Integer> checkTimeout;

    /**
     * @return How long, in seconds, to wait for a check attempt before considering it failed. (1-30)
     * 
     */
    public Output<Integer> checkTimeout() {
        return this.checkTimeout;
    }

    /**
     * What ciphers to use for SSL connections served by this NodeBalancer. `legacy` is considered insecure and should only be used if necessary. (`recommended`, `legacy`)
     * 
     */
    @Import(name="cipherSuite", required=true)
    private Output<String> cipherSuite;

    /**
     * @return What ciphers to use for SSL connections served by this NodeBalancer. `legacy` is considered insecure and should only be used if necessary. (`recommended`, `legacy`)
     * 
     */
    public Output<String> cipherSuite() {
        return this.cipherSuite;
    }

    /**
     * The config&#39;s ID.
     * 
     */
    @Import(name="id", required=true)
    private Output<Integer> id;

    /**
     * @return The config&#39;s ID.
     * 
     */
    public Output<Integer> id() {
        return this.id;
    }

    /**
     * A structure containing information about the health of the backends for this port. This information is updated periodically as checks are performed against backends.
     * 
     */
    @Import(name="nodeStatuses", required=true)
    private Output<List<GetNodebalancerConfigsNodebalancerConfigNodeStatusArgs>> nodeStatuses;

    /**
     * @return A structure containing information about the health of the backends for this port. This information is updated periodically as checks are performed against backends.
     * 
     */
    public Output<List<GetNodebalancerConfigsNodebalancerConfigNodeStatusArgs>> nodeStatuses() {
        return this.nodeStatuses;
    }

    /**
     * The ID of the NodeBalancer to access.
     * 
     * * `filter` - (Optional) A set of filters used to select Linode NodeBalancers that meet certain requirements.
     * 
     */
    @Import(name="nodebalancerId", required=true)
    private Output<Integer> nodebalancerId;

    /**
     * @return The ID of the NodeBalancer to access.
     * 
     * * `filter` - (Optional) A set of filters used to select Linode NodeBalancers that meet certain requirements.
     * 
     */
    public Output<Integer> nodebalancerId() {
        return this.nodebalancerId;
    }

    /**
     * The TCP port this Config is for.
     * 
     */
    @Import(name="port", required=true)
    private Output<Integer> port;

    /**
     * @return The TCP port this Config is for.
     * 
     */
    public Output<Integer> port() {
        return this.port;
    }

    /**
     * The protocol this port is configured to serve. If this is set to https you must include an ssl_cert and an ssl_key. (`http`, `https`, `tcp`) (Defaults to `http`)
     * 
     */
    @Import(name="protocol", required=true)
    private Output<String> protocol;

    /**
     * @return The protocol this port is configured to serve. If this is set to https you must include an ssl_cert and an ssl_key. (`http`, `https`, `tcp`) (Defaults to `http`)
     * 
     */
    public Output<String> protocol() {
        return this.protocol;
    }

    /**
     * The version of ProxyProtocol to use for the underlying NodeBalancer. This requires protocol to be `tcp`. (`none`, `v1`, and `v2`) (Defaults to `none`)
     * 
     */
    @Import(name="proxyProtocol", required=true)
    private Output<String> proxyProtocol;

    /**
     * @return The version of ProxyProtocol to use for the underlying NodeBalancer. This requires protocol to be `tcp`. (`none`, `v1`, and `v2`) (Defaults to `none`)
     * 
     */
    public Output<String> proxyProtocol() {
        return this.proxyProtocol;
    }

    /**
     * The read-only common name automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
     * 
     */
    @Import(name="sslCommonname", required=true)
    private Output<String> sslCommonname;

    /**
     * @return The read-only common name automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
     * 
     */
    public Output<String> sslCommonname() {
        return this.sslCommonname;
    }

    /**
     * The read-only fingerprint automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
     * 
     */
    @Import(name="sslFingerprint", required=true)
    private Output<String> sslFingerprint;

    /**
     * @return The read-only fingerprint automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
     * 
     */
    public Output<String> sslFingerprint() {
        return this.sslFingerprint;
    }

    /**
     * Controls how session stickiness is handled on this port. (`none`, `table`, `http_cookie`)
     * 
     */
    @Import(name="stickiness", required=true)
    private Output<String> stickiness;

    /**
     * @return Controls how session stickiness is handled on this port. (`none`, `table`, `http_cookie`)
     * 
     */
    public Output<String> stickiness() {
        return this.stickiness;
    }

    private GetNodebalancerConfigsNodebalancerConfigArgs() {}

    private GetNodebalancerConfigsNodebalancerConfigArgs(GetNodebalancerConfigsNodebalancerConfigArgs $) {
        this.algorithm = $.algorithm;
        this.check = $.check;
        this.checkAttempts = $.checkAttempts;
        this.checkBody = $.checkBody;
        this.checkInterval = $.checkInterval;
        this.checkPassive = $.checkPassive;
        this.checkPath = $.checkPath;
        this.checkTimeout = $.checkTimeout;
        this.cipherSuite = $.cipherSuite;
        this.id = $.id;
        this.nodeStatuses = $.nodeStatuses;
        this.nodebalancerId = $.nodebalancerId;
        this.port = $.port;
        this.protocol = $.protocol;
        this.proxyProtocol = $.proxyProtocol;
        this.sslCommonname = $.sslCommonname;
        this.sslFingerprint = $.sslFingerprint;
        this.stickiness = $.stickiness;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetNodebalancerConfigsNodebalancerConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetNodebalancerConfigsNodebalancerConfigArgs $;

        public Builder() {
            $ = new GetNodebalancerConfigsNodebalancerConfigArgs();
        }

        public Builder(GetNodebalancerConfigsNodebalancerConfigArgs defaults) {
            $ = new GetNodebalancerConfigsNodebalancerConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param algorithm What algorithm this NodeBalancer should use for routing traffic to backends (`roundrobin`, `leastconn`, `source`)
         * 
         * @return builder
         * 
         */
        public Builder algorithm(Output<String> algorithm) {
            $.algorithm = algorithm;
            return this;
        }

        /**
         * @param algorithm What algorithm this NodeBalancer should use for routing traffic to backends (`roundrobin`, `leastconn`, `source`)
         * 
         * @return builder
         * 
         */
        public Builder algorithm(String algorithm) {
            return algorithm(Output.of(algorithm));
        }

        /**
         * @param check The type of check to perform against backends to ensure they are serving requests. This is used to determine if backends are up or down. If none no check is performed. connection requires only a connection to the backend to succeed. http and http_body rely on the backend serving HTTP, and that the response returned matches what is expected. (`none`, `connection`, `http`, `http_body`)
         * 
         * @return builder
         * 
         */
        public Builder check(Output<String> check) {
            $.check = check;
            return this;
        }

        /**
         * @param check The type of check to perform against backends to ensure they are serving requests. This is used to determine if backends are up or down. If none no check is performed. connection requires only a connection to the backend to succeed. http and http_body rely on the backend serving HTTP, and that the response returned matches what is expected. (`none`, `connection`, `http`, `http_body`)
         * 
         * @return builder
         * 
         */
        public Builder check(String check) {
            return check(Output.of(check));
        }

        /**
         * @param checkAttempts How many times to attempt a check before considering a backend to be down. (1-30)
         * 
         * @return builder
         * 
         */
        public Builder checkAttempts(Output<Integer> checkAttempts) {
            $.checkAttempts = checkAttempts;
            return this;
        }

        /**
         * @param checkAttempts How many times to attempt a check before considering a backend to be down. (1-30)
         * 
         * @return builder
         * 
         */
        public Builder checkAttempts(Integer checkAttempts) {
            return checkAttempts(Output.of(checkAttempts));
        }

        /**
         * @param checkBody This value must be present in the response body of the check in order for it to pass. If this value is not present in the response body of a check request, the backend is considered to be down
         * 
         * @return builder
         * 
         */
        public Builder checkBody(Output<String> checkBody) {
            $.checkBody = checkBody;
            return this;
        }

        /**
         * @param checkBody This value must be present in the response body of the check in order for it to pass. If this value is not present in the response body of a check request, the backend is considered to be down
         * 
         * @return builder
         * 
         */
        public Builder checkBody(String checkBody) {
            return checkBody(Output.of(checkBody));
        }

        /**
         * @param checkInterval How often, in seconds, to check that backends are up and serving requests.
         * 
         * @return builder
         * 
         */
        public Builder checkInterval(Output<Integer> checkInterval) {
            $.checkInterval = checkInterval;
            return this;
        }

        /**
         * @param checkInterval How often, in seconds, to check that backends are up and serving requests.
         * 
         * @return builder
         * 
         */
        public Builder checkInterval(Integer checkInterval) {
            return checkInterval(Output.of(checkInterval));
        }

        /**
         * @param checkPassive If true, any response from this backend with a 5xx status code will be enough for it to be considered unhealthy and taken out of rotation.
         * 
         * @return builder
         * 
         */
        public Builder checkPassive(Output<Boolean> checkPassive) {
            $.checkPassive = checkPassive;
            return this;
        }

        /**
         * @param checkPassive If true, any response from this backend with a 5xx status code will be enough for it to be considered unhealthy and taken out of rotation.
         * 
         * @return builder
         * 
         */
        public Builder checkPassive(Boolean checkPassive) {
            return checkPassive(Output.of(checkPassive));
        }

        /**
         * @param checkPath The URL path to check on each backend. If the backend does not respond to this request it is considered to be down.
         * 
         * @return builder
         * 
         */
        public Builder checkPath(Output<String> checkPath) {
            $.checkPath = checkPath;
            return this;
        }

        /**
         * @param checkPath The URL path to check on each backend. If the backend does not respond to this request it is considered to be down.
         * 
         * @return builder
         * 
         */
        public Builder checkPath(String checkPath) {
            return checkPath(Output.of(checkPath));
        }

        /**
         * @param checkTimeout How long, in seconds, to wait for a check attempt before considering it failed. (1-30)
         * 
         * @return builder
         * 
         */
        public Builder checkTimeout(Output<Integer> checkTimeout) {
            $.checkTimeout = checkTimeout;
            return this;
        }

        /**
         * @param checkTimeout How long, in seconds, to wait for a check attempt before considering it failed. (1-30)
         * 
         * @return builder
         * 
         */
        public Builder checkTimeout(Integer checkTimeout) {
            return checkTimeout(Output.of(checkTimeout));
        }

        /**
         * @param cipherSuite What ciphers to use for SSL connections served by this NodeBalancer. `legacy` is considered insecure and should only be used if necessary. (`recommended`, `legacy`)
         * 
         * @return builder
         * 
         */
        public Builder cipherSuite(Output<String> cipherSuite) {
            $.cipherSuite = cipherSuite;
            return this;
        }

        /**
         * @param cipherSuite What ciphers to use for SSL connections served by this NodeBalancer. `legacy` is considered insecure and should only be used if necessary. (`recommended`, `legacy`)
         * 
         * @return builder
         * 
         */
        public Builder cipherSuite(String cipherSuite) {
            return cipherSuite(Output.of(cipherSuite));
        }

        /**
         * @param id The config&#39;s ID.
         * 
         * @return builder
         * 
         */
        public Builder id(Output<Integer> id) {
            $.id = id;
            return this;
        }

        /**
         * @param id The config&#39;s ID.
         * 
         * @return builder
         * 
         */
        public Builder id(Integer id) {
            return id(Output.of(id));
        }

        /**
         * @param nodeStatuses A structure containing information about the health of the backends for this port. This information is updated periodically as checks are performed against backends.
         * 
         * @return builder
         * 
         */
        public Builder nodeStatuses(Output<List<GetNodebalancerConfigsNodebalancerConfigNodeStatusArgs>> nodeStatuses) {
            $.nodeStatuses = nodeStatuses;
            return this;
        }

        /**
         * @param nodeStatuses A structure containing information about the health of the backends for this port. This information is updated periodically as checks are performed against backends.
         * 
         * @return builder
         * 
         */
        public Builder nodeStatuses(List<GetNodebalancerConfigsNodebalancerConfigNodeStatusArgs> nodeStatuses) {
            return nodeStatuses(Output.of(nodeStatuses));
        }

        /**
         * @param nodeStatuses A structure containing information about the health of the backends for this port. This information is updated periodically as checks are performed against backends.
         * 
         * @return builder
         * 
         */
        public Builder nodeStatuses(GetNodebalancerConfigsNodebalancerConfigNodeStatusArgs... nodeStatuses) {
            return nodeStatuses(List.of(nodeStatuses));
        }

        /**
         * @param nodebalancerId The ID of the NodeBalancer to access.
         * 
         * * `filter` - (Optional) A set of filters used to select Linode NodeBalancers that meet certain requirements.
         * 
         * @return builder
         * 
         */
        public Builder nodebalancerId(Output<Integer> nodebalancerId) {
            $.nodebalancerId = nodebalancerId;
            return this;
        }

        /**
         * @param nodebalancerId The ID of the NodeBalancer to access.
         * 
         * * `filter` - (Optional) A set of filters used to select Linode NodeBalancers that meet certain requirements.
         * 
         * @return builder
         * 
         */
        public Builder nodebalancerId(Integer nodebalancerId) {
            return nodebalancerId(Output.of(nodebalancerId));
        }

        /**
         * @param port The TCP port this Config is for.
         * 
         * @return builder
         * 
         */
        public Builder port(Output<Integer> port) {
            $.port = port;
            return this;
        }

        /**
         * @param port The TCP port this Config is for.
         * 
         * @return builder
         * 
         */
        public Builder port(Integer port) {
            return port(Output.of(port));
        }

        /**
         * @param protocol The protocol this port is configured to serve. If this is set to https you must include an ssl_cert and an ssl_key. (`http`, `https`, `tcp`) (Defaults to `http`)
         * 
         * @return builder
         * 
         */
        public Builder protocol(Output<String> protocol) {
            $.protocol = protocol;
            return this;
        }

        /**
         * @param protocol The protocol this port is configured to serve. If this is set to https you must include an ssl_cert and an ssl_key. (`http`, `https`, `tcp`) (Defaults to `http`)
         * 
         * @return builder
         * 
         */
        public Builder protocol(String protocol) {
            return protocol(Output.of(protocol));
        }

        /**
         * @param proxyProtocol The version of ProxyProtocol to use for the underlying NodeBalancer. This requires protocol to be `tcp`. (`none`, `v1`, and `v2`) (Defaults to `none`)
         * 
         * @return builder
         * 
         */
        public Builder proxyProtocol(Output<String> proxyProtocol) {
            $.proxyProtocol = proxyProtocol;
            return this;
        }

        /**
         * @param proxyProtocol The version of ProxyProtocol to use for the underlying NodeBalancer. This requires protocol to be `tcp`. (`none`, `v1`, and `v2`) (Defaults to `none`)
         * 
         * @return builder
         * 
         */
        public Builder proxyProtocol(String proxyProtocol) {
            return proxyProtocol(Output.of(proxyProtocol));
        }

        /**
         * @param sslCommonname The read-only common name automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
         * 
         * @return builder
         * 
         */
        public Builder sslCommonname(Output<String> sslCommonname) {
            $.sslCommonname = sslCommonname;
            return this;
        }

        /**
         * @param sslCommonname The read-only common name automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
         * 
         * @return builder
         * 
         */
        public Builder sslCommonname(String sslCommonname) {
            return sslCommonname(Output.of(sslCommonname));
        }

        /**
         * @param sslFingerprint The read-only fingerprint automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
         * 
         * @return builder
         * 
         */
        public Builder sslFingerprint(Output<String> sslFingerprint) {
            $.sslFingerprint = sslFingerprint;
            return this;
        }

        /**
         * @param sslFingerprint The read-only fingerprint automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
         * 
         * @return builder
         * 
         */
        public Builder sslFingerprint(String sslFingerprint) {
            return sslFingerprint(Output.of(sslFingerprint));
        }

        /**
         * @param stickiness Controls how session stickiness is handled on this port. (`none`, `table`, `http_cookie`)
         * 
         * @return builder
         * 
         */
        public Builder stickiness(Output<String> stickiness) {
            $.stickiness = stickiness;
            return this;
        }

        /**
         * @param stickiness Controls how session stickiness is handled on this port. (`none`, `table`, `http_cookie`)
         * 
         * @return builder
         * 
         */
        public Builder stickiness(String stickiness) {
            return stickiness(Output.of(stickiness));
        }

        public GetNodebalancerConfigsNodebalancerConfigArgs build() {
            if ($.algorithm == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "algorithm");
            }
            if ($.check == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "check");
            }
            if ($.checkAttempts == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "checkAttempts");
            }
            if ($.checkBody == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "checkBody");
            }
            if ($.checkInterval == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "checkInterval");
            }
            if ($.checkPassive == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "checkPassive");
            }
            if ($.checkPath == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "checkPath");
            }
            if ($.checkTimeout == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "checkTimeout");
            }
            if ($.cipherSuite == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "cipherSuite");
            }
            if ($.id == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "id");
            }
            if ($.nodeStatuses == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "nodeStatuses");
            }
            if ($.nodebalancerId == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "nodebalancerId");
            }
            if ($.port == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "port");
            }
            if ($.protocol == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "protocol");
            }
            if ($.proxyProtocol == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "proxyProtocol");
            }
            if ($.sslCommonname == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "sslCommonname");
            }
            if ($.sslFingerprint == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "sslFingerprint");
            }
            if ($.stickiness == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfigArgs", "stickiness");
            }
            return $;
        }
    }

}
