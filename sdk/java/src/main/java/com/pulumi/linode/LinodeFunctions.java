// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.linode;

import com.pulumi.core.Output;
import com.pulumi.core.TypeShape;
import com.pulumi.deployment.Deployment;
import com.pulumi.deployment.InvokeOptions;
import com.pulumi.deployment.InvokeOutputOptions;
import com.pulumi.linode.Utilities;
import com.pulumi.linode.inputs.GetAccountAvailabilitiesArgs;
import com.pulumi.linode.inputs.GetAccountAvailabilitiesPlainArgs;
import com.pulumi.linode.inputs.GetAccountAvailabilityArgs;
import com.pulumi.linode.inputs.GetAccountAvailabilityPlainArgs;
import com.pulumi.linode.inputs.GetAccountLoginArgs;
import com.pulumi.linode.inputs.GetAccountLoginPlainArgs;
import com.pulumi.linode.inputs.GetAccountLoginsArgs;
import com.pulumi.linode.inputs.GetAccountLoginsPlainArgs;
import com.pulumi.linode.inputs.GetChildAccountArgs;
import com.pulumi.linode.inputs.GetChildAccountPlainArgs;
import com.pulumi.linode.inputs.GetChildAccountsArgs;
import com.pulumi.linode.inputs.GetChildAccountsPlainArgs;
import com.pulumi.linode.inputs.GetDatabaseBackupsArgs;
import com.pulumi.linode.inputs.GetDatabaseBackupsPlainArgs;
import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
import com.pulumi.linode.inputs.GetDatabaseEnginesPlainArgs;
import com.pulumi.linode.inputs.GetDatabaseMysqlArgs;
import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsArgs;
import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsPlainArgs;
import com.pulumi.linode.inputs.GetDatabaseMysqlPlainArgs;
import com.pulumi.linode.inputs.GetDatabaseMysqlV2Args;
import com.pulumi.linode.inputs.GetDatabaseMysqlV2PlainArgs;
import com.pulumi.linode.inputs.GetDatabasePostgresqlArgs;
import com.pulumi.linode.inputs.GetDatabasePostgresqlPlainArgs;
import com.pulumi.linode.inputs.GetDatabasePostgresqlV2Args;
import com.pulumi.linode.inputs.GetDatabasePostgresqlV2PlainArgs;
import com.pulumi.linode.inputs.GetDatabasesArgs;
import com.pulumi.linode.inputs.GetDatabasesPlainArgs;
import com.pulumi.linode.inputs.GetDomainArgs;
import com.pulumi.linode.inputs.GetDomainPlainArgs;
import com.pulumi.linode.inputs.GetDomainRecordArgs;
import com.pulumi.linode.inputs.GetDomainRecordPlainArgs;
import com.pulumi.linode.inputs.GetDomainZonefileArgs;
import com.pulumi.linode.inputs.GetDomainZonefilePlainArgs;
import com.pulumi.linode.inputs.GetDomainsArgs;
import com.pulumi.linode.inputs.GetDomainsPlainArgs;
import com.pulumi.linode.inputs.GetFirewallArgs;
import com.pulumi.linode.inputs.GetFirewallPlainArgs;
import com.pulumi.linode.inputs.GetFirewallsArgs;
import com.pulumi.linode.inputs.GetFirewallsPlainArgs;
import com.pulumi.linode.inputs.GetImageArgs;
import com.pulumi.linode.inputs.GetImagePlainArgs;
import com.pulumi.linode.inputs.GetImagesArgs;
import com.pulumi.linode.inputs.GetImagesPlainArgs;
import com.pulumi.linode.inputs.GetInstanceBackupsArgs;
import com.pulumi.linode.inputs.GetInstanceBackupsPlainArgs;
import com.pulumi.linode.inputs.GetInstanceNetworkingArgs;
import com.pulumi.linode.inputs.GetInstanceNetworkingPlainArgs;
import com.pulumi.linode.inputs.GetInstanceTypeArgs;
import com.pulumi.linode.inputs.GetInstanceTypePlainArgs;
import com.pulumi.linode.inputs.GetInstanceTypesArgs;
import com.pulumi.linode.inputs.GetInstanceTypesPlainArgs;
import com.pulumi.linode.inputs.GetInstancesArgs;
import com.pulumi.linode.inputs.GetInstancesPlainArgs;
import com.pulumi.linode.inputs.GetIpv6RangeArgs;
import com.pulumi.linode.inputs.GetIpv6RangePlainArgs;
import com.pulumi.linode.inputs.GetIpv6RangesArgs;
import com.pulumi.linode.inputs.GetIpv6RangesPlainArgs;
import com.pulumi.linode.inputs.GetKernelArgs;
import com.pulumi.linode.inputs.GetKernelPlainArgs;
import com.pulumi.linode.inputs.GetKernelsArgs;
import com.pulumi.linode.inputs.GetKernelsPlainArgs;
import com.pulumi.linode.inputs.GetLinodeObjectStorageBucketArgs;
import com.pulumi.linode.inputs.GetLinodeObjectStorageBucketPlainArgs;
import com.pulumi.linode.inputs.GetLkeClusterArgs;
import com.pulumi.linode.inputs.GetLkeClusterPlainArgs;
import com.pulumi.linode.inputs.GetLkeClustersArgs;
import com.pulumi.linode.inputs.GetLkeClustersPlainArgs;
import com.pulumi.linode.inputs.GetLkeTypesArgs;
import com.pulumi.linode.inputs.GetLkeTypesPlainArgs;
import com.pulumi.linode.inputs.GetLkeVersionArgs;
import com.pulumi.linode.inputs.GetLkeVersionPlainArgs;
import com.pulumi.linode.inputs.GetLkeVersionsArgs;
import com.pulumi.linode.inputs.GetLkeVersionsPlainArgs;
import com.pulumi.linode.inputs.GetNbTypesArgs;
import com.pulumi.linode.inputs.GetNbTypesPlainArgs;
import com.pulumi.linode.inputs.GetNetworkTransferPricesArgs;
import com.pulumi.linode.inputs.GetNetworkTransferPricesPlainArgs;
import com.pulumi.linode.inputs.GetNetworkingIpArgs;
import com.pulumi.linode.inputs.GetNetworkingIpPlainArgs;
import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
import com.pulumi.linode.inputs.GetNetworkingIpsPlainArgs;
import com.pulumi.linode.inputs.GetNodeBalancerArgs;
import com.pulumi.linode.inputs.GetNodeBalancerConfigArgs;
import com.pulumi.linode.inputs.GetNodeBalancerConfigPlainArgs;
import com.pulumi.linode.inputs.GetNodeBalancerNodeArgs;
import com.pulumi.linode.inputs.GetNodeBalancerNodePlainArgs;
import com.pulumi.linode.inputs.GetNodeBalancerPlainArgs;
import com.pulumi.linode.inputs.GetNodebalancerConfigsArgs;
import com.pulumi.linode.inputs.GetNodebalancerConfigsPlainArgs;
import com.pulumi.linode.inputs.GetNodebalancersArgs;
import com.pulumi.linode.inputs.GetNodebalancersPlainArgs;
import com.pulumi.linode.inputs.GetObjectStorageClusterArgs;
import com.pulumi.linode.inputs.GetObjectStorageClusterPlainArgs;
import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
import com.pulumi.linode.inputs.GetObjectStorageEndpointsPlainArgs;
import com.pulumi.linode.inputs.GetObjectStorageQuotaArgs;
import com.pulumi.linode.inputs.GetObjectStorageQuotaPlainArgs;
import com.pulumi.linode.inputs.GetObjectStorageQuotasArgs;
import com.pulumi.linode.inputs.GetObjectStorageQuotasPlainArgs;
import com.pulumi.linode.inputs.GetPlacementGroupArgs;
import com.pulumi.linode.inputs.GetPlacementGroupPlainArgs;
import com.pulumi.linode.inputs.GetPlacementGroupsArgs;
import com.pulumi.linode.inputs.GetPlacementGroupsPlainArgs;
import com.pulumi.linode.inputs.GetRegionArgs;
import com.pulumi.linode.inputs.GetRegionPlainArgs;
import com.pulumi.linode.inputs.GetRegionsArgs;
import com.pulumi.linode.inputs.GetRegionsPlainArgs;
import com.pulumi.linode.inputs.GetSshKeyArgs;
import com.pulumi.linode.inputs.GetSshKeyPlainArgs;
import com.pulumi.linode.inputs.GetSshkeysArgs;
import com.pulumi.linode.inputs.GetSshkeysPlainArgs;
import com.pulumi.linode.inputs.GetStackScriptArgs;
import com.pulumi.linode.inputs.GetStackScriptPlainArgs;
import com.pulumi.linode.inputs.GetStackScriptsArgs;
import com.pulumi.linode.inputs.GetStackScriptsPlainArgs;
import com.pulumi.linode.inputs.GetUserArgs;
import com.pulumi.linode.inputs.GetUserPlainArgs;
import com.pulumi.linode.inputs.GetUsersArgs;
import com.pulumi.linode.inputs.GetUsersPlainArgs;
import com.pulumi.linode.inputs.GetVlansArgs;
import com.pulumi.linode.inputs.GetVlansPlainArgs;
import com.pulumi.linode.inputs.GetVolumeArgs;
import com.pulumi.linode.inputs.GetVolumePlainArgs;
import com.pulumi.linode.inputs.GetVolumeTypesArgs;
import com.pulumi.linode.inputs.GetVolumeTypesPlainArgs;
import com.pulumi.linode.inputs.GetVolumesArgs;
import com.pulumi.linode.inputs.GetVolumesPlainArgs;
import com.pulumi.linode.inputs.GetVpcArgs;
import com.pulumi.linode.inputs.GetVpcIpsArgs;
import com.pulumi.linode.inputs.GetVpcIpsPlainArgs;
import com.pulumi.linode.inputs.GetVpcPlainArgs;
import com.pulumi.linode.inputs.GetVpcSubnetArgs;
import com.pulumi.linode.inputs.GetVpcSubnetPlainArgs;
import com.pulumi.linode.inputs.GetVpcSubnetsArgs;
import com.pulumi.linode.inputs.GetVpcSubnetsPlainArgs;
import com.pulumi.linode.inputs.GetVpcsArgs;
import com.pulumi.linode.inputs.GetVpcsPlainArgs;
import com.pulumi.linode.outputs.GetAccountAvailabilitiesResult;
import com.pulumi.linode.outputs.GetAccountAvailabilityResult;
import com.pulumi.linode.outputs.GetAccountLoginResult;
import com.pulumi.linode.outputs.GetAccountLoginsResult;
import com.pulumi.linode.outputs.GetAccountResult;
import com.pulumi.linode.outputs.GetAccountSettingsResult;
import com.pulumi.linode.outputs.GetChildAccountResult;
import com.pulumi.linode.outputs.GetChildAccountsResult;
import com.pulumi.linode.outputs.GetDatabaseBackupsResult;
import com.pulumi.linode.outputs.GetDatabaseEnginesResult;
import com.pulumi.linode.outputs.GetDatabaseMysqlBackupsResult;
import com.pulumi.linode.outputs.GetDatabaseMysqlConfigResult;
import com.pulumi.linode.outputs.GetDatabaseMysqlResult;
import com.pulumi.linode.outputs.GetDatabaseMysqlV2Result;
import com.pulumi.linode.outputs.GetDatabasePostgresqlConfigResult;
import com.pulumi.linode.outputs.GetDatabasePostgresqlResult;
import com.pulumi.linode.outputs.GetDatabasePostgresqlV2Result;
import com.pulumi.linode.outputs.GetDatabasesResult;
import com.pulumi.linode.outputs.GetDomainRecordResult;
import com.pulumi.linode.outputs.GetDomainResult;
import com.pulumi.linode.outputs.GetDomainZonefileResult;
import com.pulumi.linode.outputs.GetDomainsResult;
import com.pulumi.linode.outputs.GetFirewallResult;
import com.pulumi.linode.outputs.GetFirewallsResult;
import com.pulumi.linode.outputs.GetImageResult;
import com.pulumi.linode.outputs.GetImagesResult;
import com.pulumi.linode.outputs.GetInstanceBackupsResult;
import com.pulumi.linode.outputs.GetInstanceNetworkingResult;
import com.pulumi.linode.outputs.GetInstanceTypeResult;
import com.pulumi.linode.outputs.GetInstanceTypesResult;
import com.pulumi.linode.outputs.GetInstancesResult;
import com.pulumi.linode.outputs.GetIpv6RangeResult;
import com.pulumi.linode.outputs.GetIpv6RangesResult;
import com.pulumi.linode.outputs.GetKernelResult;
import com.pulumi.linode.outputs.GetKernelsResult;
import com.pulumi.linode.outputs.GetLinodeObjectStorageBucketResult;
import com.pulumi.linode.outputs.GetLkeClusterResult;
import com.pulumi.linode.outputs.GetLkeClustersResult;
import com.pulumi.linode.outputs.GetLkeTypesResult;
import com.pulumi.linode.outputs.GetLkeVersionResult;
import com.pulumi.linode.outputs.GetLkeVersionsResult;
import com.pulumi.linode.outputs.GetNbTypesResult;
import com.pulumi.linode.outputs.GetNetworkTransferPricesResult;
import com.pulumi.linode.outputs.GetNetworkingIpResult;
import com.pulumi.linode.outputs.GetNetworkingIpsResult;
import com.pulumi.linode.outputs.GetNodeBalancerConfigResult;
import com.pulumi.linode.outputs.GetNodeBalancerNodeResult;
import com.pulumi.linode.outputs.GetNodeBalancerResult;
import com.pulumi.linode.outputs.GetNodebalancerConfigsResult;
import com.pulumi.linode.outputs.GetNodebalancersResult;
import com.pulumi.linode.outputs.GetObjectStorageClusterResult;
import com.pulumi.linode.outputs.GetObjectStorageEndpointsResult;
import com.pulumi.linode.outputs.GetObjectStorageQuotaResult;
import com.pulumi.linode.outputs.GetObjectStorageQuotasResult;
import com.pulumi.linode.outputs.GetPlacementGroupResult;
import com.pulumi.linode.outputs.GetPlacementGroupsResult;
import com.pulumi.linode.outputs.GetProfileResult;
import com.pulumi.linode.outputs.GetRegionResult;
import com.pulumi.linode.outputs.GetRegionsResult;
import com.pulumi.linode.outputs.GetSshKeyResult;
import com.pulumi.linode.outputs.GetSshkeysResult;
import com.pulumi.linode.outputs.GetStackScriptResult;
import com.pulumi.linode.outputs.GetStackScriptsResult;
import com.pulumi.linode.outputs.GetUserResult;
import com.pulumi.linode.outputs.GetUsersResult;
import com.pulumi.linode.outputs.GetVlansResult;
import com.pulumi.linode.outputs.GetVolumeResult;
import com.pulumi.linode.outputs.GetVolumeTypesResult;
import com.pulumi.linode.outputs.GetVolumesResult;
import com.pulumi.linode.outputs.GetVpcIpsResult;
import com.pulumi.linode.outputs.GetVpcResult;
import com.pulumi.linode.outputs.GetVpcSubnetResult;
import com.pulumi.linode.outputs.GetVpcSubnetsResult;
import com.pulumi.linode.outputs.GetVpcsResult;
import com.pulumi.resources.InvokeArgs;
import java.util.concurrent.CompletableFuture;

public final class LinodeFunctions {
    /**
     * Provides information about a Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getAccount(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountResult> getAccount() {
        return getAccount(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getAccount(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountResult> getAccountPlain() {
        return getAccountPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getAccount(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountResult> getAccount(InvokeArgs args) {
        return getAccount(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getAccount(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountResult> getAccountPlain(InvokeArgs args) {
        return getAccountPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getAccount(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountResult> getAccount(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccount:getAccount", TypeShape.of(GetAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getAccount(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountResult> getAccount(InvokeArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccount:getAccount", TypeShape.of(GetAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getAccount(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountResult> getAccountPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getAccount:getAccount", TypeShape.of(GetAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about services availabilities for the current Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to discover regions without specific service availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilitiesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-availabilities = LinodeFunctions.getAccountAvailabilities(GetAccountAvailabilitiesArgs.builder()
     *             .filters(GetAccountAvailabilitiesFilterArgs.builder()
     *                 .name("unavailable")
     *                 .values("Linodes")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("regions-without-linodes", filtered_availabilities.availabilities().stream().map(element -> element.region()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `region`
     * 
     * * `unavailable`
     * 
     * * `available`
     * 
     */
    public static Output<GetAccountAvailabilitiesResult> getAccountAvailabilities() {
        return getAccountAvailabilities(GetAccountAvailabilitiesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about services availabilities for the current Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to discover regions without specific service availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilitiesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-availabilities = LinodeFunctions.getAccountAvailabilities(GetAccountAvailabilitiesArgs.builder()
     *             .filters(GetAccountAvailabilitiesFilterArgs.builder()
     *                 .name("unavailable")
     *                 .values("Linodes")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("regions-without-linodes", filtered_availabilities.availabilities().stream().map(element -> element.region()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `region`
     * 
     * * `unavailable`
     * 
     * * `available`
     * 
     */
    public static CompletableFuture<GetAccountAvailabilitiesResult> getAccountAvailabilitiesPlain() {
        return getAccountAvailabilitiesPlain(GetAccountAvailabilitiesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about services availabilities for the current Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to discover regions without specific service availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilitiesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-availabilities = LinodeFunctions.getAccountAvailabilities(GetAccountAvailabilitiesArgs.builder()
     *             .filters(GetAccountAvailabilitiesFilterArgs.builder()
     *                 .name("unavailable")
     *                 .values("Linodes")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("regions-without-linodes", filtered_availabilities.availabilities().stream().map(element -> element.region()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `region`
     * 
     * * `unavailable`
     * 
     * * `available`
     * 
     */
    public static Output<GetAccountAvailabilitiesResult> getAccountAvailabilities(GetAccountAvailabilitiesArgs args) {
        return getAccountAvailabilities(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about services availabilities for the current Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to discover regions without specific service availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilitiesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-availabilities = LinodeFunctions.getAccountAvailabilities(GetAccountAvailabilitiesArgs.builder()
     *             .filters(GetAccountAvailabilitiesFilterArgs.builder()
     *                 .name("unavailable")
     *                 .values("Linodes")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("regions-without-linodes", filtered_availabilities.availabilities().stream().map(element -> element.region()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `region`
     * 
     * * `unavailable`
     * 
     * * `available`
     * 
     */
    public static CompletableFuture<GetAccountAvailabilitiesResult> getAccountAvailabilitiesPlain(GetAccountAvailabilitiesPlainArgs args) {
        return getAccountAvailabilitiesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about services availabilities for the current Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to discover regions without specific service availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilitiesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-availabilities = LinodeFunctions.getAccountAvailabilities(GetAccountAvailabilitiesArgs.builder()
     *             .filters(GetAccountAvailabilitiesFilterArgs.builder()
     *                 .name("unavailable")
     *                 .values("Linodes")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("regions-without-linodes", filtered_availabilities.availabilities().stream().map(element -> element.region()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `region`
     * 
     * * `unavailable`
     * 
     * * `available`
     * 
     */
    public static Output<GetAccountAvailabilitiesResult> getAccountAvailabilities(GetAccountAvailabilitiesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccountAvailabilities:getAccountAvailabilities", TypeShape.of(GetAccountAvailabilitiesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about services availabilities for the current Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to discover regions without specific service availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilitiesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-availabilities = LinodeFunctions.getAccountAvailabilities(GetAccountAvailabilitiesArgs.builder()
     *             .filters(GetAccountAvailabilitiesFilterArgs.builder()
     *                 .name("unavailable")
     *                 .values("Linodes")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("regions-without-linodes", filtered_availabilities.availabilities().stream().map(element -> element.region()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `region`
     * 
     * * `unavailable`
     * 
     * * `available`
     * 
     */
    public static Output<GetAccountAvailabilitiesResult> getAccountAvailabilities(GetAccountAvailabilitiesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccountAvailabilities:getAccountAvailabilities", TypeShape.of(GetAccountAvailabilitiesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about services availabilities for the current Linode account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to discover regions without specific service availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilitiesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-availabilities = LinodeFunctions.getAccountAvailabilities(GetAccountAvailabilitiesArgs.builder()
     *             .filters(GetAccountAvailabilitiesFilterArgs.builder()
     *                 .name("unavailable")
     *                 .values("Linodes")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("regions-without-linodes", filtered_availabilities.availabilities().stream().map(element -> element.region()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `region`
     * 
     * * `unavailable`
     * 
     * * `available`
     * 
     */
    public static CompletableFuture<GetAccountAvailabilitiesResult> getAccountAvailabilitiesPlain(GetAccountAvailabilitiesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getAccountAvailabilities:getAccountAvailabilities", TypeShape.of(GetAccountAvailabilitiesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about service availability in a region to an account specifically.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myAccountAvailability = LinodeFunctions.getAccountAvailability(GetAccountAvailabilityArgs.builder()
     *             .region("us-east")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountAvailabilityResult> getAccountAvailability(GetAccountAvailabilityArgs args) {
        return getAccountAvailability(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about service availability in a region to an account specifically.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myAccountAvailability = LinodeFunctions.getAccountAvailability(GetAccountAvailabilityArgs.builder()
     *             .region("us-east")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountAvailabilityResult> getAccountAvailabilityPlain(GetAccountAvailabilityPlainArgs args) {
        return getAccountAvailabilityPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about service availability in a region to an account specifically.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myAccountAvailability = LinodeFunctions.getAccountAvailability(GetAccountAvailabilityArgs.builder()
     *             .region("us-east")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountAvailabilityResult> getAccountAvailability(GetAccountAvailabilityArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccountAvailability:getAccountAvailability", TypeShape.of(GetAccountAvailabilityResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about service availability in a region to an account specifically.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myAccountAvailability = LinodeFunctions.getAccountAvailability(GetAccountAvailabilityArgs.builder()
     *             .region("us-east")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountAvailabilityResult> getAccountAvailability(GetAccountAvailabilityArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccountAvailability:getAccountAvailability", TypeShape.of(GetAccountAvailabilityResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about service availability in a region to an account specifically.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-availability).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account availability.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountAvailabilityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myAccountAvailability = LinodeFunctions.getAccountAvailability(GetAccountAvailabilityArgs.builder()
     *             .region("us-east")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountAvailabilityResult> getAccountAvailabilityPlain(GetAccountAvailabilityPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getAccountAvailability:getAccountAvailability", TypeShape.of(GetAccountAvailabilityResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a specific Linode account login.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-login).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myAccountLogin = LinodeFunctions.getAccountLogin(GetAccountLoginArgs.builder()
     *             .id(123456)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountLoginResult> getAccountLogin(GetAccountLoginArgs args) {
        return getAccountLogin(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a specific Linode account login.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-login).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myAccountLogin = LinodeFunctions.getAccountLogin(GetAccountLoginArgs.builder()
     *             .id(123456)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountLoginResult> getAccountLoginPlain(GetAccountLoginPlainArgs args) {
        return getAccountLoginPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a specific Linode account login.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-login).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myAccountLogin = LinodeFunctions.getAccountLogin(GetAccountLoginArgs.builder()
     *             .id(123456)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountLoginResult> getAccountLogin(GetAccountLoginArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccountLogin:getAccountLogin", TypeShape.of(GetAccountLoginResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a specific Linode account login.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-login).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myAccountLogin = LinodeFunctions.getAccountLogin(GetAccountLoginArgs.builder()
     *             .id(123456)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountLoginResult> getAccountLogin(GetAccountLoginArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccountLogin:getAccountLogin", TypeShape.of(GetAccountLoginResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a specific Linode account login.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-login).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myAccountLogin = LinodeFunctions.getAccountLogin(GetAccountLoginArgs.builder()
     *             .id(123456)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountLoginResult> getAccountLoginPlain(GetAccountLoginPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getAccountLogin:getAccountLogin", TypeShape.of(GetAccountLoginResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode account logins that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-logins).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-account-logins = LinodeFunctions.getAccountLogins(GetAccountLoginsArgs.builder()
     *             .filters(            
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("restricted")
     *                     .values("true")
     *                     .build(),
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("username")
     *                     .values("myUsername")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("loginIds", filtered_account_logins.logins().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `ip`
     * 
     * * `restricted`
     * 
     * * `username`
     * 
     */
    public static Output<GetAccountLoginsResult> getAccountLogins() {
        return getAccountLogins(GetAccountLoginsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode account logins that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-logins).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-account-logins = LinodeFunctions.getAccountLogins(GetAccountLoginsArgs.builder()
     *             .filters(            
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("restricted")
     *                     .values("true")
     *                     .build(),
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("username")
     *                     .values("myUsername")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("loginIds", filtered_account_logins.logins().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `ip`
     * 
     * * `restricted`
     * 
     * * `username`
     * 
     */
    public static CompletableFuture<GetAccountLoginsResult> getAccountLoginsPlain() {
        return getAccountLoginsPlain(GetAccountLoginsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode account logins that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-logins).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-account-logins = LinodeFunctions.getAccountLogins(GetAccountLoginsArgs.builder()
     *             .filters(            
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("restricted")
     *                     .values("true")
     *                     .build(),
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("username")
     *                     .values("myUsername")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("loginIds", filtered_account_logins.logins().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `ip`
     * 
     * * `restricted`
     * 
     * * `username`
     * 
     */
    public static Output<GetAccountLoginsResult> getAccountLogins(GetAccountLoginsArgs args) {
        return getAccountLogins(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode account logins that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-logins).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-account-logins = LinodeFunctions.getAccountLogins(GetAccountLoginsArgs.builder()
     *             .filters(            
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("restricted")
     *                     .values("true")
     *                     .build(),
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("username")
     *                     .values("myUsername")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("loginIds", filtered_account_logins.logins().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `ip`
     * 
     * * `restricted`
     * 
     * * `username`
     * 
     */
    public static CompletableFuture<GetAccountLoginsResult> getAccountLoginsPlain(GetAccountLoginsPlainArgs args) {
        return getAccountLoginsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode account logins that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-logins).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-account-logins = LinodeFunctions.getAccountLogins(GetAccountLoginsArgs.builder()
     *             .filters(            
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("restricted")
     *                     .values("true")
     *                     .build(),
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("username")
     *                     .values("myUsername")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("loginIds", filtered_account_logins.logins().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `ip`
     * 
     * * `restricted`
     * 
     * * `username`
     * 
     */
    public static Output<GetAccountLoginsResult> getAccountLogins(GetAccountLoginsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccountLogins:getAccountLogins", TypeShape.of(GetAccountLoginsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode account logins that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-logins).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-account-logins = LinodeFunctions.getAccountLogins(GetAccountLoginsArgs.builder()
     *             .filters(            
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("restricted")
     *                     .values("true")
     *                     .build(),
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("username")
     *                     .values("myUsername")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("loginIds", filtered_account_logins.logins().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `ip`
     * 
     * * `restricted`
     * 
     * * `username`
     * 
     */
    public static Output<GetAccountLoginsResult> getAccountLogins(GetAccountLoginsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccountLogins:getAccountLogins", TypeShape.of(GetAccountLoginsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode account logins that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-logins).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode account login.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetAccountLoginsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-account-logins = LinodeFunctions.getAccountLogins(GetAccountLoginsArgs.builder()
     *             .filters(            
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("restricted")
     *                     .values("true")
     *                     .build(),
     *                 GetAccountLoginsFilterArgs.builder()
     *                     .name("username")
     *                     .values("myUsername")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("loginIds", filtered_account_logins.logins().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `ip`
     * 
     * * `restricted`
     * 
     * * `username`
     * 
     */
    public static CompletableFuture<GetAccountLoginsResult> getAccountLoginsPlain(GetAccountLoginsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getAccountLogins:getAccountLogins", TypeShape.of(GetAccountLoginsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode account settings.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-settings).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about Linode account settings.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getAccountSettings(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountSettingsResult> getAccountSettings() {
        return getAccountSettings(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode account settings.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-settings).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about Linode account settings.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getAccountSettings(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountSettingsResult> getAccountSettingsPlain() {
        return getAccountSettingsPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode account settings.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-settings).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about Linode account settings.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getAccountSettings(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountSettingsResult> getAccountSettings(InvokeArgs args) {
        return getAccountSettings(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode account settings.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-settings).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about Linode account settings.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getAccountSettings(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountSettingsResult> getAccountSettingsPlain(InvokeArgs args) {
        return getAccountSettingsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode account settings.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-settings).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about Linode account settings.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getAccountSettings(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountSettingsResult> getAccountSettings(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccountSettings:getAccountSettings", TypeShape.of(GetAccountSettingsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode account settings.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-settings).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about Linode account settings.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getAccountSettings(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountSettingsResult> getAccountSettings(InvokeArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getAccountSettings:getAccountSettings", TypeShape.of(GetAccountSettingsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode account settings.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-account-settings).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about Linode account settings.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getAccountSettings(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountSettingsResult> getAccountSettingsPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getAccountSettings:getAccountSettings", TypeShape.of(GetAccountSettingsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Child Account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access child account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getChildAccount(GetChildAccountArgs.builder()
     *             .euuid("FFFFFFFF-FFFF-FFFF-FFFFFFFFFFFFFFFF")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetChildAccountResult> getChildAccount(GetChildAccountArgs args) {
        return getChildAccount(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Child Account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access child account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getChildAccount(GetChildAccountArgs.builder()
     *             .euuid("FFFFFFFF-FFFF-FFFF-FFFFFFFFFFFFFFFF")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetChildAccountResult> getChildAccountPlain(GetChildAccountPlainArgs args) {
        return getChildAccountPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Child Account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access child account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getChildAccount(GetChildAccountArgs.builder()
     *             .euuid("FFFFFFFF-FFFF-FFFF-FFFFFFFFFFFFFFFF")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetChildAccountResult> getChildAccount(GetChildAccountArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getChildAccount:getChildAccount", TypeShape.of(GetChildAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Child Account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access child account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getChildAccount(GetChildAccountArgs.builder()
     *             .euuid("FFFFFFFF-FFFF-FFFF-FFFFFFFFFFFFFFFF")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetChildAccountResult> getChildAccount(GetChildAccountArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getChildAccount:getChildAccount", TypeShape.of(GetChildAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Child Account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-account).
     * 
     * Due to the sensitive nature of the data exposed by this data source, it should not be used in conjunction with the `LINODE_DEBUG` option.  See the [debugging notes](https://www.terraform.io/providers/linode/linode/latest/docs#debugging) for more details.
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access child account details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = LinodeFunctions.getChildAccount(GetChildAccountArgs.builder()
     *             .euuid("FFFFFFFF-FFFF-FFFF-FFFFFFFFFFFFFFFF")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetChildAccountResult> getChildAccountPlain(GetChildAccountPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getChildAccount:getChildAccount", TypeShape.of(GetChildAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Child Accounts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-accounts).
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access Child Accounts under the current Account.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var all = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .filters(            
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("email")
     *                     .values("example}{@literal @}{@code linode.com")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("first_name")
     *                     .values("John")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("last_name")
     *                     .values("Smith")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("allAccounts", all.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *         ctx.export("filteredAccounts", filtered.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `euuid`
     * 
     * * `email`
     * 
     * * `first_name`
     * 
     * * `last_name`
     * 
     * * `company`
     * 
     * * `address_1`
     * 
     * * `address_2`
     * 
     * * `phone`
     * 
     * * `city`
     * 
     * * `state`
     * 
     * * `country`
     * 
     * * `zip`
     * 
     * * `capabilities`
     * 
     * * `active_since`
     * 
     */
    public static Output<GetChildAccountsResult> getChildAccounts() {
        return getChildAccounts(GetChildAccountsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Child Accounts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-accounts).
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access Child Accounts under the current Account.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var all = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .filters(            
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("email")
     *                     .values("example}{@literal @}{@code linode.com")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("first_name")
     *                     .values("John")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("last_name")
     *                     .values("Smith")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("allAccounts", all.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *         ctx.export("filteredAccounts", filtered.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `euuid`
     * 
     * * `email`
     * 
     * * `first_name`
     * 
     * * `last_name`
     * 
     * * `company`
     * 
     * * `address_1`
     * 
     * * `address_2`
     * 
     * * `phone`
     * 
     * * `city`
     * 
     * * `state`
     * 
     * * `country`
     * 
     * * `zip`
     * 
     * * `capabilities`
     * 
     * * `active_since`
     * 
     */
    public static CompletableFuture<GetChildAccountsResult> getChildAccountsPlain() {
        return getChildAccountsPlain(GetChildAccountsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Child Accounts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-accounts).
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access Child Accounts under the current Account.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var all = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .filters(            
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("email")
     *                     .values("example}{@literal @}{@code linode.com")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("first_name")
     *                     .values("John")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("last_name")
     *                     .values("Smith")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("allAccounts", all.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *         ctx.export("filteredAccounts", filtered.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `euuid`
     * 
     * * `email`
     * 
     * * `first_name`
     * 
     * * `last_name`
     * 
     * * `company`
     * 
     * * `address_1`
     * 
     * * `address_2`
     * 
     * * `phone`
     * 
     * * `city`
     * 
     * * `state`
     * 
     * * `country`
     * 
     * * `zip`
     * 
     * * `capabilities`
     * 
     * * `active_since`
     * 
     */
    public static Output<GetChildAccountsResult> getChildAccounts(GetChildAccountsArgs args) {
        return getChildAccounts(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Child Accounts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-accounts).
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access Child Accounts under the current Account.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var all = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .filters(            
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("email")
     *                     .values("example}{@literal @}{@code linode.com")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("first_name")
     *                     .values("John")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("last_name")
     *                     .values("Smith")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("allAccounts", all.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *         ctx.export("filteredAccounts", filtered.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `euuid`
     * 
     * * `email`
     * 
     * * `first_name`
     * 
     * * `last_name`
     * 
     * * `company`
     * 
     * * `address_1`
     * 
     * * `address_2`
     * 
     * * `phone`
     * 
     * * `city`
     * 
     * * `state`
     * 
     * * `country`
     * 
     * * `zip`
     * 
     * * `capabilities`
     * 
     * * `active_since`
     * 
     */
    public static CompletableFuture<GetChildAccountsResult> getChildAccountsPlain(GetChildAccountsPlainArgs args) {
        return getChildAccountsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Child Accounts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-accounts).
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access Child Accounts under the current Account.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var all = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .filters(            
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("email")
     *                     .values("example}{@literal @}{@code linode.com")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("first_name")
     *                     .values("John")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("last_name")
     *                     .values("Smith")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("allAccounts", all.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *         ctx.export("filteredAccounts", filtered.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `euuid`
     * 
     * * `email`
     * 
     * * `first_name`
     * 
     * * `last_name`
     * 
     * * `company`
     * 
     * * `address_1`
     * 
     * * `address_2`
     * 
     * * `phone`
     * 
     * * `city`
     * 
     * * `state`
     * 
     * * `country`
     * 
     * * `zip`
     * 
     * * `capabilities`
     * 
     * * `active_since`
     * 
     */
    public static Output<GetChildAccountsResult> getChildAccounts(GetChildAccountsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getChildAccounts:getChildAccounts", TypeShape.of(GetChildAccountsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Child Accounts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-accounts).
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access Child Accounts under the current Account.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var all = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .filters(            
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("email")
     *                     .values("example}{@literal @}{@code linode.com")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("first_name")
     *                     .values("John")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("last_name")
     *                     .values("Smith")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("allAccounts", all.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *         ctx.export("filteredAccounts", filtered.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `euuid`
     * 
     * * `email`
     * 
     * * `first_name`
     * 
     * * `last_name`
     * 
     * * `company`
     * 
     * * `address_1`
     * 
     * * `address_2`
     * 
     * * `phone`
     * 
     * * `city`
     * 
     * * `state`
     * 
     * * `country`
     * 
     * * `zip`
     * 
     * * `capabilities`
     * 
     * * `active_since`
     * 
     */
    public static Output<GetChildAccountsResult> getChildAccounts(GetChildAccountsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getChildAccounts:getChildAccounts", TypeShape.of(GetChildAccountsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Child Accounts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-child-accounts).
     * 
     * **NOTE: Parent/Child related features may not be generally available.**
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access Child Accounts under the current Account.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetChildAccountsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var all = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getChildAccounts(GetChildAccountsArgs.builder()
     *             .filters(            
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("email")
     *                     .values("example}{@literal @}{@code linode.com")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("first_name")
     *                     .values("John")
     *                     .build(),
     *                 GetChildAccountsFilterArgs.builder()
     *                     .name("last_name")
     *                     .values("Smith")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("allAccounts", all.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *         ctx.export("filteredAccounts", filtered.childAccounts().stream().map(element -> element.euuid()).collect(toList()));
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `euuid`
     * 
     * * `email`
     * 
     * * `first_name`
     * 
     * * `last_name`
     * 
     * * `company`
     * 
     * * `address_1`
     * 
     * * `address_2`
     * 
     * * `phone`
     * 
     * * `city`
     * 
     * * `state`
     * 
     * * `country`
     * 
     * * `zip`
     * 
     * * `capabilities`
     * 
     * * `active_since`
     * 
     */
    public static CompletableFuture<GetChildAccountsResult> getChildAccountsPlain(GetChildAccountsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getChildAccounts:getChildAccounts", TypeShape.of(GetChildAccountsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated.
     * 
     * Provides information about Linode Database Backups that match a set of filters.
     * For more information, see the Linode APIv4 docs for [MySQL](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-backups) and [PostgreSQL](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about all backups for a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-backups = LinodeFunctions.getDatabaseBackups(GetDatabaseBackupsArgs.builder()
     *             .databaseId(12345)
     *             .databaseType("mysql")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all automatic PostgreSQL Database Backups:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var auto-backups = LinodeFunctions.getDatabaseBackups(GetDatabaseBackupsArgs.builder()
     *             .databaseId(12345)
     *             .databaseType("postgresql")
     *             .filters(GetDatabaseBackupsFilterArgs.builder()
     *                 .name("type")
     *                 .values("auto")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabaseBackupsResult> getDatabaseBackups(GetDatabaseBackupsArgs args) {
        return getDatabaseBackups(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated.
     * 
     * Provides information about Linode Database Backups that match a set of filters.
     * For more information, see the Linode APIv4 docs for [MySQL](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-backups) and [PostgreSQL](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about all backups for a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-backups = LinodeFunctions.getDatabaseBackups(GetDatabaseBackupsArgs.builder()
     *             .databaseId(12345)
     *             .databaseType("mysql")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all automatic PostgreSQL Database Backups:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var auto-backups = LinodeFunctions.getDatabaseBackups(GetDatabaseBackupsArgs.builder()
     *             .databaseId(12345)
     *             .databaseType("postgresql")
     *             .filters(GetDatabaseBackupsFilterArgs.builder()
     *                 .name("type")
     *                 .values("auto")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDatabaseBackupsResult> getDatabaseBackupsPlain(GetDatabaseBackupsPlainArgs args) {
        return getDatabaseBackupsPlain(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated.
     * 
     * Provides information about Linode Database Backups that match a set of filters.
     * For more information, see the Linode APIv4 docs for [MySQL](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-backups) and [PostgreSQL](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about all backups for a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-backups = LinodeFunctions.getDatabaseBackups(GetDatabaseBackupsArgs.builder()
     *             .databaseId(12345)
     *             .databaseType("mysql")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all automatic PostgreSQL Database Backups:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var auto-backups = LinodeFunctions.getDatabaseBackups(GetDatabaseBackupsArgs.builder()
     *             .databaseId(12345)
     *             .databaseType("postgresql")
     *             .filters(GetDatabaseBackupsFilterArgs.builder()
     *                 .name("type")
     *                 .values("auto")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabaseBackupsResult> getDatabaseBackups(GetDatabaseBackupsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseBackups:getDatabaseBackups", TypeShape.of(GetDatabaseBackupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated.
     * 
     * Provides information about Linode Database Backups that match a set of filters.
     * For more information, see the Linode APIv4 docs for [MySQL](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-backups) and [PostgreSQL](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about all backups for a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-backups = LinodeFunctions.getDatabaseBackups(GetDatabaseBackupsArgs.builder()
     *             .databaseId(12345)
     *             .databaseType("mysql")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all automatic PostgreSQL Database Backups:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var auto-backups = LinodeFunctions.getDatabaseBackups(GetDatabaseBackupsArgs.builder()
     *             .databaseId(12345)
     *             .databaseType("postgresql")
     *             .filters(GetDatabaseBackupsFilterArgs.builder()
     *                 .name("type")
     *                 .values("auto")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabaseBackupsResult> getDatabaseBackups(GetDatabaseBackupsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseBackups:getDatabaseBackups", TypeShape.of(GetDatabaseBackupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated.
     * 
     * Provides information about Linode Database Backups that match a set of filters.
     * For more information, see the Linode APIv4 docs for [MySQL](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-backups) and [PostgreSQL](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about all backups for a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-backups = LinodeFunctions.getDatabaseBackups(GetDatabaseBackupsArgs.builder()
     *             .databaseId(12345)
     *             .databaseType("mysql")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all automatic PostgreSQL Database Backups:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var auto-backups = LinodeFunctions.getDatabaseBackups(GetDatabaseBackupsArgs.builder()
     *             .databaseId(12345)
     *             .databaseType("postgresql")
     *             .filters(GetDatabaseBackupsFilterArgs.builder()
     *                 .name("type")
     *                 .values("auto")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDatabaseBackupsResult> getDatabaseBackupsPlain(GetDatabaseBackupsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDatabaseBackups:getDatabaseBackups", TypeShape.of(GetDatabaseBackupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Managed Database engines that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-engines).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .build());
     * 
     *         ctx.export("engineIds", all.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("engineIds", mysql.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Create a Linode MySQL Database using the latest support MySQL version:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import com.pulumi.linode.DatabaseMysql;
     * import com.pulumi.linode.DatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .latest(true)
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         var myDb = new DatabaseMysql("myDb", DatabaseMysqlArgs.builder()
     *             .label("mydb")
     *             .engineId(mysql.engines()[0].id())
     *             .region("us-southeast")
     *             .type("g6-nanode-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabaseEnginesResult> getDatabaseEngines() {
        return getDatabaseEngines(GetDatabaseEnginesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Managed Database engines that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-engines).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .build());
     * 
     *         ctx.export("engineIds", all.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("engineIds", mysql.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Create a Linode MySQL Database using the latest support MySQL version:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import com.pulumi.linode.DatabaseMysql;
     * import com.pulumi.linode.DatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .latest(true)
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         var myDb = new DatabaseMysql("myDb", DatabaseMysqlArgs.builder()
     *             .label("mydb")
     *             .engineId(mysql.engines()[0].id())
     *             .region("us-southeast")
     *             .type("g6-nanode-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDatabaseEnginesResult> getDatabaseEnginesPlain() {
        return getDatabaseEnginesPlain(GetDatabaseEnginesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Managed Database engines that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-engines).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .build());
     * 
     *         ctx.export("engineIds", all.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("engineIds", mysql.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Create a Linode MySQL Database using the latest support MySQL version:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import com.pulumi.linode.DatabaseMysql;
     * import com.pulumi.linode.DatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .latest(true)
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         var myDb = new DatabaseMysql("myDb", DatabaseMysqlArgs.builder()
     *             .label("mydb")
     *             .engineId(mysql.engines()[0].id())
     *             .region("us-southeast")
     *             .type("g6-nanode-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabaseEnginesResult> getDatabaseEngines(GetDatabaseEnginesArgs args) {
        return getDatabaseEngines(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Managed Database engines that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-engines).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .build());
     * 
     *         ctx.export("engineIds", all.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("engineIds", mysql.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Create a Linode MySQL Database using the latest support MySQL version:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import com.pulumi.linode.DatabaseMysql;
     * import com.pulumi.linode.DatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .latest(true)
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         var myDb = new DatabaseMysql("myDb", DatabaseMysqlArgs.builder()
     *             .label("mydb")
     *             .engineId(mysql.engines()[0].id())
     *             .region("us-southeast")
     *             .type("g6-nanode-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDatabaseEnginesResult> getDatabaseEnginesPlain(GetDatabaseEnginesPlainArgs args) {
        return getDatabaseEnginesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Managed Database engines that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-engines).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .build());
     * 
     *         ctx.export("engineIds", all.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("engineIds", mysql.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Create a Linode MySQL Database using the latest support MySQL version:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import com.pulumi.linode.DatabaseMysql;
     * import com.pulumi.linode.DatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .latest(true)
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         var myDb = new DatabaseMysql("myDb", DatabaseMysqlArgs.builder()
     *             .label("mydb")
     *             .engineId(mysql.engines()[0].id())
     *             .region("us-southeast")
     *             .type("g6-nanode-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabaseEnginesResult> getDatabaseEngines(GetDatabaseEnginesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseEngines:getDatabaseEngines", TypeShape.of(GetDatabaseEnginesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Managed Database engines that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-engines).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .build());
     * 
     *         ctx.export("engineIds", all.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("engineIds", mysql.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Create a Linode MySQL Database using the latest support MySQL version:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import com.pulumi.linode.DatabaseMysql;
     * import com.pulumi.linode.DatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .latest(true)
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         var myDb = new DatabaseMysql("myDb", DatabaseMysqlArgs.builder()
     *             .label("mydb")
     *             .engineId(mysql.engines()[0].id())
     *             .region("us-southeast")
     *             .type("g6-nanode-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabaseEnginesResult> getDatabaseEngines(GetDatabaseEnginesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseEngines:getDatabaseEngines", TypeShape.of(GetDatabaseEnginesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Managed Database engines that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-engines).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .build());
     * 
     *         ctx.export("engineIds", all.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Database engines:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("engineIds", mysql.engines().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Create a Linode MySQL Database using the latest support MySQL version:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseEnginesArgs;
     * import com.pulumi.linode.DatabaseMysql;
     * import com.pulumi.linode.DatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabaseEngines(GetDatabaseEnginesArgs.builder()
     *             .latest(true)
     *             .filters(GetDatabaseEnginesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         var myDb = new DatabaseMysql("myDb", DatabaseMysqlArgs.builder()
     *             .label("mydb")
     *             .engineId(mysql.engines()[0].id())
     *             .region("us-southeast")
     *             .type("g6-nanode-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDatabaseEnginesResult> getDatabaseEnginesPlain(GetDatabaseEnginesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDatabaseEngines:getDatabaseEngines", TypeShape.of(GetDatabaseEnginesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabaseMysqlV2 for all future implementations.
     * 
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysql(GetDatabaseMysqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static Output<GetDatabaseMysqlResult> getDatabaseMysql() {
        return getDatabaseMysql(GetDatabaseMysqlArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabaseMysqlV2 for all future implementations.
     * 
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysql(GetDatabaseMysqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static CompletableFuture<GetDatabaseMysqlResult> getDatabaseMysqlPlain() {
        return getDatabaseMysqlPlain(GetDatabaseMysqlPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabaseMysqlV2 for all future implementations.
     * 
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysql(GetDatabaseMysqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static Output<GetDatabaseMysqlResult> getDatabaseMysql(GetDatabaseMysqlArgs args) {
        return getDatabaseMysql(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabaseMysqlV2 for all future implementations.
     * 
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysql(GetDatabaseMysqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static CompletableFuture<GetDatabaseMysqlResult> getDatabaseMysqlPlain(GetDatabaseMysqlPlainArgs args) {
        return getDatabaseMysqlPlain(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabaseMysqlV2 for all future implementations.
     * 
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysql(GetDatabaseMysqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static Output<GetDatabaseMysqlResult> getDatabaseMysql(GetDatabaseMysqlArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseMysql:getDatabaseMysql", TypeShape.of(GetDatabaseMysqlResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabaseMysqlV2 for all future implementations.
     * 
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysql(GetDatabaseMysqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static Output<GetDatabaseMysqlResult> getDatabaseMysql(GetDatabaseMysqlArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseMysql:getDatabaseMysql", TypeShape.of(GetDatabaseMysqlResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabaseMysqlV2 for all future implementations.
     * 
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysql(GetDatabaseMysqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static CompletableFuture<GetDatabaseMysqlResult> getDatabaseMysqlPlain(GetDatabaseMysqlPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDatabaseMysql:getDatabaseMysql", TypeShape.of(GetDatabaseMysqlResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated.
     * 
     * Provides information about Linode MySQL Database Backups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about all backups for a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-backups = LinodeFunctions.getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs.builder()
     *             .databaseId(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all automatic MySQL Database Backups:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var auto-backups = LinodeFunctions.getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs.builder()
     *             .databaseId(12345)
     *             .filters(GetDatabaseMysqlBackupsFilterArgs.builder()
     *                 .name("type")
     *                 .values("auto")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabaseMysqlBackupsResult> getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs args) {
        return getDatabaseMysqlBackups(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated.
     * 
     * Provides information about Linode MySQL Database Backups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about all backups for a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-backups = LinodeFunctions.getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs.builder()
     *             .databaseId(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all automatic MySQL Database Backups:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var auto-backups = LinodeFunctions.getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs.builder()
     *             .databaseId(12345)
     *             .filters(GetDatabaseMysqlBackupsFilterArgs.builder()
     *                 .name("type")
     *                 .values("auto")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDatabaseMysqlBackupsResult> getDatabaseMysqlBackupsPlain(GetDatabaseMysqlBackupsPlainArgs args) {
        return getDatabaseMysqlBackupsPlain(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated.
     * 
     * Provides information about Linode MySQL Database Backups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about all backups for a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-backups = LinodeFunctions.getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs.builder()
     *             .databaseId(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all automatic MySQL Database Backups:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var auto-backups = LinodeFunctions.getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs.builder()
     *             .databaseId(12345)
     *             .filters(GetDatabaseMysqlBackupsFilterArgs.builder()
     *                 .name("type")
     *                 .values("auto")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabaseMysqlBackupsResult> getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseMysqlBackups:getDatabaseMysqlBackups", TypeShape.of(GetDatabaseMysqlBackupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated.
     * 
     * Provides information about Linode MySQL Database Backups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about all backups for a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-backups = LinodeFunctions.getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs.builder()
     *             .databaseId(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all automatic MySQL Database Backups:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var auto-backups = LinodeFunctions.getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs.builder()
     *             .databaseId(12345)
     *             .filters(GetDatabaseMysqlBackupsFilterArgs.builder()
     *                 .name("type")
     *                 .values("auto")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabaseMysqlBackupsResult> getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseMysqlBackups:getDatabaseMysqlBackups", TypeShape.of(GetDatabaseMysqlBackupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated.
     * 
     * Provides information about Linode MySQL Database Backups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about all backups for a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-backups = LinodeFunctions.getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs.builder()
     *             .databaseId(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all automatic MySQL Database Backups:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var auto-backups = LinodeFunctions.getDatabaseMysqlBackups(GetDatabaseMysqlBackupsArgs.builder()
     *             .databaseId(12345)
     *             .filters(GetDatabaseMysqlBackupsFilterArgs.builder()
     *                 .name("type")
     *                 .values("auto")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDatabaseMysqlBackupsResult> getDatabaseMysqlBackupsPlain(GetDatabaseMysqlBackupsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDatabaseMysqlBackups:getDatabaseMysqlBackups", TypeShape.of(GetDatabaseMysqlBackupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode MySQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabaseMysqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## binlog_retention_period
     * 
     * The following arguments are supported in the `binlog_retention_period` specification block:
     * 
     * * `description` - The description of `binlog_retention_period`.
     * 
     * * `example` - An example of a valid value for `binlog_retention_period`.
     * 
     * * `maximum` - The maximum valid value of `binlog_retention_period`.
     * 
     * * `minimum` - The minimum valid value of `binlog_retention_period`.
     * 
     * * `requires_restart` - Whether changing the value `binlog_retention_period` requires the DB to restart.
     * 
     * * `type` - The type of the value of `binlog_retention_period`.
     * 
     * ## mysql
     * 
     * The following arguments are supported in the `mysql` specification block:
     * 
     * * `connect_timeout` - The number of seconds that the mysqld server waits for a connect packet before responding with &#34;Bad handshake&#34;.
     * 
     * * `default_time_zone` - Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or `SYSTEM` to use the MySQL server default.
     * 
     * * `group_concat_max_len` - The maximum permitted result length in bytes for the `GROUP_CONCAT()` function.
     * 
     * * `information_schema_stats_expiry` - The time, in seconds, before cached statistics expire.
     * 
     * * `innodb_change_buffer_max_size` - Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
     * 
     * * `innodb_flush_neighbors` - Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
     * 
     * * `innodb_ft_min_token_size` - Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_ft_server_stopword_table` - This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
     * 
     * * `innodb_lock_wait_timeout` - The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
     * 
     * * `innodb_log_buffer_size` - The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
     * 
     * * `innodb_online_alter_log_max_size` - The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
     * 
     * * `innodb_read_io_threads` - The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_rollback_on_timeout` - When enabled, a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_thread_concurrency` - Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
     * 
     * * `innodb_write_io_threads` - The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `interactive_timeout` - The number of seconds the server waits for activity on an interactive connection before closing it.
     * 
     * * `internal_tmp_mem_storage_engine` - The storage engine for in-memory internal temporary tables.
     * 
     * * `max_allowed_packet` - Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
     * 
     * * `max_heap_table_size` - Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
     * 
     * * `net_buffer_length` - Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `net_read_timeout` - The number of seconds to wait for more data from a connection before aborting the read.
     * 
     * * `net_write_timeout` - The number of seconds to wait for a block to be written to a connection before aborting the write.
     * 
     * * `sort_buffer_size` - Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
     * 
     * * `sql_mode` - Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
     * 
     * * `sql_require_primary_key` - Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
     * 
     * * `tmp_table_size` - Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
     * 
     * * `wait_timeout` - The number of seconds the server waits for activity on a noninteractive connection before closing it.
     * 
     * ## connect_timeout
     * 
     * The following arguments are supported in the `connect_timeout` specification block:
     * 
     * * `description` - The description of `connect_timeout`.
     * 
     * * `example` - An example of a valid value for `connect_timeout`.
     * 
     * * `maximum` - The maximum valid value of  `connect_timeout`.
     * 
     * * `minimum` - The minimum valid value of  `connect_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `connect_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `connect_timeout`.
     * 
     * ## default_time_zone
     * 
     * The following arguments are supported in the `default_time_zone` specification block:
     * 
     * * `description` - The description of `default_time_zone`.
     * 
     * * `example` - An example of a valid value for `default_time_zone`.
     * 
     * * `maxLength` - The maximum length of the `default_time_zone` value.
     * 
     * * `minLength` - The minimum length of the `default_time_zone` value.
     * 
     * * `pattern` - A regular expression that the `default_time_zone` value must match.
     * 
     * * `requires_restart` - Whether changing the value `default_time_zone` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_time_zone`.
     * 
     * ## group_concat_max_len
     * 
     * The following arguments are supported in the `group_concat_max_len` specification block:
     * 
     * * `description` - The description of `group_concat_max_len`.
     * 
     * * `example` - An example of a valid value for `group_concat_max_len`.
     * 
     * * `maximum` - The maximum valid value of `group_concat_max_len`.
     * 
     * * `minimum` - The minimum valid value of `group_concat_max_len`.
     * 
     * * `requires_restart` - Whether changing the value `group_concat_max_len` requires the DB to restart.
     * 
     * * `type` - The type of the value of `group_concat_max_len`.
     * 
     * ## information_schema_stats_expiry
     * 
     * The following arguments are supported in the `information_schema_stats_expiry` specification block:
     * 
     * * `description` - The description of `information_schema_stats_expiry`.
     * 
     * * `example` - An example of a valid value for `information_schema_stats_expiry`.
     * 
     * * `maximum` - The maximum valid value of `information_schema_stats_expiry`.
     * 
     * * `minimum` - The minimum valid value of `information_schema_stats_expiry`.
     * 
     * * `requires_restart` - Whether changing the value `information_schema_stats_expiry` requires the DB to restart.
     * 
     * * `type` - The type of the value of `information_schema_stats_expiry`.
     * 
     * ## innodb_change_buffer_max_size
     * 
     * The following arguments are supported in the `innodb_change_buffer_max_size` specification block:
     * 
     * * `description` - The description of `innodb_change_buffer_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_change_buffer_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_change_buffer_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_change_buffer_max_size`.
     * 
     * ## innodb_flush_neighbors
     * 
     * The following arguments are supported in the `innodb_flush_neighbors` specification block:
     * 
     * * `description` - The description of `innodb_flush_neighbors`.
     * 
     * * `example` - An example of a valid value for `innodb_flush_neighbors`.
     * 
     * * `maximum` - The maximum valid value of `innodb_flush_neighbors`.
     * 
     * * `minimum` - The minimum valid value of `innodb_flush_neighbors`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_flush_neighbors` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_flush_neighbors`.
     * 
     * ## innodb_ft_min_token_size
     * 
     * The following arguments are supported in the `innodb_ft_min_token_size` specification block:
     * 
     * * `description` - The description of `innodb_ft_min_token_size`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_min_token_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_ft_min_token_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_ft_min_token_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_min_token_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_min_token_size`.
     * 
     * ## innodb_ft_server_stopword_table
     * 
     * The following arguments are supported in the `innodb_ft_server_stopword_table` specification block:
     * 
     * * `description` - The description of `innodb_ft_server_stopword_table`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_server_stopword_table`.
     * 
     * * `maxLength` - The maximum length of the value for `innodb_ft_server_stopword_table`.
     * 
     * * `pattern` - A regex pattern that a value of `innodb_ft_server_stopword_table` must match.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_server_stopword_table` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_server_stopword_table`.
     * 
     * ## innodb_lock_wait_timeout
     * 
     * The following arguments are supported in the `innodb_lock_wait_timeout` specification block:
     * 
     * * `description` - The description of `innodb_lock_wait_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_lock_wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_lock_wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_lock_wait_timeout`.
     * 
     * ## innodb_log_buffer_size
     * 
     * The following arguments are supported in the `innodb_log_buffer_size` specification block:
     * 
     * * `description` - The description of `innodb_log_buffer_size`.
     * 
     * * `example` - An example of a valid value for `innodb_log_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_log_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_log_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_log_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_log_buffer_size`.
     * 
     * ## innodb_online_alter_log_max_size
     * 
     * The following arguments are supported in the `innodb_online_alter_log_max_size` specification block:
     * 
     * * `description` - The description of `innodb_online_alter_log_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_online_alter_log_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_online_alter_log_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_online_alter_log_max_size`.
     * 
     * ## innodb_read_io_threads
     * 
     * The following arguments are supported in the `innodb_read_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_read_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_read_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_read_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_read_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_read_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_read_io_threads`.
     * 
     * ## innodb_rollback_on_timeout
     * 
     * The following arguments are supported in the `innodb_rollback_on_timeout` specification block:
     * 
     * * `description` - The description of `innodb_rollback_on_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_rollback_on_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_rollback_on_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_rollback_on_timeout`.
     * 
     * ## innodb_thread_concurrency
     * 
     * The following arguments are supported in the `innodb_thread_concurrency` specification block:
     * 
     * * `description` - The description of `innodb_thread_concurrency`.
     * 
     * * `example` - An example of a valid value for `innodb_thread_concurrency`.
     * 
     * * `maximum` - The maximum valid value of `innodb_thread_concurrency`.
     * 
     * * `minimum` - The minimum valid value of `innodb_thread_concurrency`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_thread_concurrency` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_thread_concurrency`.
     * 
     * ## innodb_write_io_threads
     * 
     * The following arguments are supported in the `innodb_write_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_write_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_write_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_write_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_write_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_write_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_write_io_threads`.
     * 
     * ## interactive_timeout
     * 
     * The following arguments are supported in the `interactive_timeout` specification block:
     * 
     * * `description` - The description of `interactive_timeout`.
     * 
     * * `example` - An example of a valid value for `interactive_timeout`.
     * 
     * * `maximum` - The maximum valid value of `interactive_timeout`.
     * 
     * * `minimum` - The minimum valid value of `interactive_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `interactive_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `interactive_timeout`.
     * 
     * ## internal_tmp_mem_storage_engine
     * 
     * The following arguments are supported in the `internal_tmp_mem_storage_engine` specification block:
     * 
     * * `description` - The description of `internal_tmp_mem_storage_engine`.
     * 
     * * `enum` - A list of valid enum values for `internal_tmp_mem_storage_engine`.
     * 
     * * `example` - An example of a valid value for `internal_tmp_mem_storage_engine`.
     * 
     * * `requires_restart` - Whether changing the value `internal_tmp_mem_storage_engine` requires the DB to restart.
     * 
     * * `type` - The type of the value of `internal_tmp_mem_storage_engine`.
     * 
     * ## max_allowed_packet
     * 
     * The following arguments are supported in the `max_allowed_packet` specification block:
     * 
     * * `description` - The description of `max_allowed_packet`.
     * 
     * * `example` - An example of a valid value for `max_allowed_packet`.
     * 
     * * `maximum` - The maximum valid value of `max_allowed_packet`.
     * 
     * * `minimum` - The minimum valid value of `max_allowed_packet`.
     * 
     * * `requires_restart` - Whether changing the value `max_allowed_packet` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_allowed_packet`.
     * 
     * ## max_heap_table_size
     * 
     * The following arguments are supported in the `max_heap_table_size` specification block:
     * 
     * * `description` - The description of `max_heap_table_size`.
     * 
     * * `example` - An example of a valid value for `max_heap_table_size`.
     * 
     * * `maximum` - The maximum valid value of `max_heap_table_size`.
     * 
     * * `minimum` - The minimum valid value of `max_heap_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `max_heap_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_heap_table_size`.
     * 
     * ## net_buffer_length
     * 
     * The following arguments are supported in the `net_buffer_length` specification block:
     * 
     * * `description` - The description of `net_buffer_length`.
     * 
     * * `example` - An example of a valid value for `net_buffer_length`.
     * 
     * * `maximum` - The maximum valid value of `net_buffer_length`.
     * 
     * * `minimum` - The minimum valid value of `net_buffer_length`.
     * 
     * * `requires_restart` - Whether changing the value `net_buffer_length` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_buffer_length`.
     * 
     * ## net_read_timeout
     * 
     * The following arguments are supported in the `net_read_timeout` specification block:
     * 
     * * `description` - The description of `net_read_timeout`.
     * 
     * * `example` - An example of a valid value for `net_read_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_read_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_read_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_read_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_read_timeout`.
     * 
     * ## net_write_timeout
     * 
     * The following arguments are supported in the `net_write_timeout` specification block:
     * 
     * * `description` - The description of `net_write_timeout`.
     * 
     * * `example` - An example of a valid value for `net_write_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_write_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_write_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_write_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_write_timeout`.
     * 
     * ## sort_buffer_size
     * 
     * The following arguments are supported in the `sort_buffer_size` specification block:
     * 
     * * `description` - The description of `sort_buffer_size`.
     * 
     * * `example` - An example of a valid value for `sort_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `sort_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `sort_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `sort_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sort_buffer_size`.
     * 
     * ## sql_mode
     * 
     * The following arguments are supported in the `sql_mode` specification block:
     * 
     * * `description` - The description of `sql_mode`.
     * 
     * * `example` - An example of a valid value for `sql_mode`.
     * 
     * * `maxLength` - The maximum valid length of `sql_mode`.
     * 
     * * `pattern` - The pattern to match for `sql_mode`.
     * 
     * * `requires_restart` - Whether changing the value `sql_mode` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_mode`.
     * 
     * ## sql_require_primary_key
     * 
     * The following arguments are supported in the `sql_require_primary_key` specification block:
     * 
     * * `description` - The description of `sql_require_primary_key`.
     * 
     * * `example` - An example of a valid value for `sql_require_primary_key`.
     * 
     * * `requires_restart` - Whether changing the value `sql_require_primary_key` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_require_primary_key`.
     * 
     * ## tmp_table_size
     * 
     * The following arguments are supported in the `tmp_table_size` specification block:
     * 
     * * `description` - The description of `tmp_table_size`.
     * 
     * * `example` - An example of a valid value for `tmp_table_size`.
     * 
     * * `maximum` - The maximum valid value of `tmp_table_size`.
     * 
     * * `minimum` - The minimum valid value of `tmp_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `tmp_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `tmp_table_size`.
     * 
     * ## wait_timeout
     * 
     * The following arguments are supported in the `wait_timeout` specification block:
     * 
     * * `description` - The description of `wait_timeout`.
     * 
     * * `example` - An example of a valid value for `wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `wait_timeout`.
     * 
     */
    public static Output<GetDatabaseMysqlConfigResult> getDatabaseMysqlConfig() {
        return getDatabaseMysqlConfig(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode MySQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabaseMysqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## binlog_retention_period
     * 
     * The following arguments are supported in the `binlog_retention_period` specification block:
     * 
     * * `description` - The description of `binlog_retention_period`.
     * 
     * * `example` - An example of a valid value for `binlog_retention_period`.
     * 
     * * `maximum` - The maximum valid value of `binlog_retention_period`.
     * 
     * * `minimum` - The minimum valid value of `binlog_retention_period`.
     * 
     * * `requires_restart` - Whether changing the value `binlog_retention_period` requires the DB to restart.
     * 
     * * `type` - The type of the value of `binlog_retention_period`.
     * 
     * ## mysql
     * 
     * The following arguments are supported in the `mysql` specification block:
     * 
     * * `connect_timeout` - The number of seconds that the mysqld server waits for a connect packet before responding with &#34;Bad handshake&#34;.
     * 
     * * `default_time_zone` - Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or `SYSTEM` to use the MySQL server default.
     * 
     * * `group_concat_max_len` - The maximum permitted result length in bytes for the `GROUP_CONCAT()` function.
     * 
     * * `information_schema_stats_expiry` - The time, in seconds, before cached statistics expire.
     * 
     * * `innodb_change_buffer_max_size` - Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
     * 
     * * `innodb_flush_neighbors` - Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
     * 
     * * `innodb_ft_min_token_size` - Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_ft_server_stopword_table` - This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
     * 
     * * `innodb_lock_wait_timeout` - The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
     * 
     * * `innodb_log_buffer_size` - The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
     * 
     * * `innodb_online_alter_log_max_size` - The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
     * 
     * * `innodb_read_io_threads` - The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_rollback_on_timeout` - When enabled, a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_thread_concurrency` - Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
     * 
     * * `innodb_write_io_threads` - The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `interactive_timeout` - The number of seconds the server waits for activity on an interactive connection before closing it.
     * 
     * * `internal_tmp_mem_storage_engine` - The storage engine for in-memory internal temporary tables.
     * 
     * * `max_allowed_packet` - Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
     * 
     * * `max_heap_table_size` - Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
     * 
     * * `net_buffer_length` - Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `net_read_timeout` - The number of seconds to wait for more data from a connection before aborting the read.
     * 
     * * `net_write_timeout` - The number of seconds to wait for a block to be written to a connection before aborting the write.
     * 
     * * `sort_buffer_size` - Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
     * 
     * * `sql_mode` - Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
     * 
     * * `sql_require_primary_key` - Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
     * 
     * * `tmp_table_size` - Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
     * 
     * * `wait_timeout` - The number of seconds the server waits for activity on a noninteractive connection before closing it.
     * 
     * ## connect_timeout
     * 
     * The following arguments are supported in the `connect_timeout` specification block:
     * 
     * * `description` - The description of `connect_timeout`.
     * 
     * * `example` - An example of a valid value for `connect_timeout`.
     * 
     * * `maximum` - The maximum valid value of  `connect_timeout`.
     * 
     * * `minimum` - The minimum valid value of  `connect_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `connect_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `connect_timeout`.
     * 
     * ## default_time_zone
     * 
     * The following arguments are supported in the `default_time_zone` specification block:
     * 
     * * `description` - The description of `default_time_zone`.
     * 
     * * `example` - An example of a valid value for `default_time_zone`.
     * 
     * * `maxLength` - The maximum length of the `default_time_zone` value.
     * 
     * * `minLength` - The minimum length of the `default_time_zone` value.
     * 
     * * `pattern` - A regular expression that the `default_time_zone` value must match.
     * 
     * * `requires_restart` - Whether changing the value `default_time_zone` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_time_zone`.
     * 
     * ## group_concat_max_len
     * 
     * The following arguments are supported in the `group_concat_max_len` specification block:
     * 
     * * `description` - The description of `group_concat_max_len`.
     * 
     * * `example` - An example of a valid value for `group_concat_max_len`.
     * 
     * * `maximum` - The maximum valid value of `group_concat_max_len`.
     * 
     * * `minimum` - The minimum valid value of `group_concat_max_len`.
     * 
     * * `requires_restart` - Whether changing the value `group_concat_max_len` requires the DB to restart.
     * 
     * * `type` - The type of the value of `group_concat_max_len`.
     * 
     * ## information_schema_stats_expiry
     * 
     * The following arguments are supported in the `information_schema_stats_expiry` specification block:
     * 
     * * `description` - The description of `information_schema_stats_expiry`.
     * 
     * * `example` - An example of a valid value for `information_schema_stats_expiry`.
     * 
     * * `maximum` - The maximum valid value of `information_schema_stats_expiry`.
     * 
     * * `minimum` - The minimum valid value of `information_schema_stats_expiry`.
     * 
     * * `requires_restart` - Whether changing the value `information_schema_stats_expiry` requires the DB to restart.
     * 
     * * `type` - The type of the value of `information_schema_stats_expiry`.
     * 
     * ## innodb_change_buffer_max_size
     * 
     * The following arguments are supported in the `innodb_change_buffer_max_size` specification block:
     * 
     * * `description` - The description of `innodb_change_buffer_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_change_buffer_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_change_buffer_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_change_buffer_max_size`.
     * 
     * ## innodb_flush_neighbors
     * 
     * The following arguments are supported in the `innodb_flush_neighbors` specification block:
     * 
     * * `description` - The description of `innodb_flush_neighbors`.
     * 
     * * `example` - An example of a valid value for `innodb_flush_neighbors`.
     * 
     * * `maximum` - The maximum valid value of `innodb_flush_neighbors`.
     * 
     * * `minimum` - The minimum valid value of `innodb_flush_neighbors`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_flush_neighbors` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_flush_neighbors`.
     * 
     * ## innodb_ft_min_token_size
     * 
     * The following arguments are supported in the `innodb_ft_min_token_size` specification block:
     * 
     * * `description` - The description of `innodb_ft_min_token_size`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_min_token_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_ft_min_token_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_ft_min_token_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_min_token_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_min_token_size`.
     * 
     * ## innodb_ft_server_stopword_table
     * 
     * The following arguments are supported in the `innodb_ft_server_stopword_table` specification block:
     * 
     * * `description` - The description of `innodb_ft_server_stopword_table`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_server_stopword_table`.
     * 
     * * `maxLength` - The maximum length of the value for `innodb_ft_server_stopword_table`.
     * 
     * * `pattern` - A regex pattern that a value of `innodb_ft_server_stopword_table` must match.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_server_stopword_table` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_server_stopword_table`.
     * 
     * ## innodb_lock_wait_timeout
     * 
     * The following arguments are supported in the `innodb_lock_wait_timeout` specification block:
     * 
     * * `description` - The description of `innodb_lock_wait_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_lock_wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_lock_wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_lock_wait_timeout`.
     * 
     * ## innodb_log_buffer_size
     * 
     * The following arguments are supported in the `innodb_log_buffer_size` specification block:
     * 
     * * `description` - The description of `innodb_log_buffer_size`.
     * 
     * * `example` - An example of a valid value for `innodb_log_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_log_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_log_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_log_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_log_buffer_size`.
     * 
     * ## innodb_online_alter_log_max_size
     * 
     * The following arguments are supported in the `innodb_online_alter_log_max_size` specification block:
     * 
     * * `description` - The description of `innodb_online_alter_log_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_online_alter_log_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_online_alter_log_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_online_alter_log_max_size`.
     * 
     * ## innodb_read_io_threads
     * 
     * The following arguments are supported in the `innodb_read_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_read_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_read_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_read_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_read_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_read_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_read_io_threads`.
     * 
     * ## innodb_rollback_on_timeout
     * 
     * The following arguments are supported in the `innodb_rollback_on_timeout` specification block:
     * 
     * * `description` - The description of `innodb_rollback_on_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_rollback_on_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_rollback_on_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_rollback_on_timeout`.
     * 
     * ## innodb_thread_concurrency
     * 
     * The following arguments are supported in the `innodb_thread_concurrency` specification block:
     * 
     * * `description` - The description of `innodb_thread_concurrency`.
     * 
     * * `example` - An example of a valid value for `innodb_thread_concurrency`.
     * 
     * * `maximum` - The maximum valid value of `innodb_thread_concurrency`.
     * 
     * * `minimum` - The minimum valid value of `innodb_thread_concurrency`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_thread_concurrency` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_thread_concurrency`.
     * 
     * ## innodb_write_io_threads
     * 
     * The following arguments are supported in the `innodb_write_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_write_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_write_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_write_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_write_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_write_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_write_io_threads`.
     * 
     * ## interactive_timeout
     * 
     * The following arguments are supported in the `interactive_timeout` specification block:
     * 
     * * `description` - The description of `interactive_timeout`.
     * 
     * * `example` - An example of a valid value for `interactive_timeout`.
     * 
     * * `maximum` - The maximum valid value of `interactive_timeout`.
     * 
     * * `minimum` - The minimum valid value of `interactive_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `interactive_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `interactive_timeout`.
     * 
     * ## internal_tmp_mem_storage_engine
     * 
     * The following arguments are supported in the `internal_tmp_mem_storage_engine` specification block:
     * 
     * * `description` - The description of `internal_tmp_mem_storage_engine`.
     * 
     * * `enum` - A list of valid enum values for `internal_tmp_mem_storage_engine`.
     * 
     * * `example` - An example of a valid value for `internal_tmp_mem_storage_engine`.
     * 
     * * `requires_restart` - Whether changing the value `internal_tmp_mem_storage_engine` requires the DB to restart.
     * 
     * * `type` - The type of the value of `internal_tmp_mem_storage_engine`.
     * 
     * ## max_allowed_packet
     * 
     * The following arguments are supported in the `max_allowed_packet` specification block:
     * 
     * * `description` - The description of `max_allowed_packet`.
     * 
     * * `example` - An example of a valid value for `max_allowed_packet`.
     * 
     * * `maximum` - The maximum valid value of `max_allowed_packet`.
     * 
     * * `minimum` - The minimum valid value of `max_allowed_packet`.
     * 
     * * `requires_restart` - Whether changing the value `max_allowed_packet` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_allowed_packet`.
     * 
     * ## max_heap_table_size
     * 
     * The following arguments are supported in the `max_heap_table_size` specification block:
     * 
     * * `description` - The description of `max_heap_table_size`.
     * 
     * * `example` - An example of a valid value for `max_heap_table_size`.
     * 
     * * `maximum` - The maximum valid value of `max_heap_table_size`.
     * 
     * * `minimum` - The minimum valid value of `max_heap_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `max_heap_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_heap_table_size`.
     * 
     * ## net_buffer_length
     * 
     * The following arguments are supported in the `net_buffer_length` specification block:
     * 
     * * `description` - The description of `net_buffer_length`.
     * 
     * * `example` - An example of a valid value for `net_buffer_length`.
     * 
     * * `maximum` - The maximum valid value of `net_buffer_length`.
     * 
     * * `minimum` - The minimum valid value of `net_buffer_length`.
     * 
     * * `requires_restart` - Whether changing the value `net_buffer_length` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_buffer_length`.
     * 
     * ## net_read_timeout
     * 
     * The following arguments are supported in the `net_read_timeout` specification block:
     * 
     * * `description` - The description of `net_read_timeout`.
     * 
     * * `example` - An example of a valid value for `net_read_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_read_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_read_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_read_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_read_timeout`.
     * 
     * ## net_write_timeout
     * 
     * The following arguments are supported in the `net_write_timeout` specification block:
     * 
     * * `description` - The description of `net_write_timeout`.
     * 
     * * `example` - An example of a valid value for `net_write_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_write_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_write_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_write_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_write_timeout`.
     * 
     * ## sort_buffer_size
     * 
     * The following arguments are supported in the `sort_buffer_size` specification block:
     * 
     * * `description` - The description of `sort_buffer_size`.
     * 
     * * `example` - An example of a valid value for `sort_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `sort_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `sort_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `sort_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sort_buffer_size`.
     * 
     * ## sql_mode
     * 
     * The following arguments are supported in the `sql_mode` specification block:
     * 
     * * `description` - The description of `sql_mode`.
     * 
     * * `example` - An example of a valid value for `sql_mode`.
     * 
     * * `maxLength` - The maximum valid length of `sql_mode`.
     * 
     * * `pattern` - The pattern to match for `sql_mode`.
     * 
     * * `requires_restart` - Whether changing the value `sql_mode` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_mode`.
     * 
     * ## sql_require_primary_key
     * 
     * The following arguments are supported in the `sql_require_primary_key` specification block:
     * 
     * * `description` - The description of `sql_require_primary_key`.
     * 
     * * `example` - An example of a valid value for `sql_require_primary_key`.
     * 
     * * `requires_restart` - Whether changing the value `sql_require_primary_key` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_require_primary_key`.
     * 
     * ## tmp_table_size
     * 
     * The following arguments are supported in the `tmp_table_size` specification block:
     * 
     * * `description` - The description of `tmp_table_size`.
     * 
     * * `example` - An example of a valid value for `tmp_table_size`.
     * 
     * * `maximum` - The maximum valid value of `tmp_table_size`.
     * 
     * * `minimum` - The minimum valid value of `tmp_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `tmp_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `tmp_table_size`.
     * 
     * ## wait_timeout
     * 
     * The following arguments are supported in the `wait_timeout` specification block:
     * 
     * * `description` - The description of `wait_timeout`.
     * 
     * * `example` - An example of a valid value for `wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `wait_timeout`.
     * 
     */
    public static CompletableFuture<GetDatabaseMysqlConfigResult> getDatabaseMysqlConfigPlain() {
        return getDatabaseMysqlConfigPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode MySQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabaseMysqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## binlog_retention_period
     * 
     * The following arguments are supported in the `binlog_retention_period` specification block:
     * 
     * * `description` - The description of `binlog_retention_period`.
     * 
     * * `example` - An example of a valid value for `binlog_retention_period`.
     * 
     * * `maximum` - The maximum valid value of `binlog_retention_period`.
     * 
     * * `minimum` - The minimum valid value of `binlog_retention_period`.
     * 
     * * `requires_restart` - Whether changing the value `binlog_retention_period` requires the DB to restart.
     * 
     * * `type` - The type of the value of `binlog_retention_period`.
     * 
     * ## mysql
     * 
     * The following arguments are supported in the `mysql` specification block:
     * 
     * * `connect_timeout` - The number of seconds that the mysqld server waits for a connect packet before responding with &#34;Bad handshake&#34;.
     * 
     * * `default_time_zone` - Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or `SYSTEM` to use the MySQL server default.
     * 
     * * `group_concat_max_len` - The maximum permitted result length in bytes for the `GROUP_CONCAT()` function.
     * 
     * * `information_schema_stats_expiry` - The time, in seconds, before cached statistics expire.
     * 
     * * `innodb_change_buffer_max_size` - Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
     * 
     * * `innodb_flush_neighbors` - Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
     * 
     * * `innodb_ft_min_token_size` - Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_ft_server_stopword_table` - This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
     * 
     * * `innodb_lock_wait_timeout` - The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
     * 
     * * `innodb_log_buffer_size` - The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
     * 
     * * `innodb_online_alter_log_max_size` - The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
     * 
     * * `innodb_read_io_threads` - The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_rollback_on_timeout` - When enabled, a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_thread_concurrency` - Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
     * 
     * * `innodb_write_io_threads` - The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `interactive_timeout` - The number of seconds the server waits for activity on an interactive connection before closing it.
     * 
     * * `internal_tmp_mem_storage_engine` - The storage engine for in-memory internal temporary tables.
     * 
     * * `max_allowed_packet` - Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
     * 
     * * `max_heap_table_size` - Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
     * 
     * * `net_buffer_length` - Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `net_read_timeout` - The number of seconds to wait for more data from a connection before aborting the read.
     * 
     * * `net_write_timeout` - The number of seconds to wait for a block to be written to a connection before aborting the write.
     * 
     * * `sort_buffer_size` - Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
     * 
     * * `sql_mode` - Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
     * 
     * * `sql_require_primary_key` - Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
     * 
     * * `tmp_table_size` - Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
     * 
     * * `wait_timeout` - The number of seconds the server waits for activity on a noninteractive connection before closing it.
     * 
     * ## connect_timeout
     * 
     * The following arguments are supported in the `connect_timeout` specification block:
     * 
     * * `description` - The description of `connect_timeout`.
     * 
     * * `example` - An example of a valid value for `connect_timeout`.
     * 
     * * `maximum` - The maximum valid value of  `connect_timeout`.
     * 
     * * `minimum` - The minimum valid value of  `connect_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `connect_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `connect_timeout`.
     * 
     * ## default_time_zone
     * 
     * The following arguments are supported in the `default_time_zone` specification block:
     * 
     * * `description` - The description of `default_time_zone`.
     * 
     * * `example` - An example of a valid value for `default_time_zone`.
     * 
     * * `maxLength` - The maximum length of the `default_time_zone` value.
     * 
     * * `minLength` - The minimum length of the `default_time_zone` value.
     * 
     * * `pattern` - A regular expression that the `default_time_zone` value must match.
     * 
     * * `requires_restart` - Whether changing the value `default_time_zone` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_time_zone`.
     * 
     * ## group_concat_max_len
     * 
     * The following arguments are supported in the `group_concat_max_len` specification block:
     * 
     * * `description` - The description of `group_concat_max_len`.
     * 
     * * `example` - An example of a valid value for `group_concat_max_len`.
     * 
     * * `maximum` - The maximum valid value of `group_concat_max_len`.
     * 
     * * `minimum` - The minimum valid value of `group_concat_max_len`.
     * 
     * * `requires_restart` - Whether changing the value `group_concat_max_len` requires the DB to restart.
     * 
     * * `type` - The type of the value of `group_concat_max_len`.
     * 
     * ## information_schema_stats_expiry
     * 
     * The following arguments are supported in the `information_schema_stats_expiry` specification block:
     * 
     * * `description` - The description of `information_schema_stats_expiry`.
     * 
     * * `example` - An example of a valid value for `information_schema_stats_expiry`.
     * 
     * * `maximum` - The maximum valid value of `information_schema_stats_expiry`.
     * 
     * * `minimum` - The minimum valid value of `information_schema_stats_expiry`.
     * 
     * * `requires_restart` - Whether changing the value `information_schema_stats_expiry` requires the DB to restart.
     * 
     * * `type` - The type of the value of `information_schema_stats_expiry`.
     * 
     * ## innodb_change_buffer_max_size
     * 
     * The following arguments are supported in the `innodb_change_buffer_max_size` specification block:
     * 
     * * `description` - The description of `innodb_change_buffer_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_change_buffer_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_change_buffer_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_change_buffer_max_size`.
     * 
     * ## innodb_flush_neighbors
     * 
     * The following arguments are supported in the `innodb_flush_neighbors` specification block:
     * 
     * * `description` - The description of `innodb_flush_neighbors`.
     * 
     * * `example` - An example of a valid value for `innodb_flush_neighbors`.
     * 
     * * `maximum` - The maximum valid value of `innodb_flush_neighbors`.
     * 
     * * `minimum` - The minimum valid value of `innodb_flush_neighbors`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_flush_neighbors` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_flush_neighbors`.
     * 
     * ## innodb_ft_min_token_size
     * 
     * The following arguments are supported in the `innodb_ft_min_token_size` specification block:
     * 
     * * `description` - The description of `innodb_ft_min_token_size`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_min_token_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_ft_min_token_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_ft_min_token_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_min_token_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_min_token_size`.
     * 
     * ## innodb_ft_server_stopword_table
     * 
     * The following arguments are supported in the `innodb_ft_server_stopword_table` specification block:
     * 
     * * `description` - The description of `innodb_ft_server_stopword_table`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_server_stopword_table`.
     * 
     * * `maxLength` - The maximum length of the value for `innodb_ft_server_stopword_table`.
     * 
     * * `pattern` - A regex pattern that a value of `innodb_ft_server_stopword_table` must match.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_server_stopword_table` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_server_stopword_table`.
     * 
     * ## innodb_lock_wait_timeout
     * 
     * The following arguments are supported in the `innodb_lock_wait_timeout` specification block:
     * 
     * * `description` - The description of `innodb_lock_wait_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_lock_wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_lock_wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_lock_wait_timeout`.
     * 
     * ## innodb_log_buffer_size
     * 
     * The following arguments are supported in the `innodb_log_buffer_size` specification block:
     * 
     * * `description` - The description of `innodb_log_buffer_size`.
     * 
     * * `example` - An example of a valid value for `innodb_log_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_log_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_log_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_log_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_log_buffer_size`.
     * 
     * ## innodb_online_alter_log_max_size
     * 
     * The following arguments are supported in the `innodb_online_alter_log_max_size` specification block:
     * 
     * * `description` - The description of `innodb_online_alter_log_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_online_alter_log_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_online_alter_log_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_online_alter_log_max_size`.
     * 
     * ## innodb_read_io_threads
     * 
     * The following arguments are supported in the `innodb_read_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_read_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_read_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_read_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_read_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_read_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_read_io_threads`.
     * 
     * ## innodb_rollback_on_timeout
     * 
     * The following arguments are supported in the `innodb_rollback_on_timeout` specification block:
     * 
     * * `description` - The description of `innodb_rollback_on_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_rollback_on_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_rollback_on_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_rollback_on_timeout`.
     * 
     * ## innodb_thread_concurrency
     * 
     * The following arguments are supported in the `innodb_thread_concurrency` specification block:
     * 
     * * `description` - The description of `innodb_thread_concurrency`.
     * 
     * * `example` - An example of a valid value for `innodb_thread_concurrency`.
     * 
     * * `maximum` - The maximum valid value of `innodb_thread_concurrency`.
     * 
     * * `minimum` - The minimum valid value of `innodb_thread_concurrency`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_thread_concurrency` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_thread_concurrency`.
     * 
     * ## innodb_write_io_threads
     * 
     * The following arguments are supported in the `innodb_write_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_write_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_write_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_write_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_write_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_write_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_write_io_threads`.
     * 
     * ## interactive_timeout
     * 
     * The following arguments are supported in the `interactive_timeout` specification block:
     * 
     * * `description` - The description of `interactive_timeout`.
     * 
     * * `example` - An example of a valid value for `interactive_timeout`.
     * 
     * * `maximum` - The maximum valid value of `interactive_timeout`.
     * 
     * * `minimum` - The minimum valid value of `interactive_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `interactive_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `interactive_timeout`.
     * 
     * ## internal_tmp_mem_storage_engine
     * 
     * The following arguments are supported in the `internal_tmp_mem_storage_engine` specification block:
     * 
     * * `description` - The description of `internal_tmp_mem_storage_engine`.
     * 
     * * `enum` - A list of valid enum values for `internal_tmp_mem_storage_engine`.
     * 
     * * `example` - An example of a valid value for `internal_tmp_mem_storage_engine`.
     * 
     * * `requires_restart` - Whether changing the value `internal_tmp_mem_storage_engine` requires the DB to restart.
     * 
     * * `type` - The type of the value of `internal_tmp_mem_storage_engine`.
     * 
     * ## max_allowed_packet
     * 
     * The following arguments are supported in the `max_allowed_packet` specification block:
     * 
     * * `description` - The description of `max_allowed_packet`.
     * 
     * * `example` - An example of a valid value for `max_allowed_packet`.
     * 
     * * `maximum` - The maximum valid value of `max_allowed_packet`.
     * 
     * * `minimum` - The minimum valid value of `max_allowed_packet`.
     * 
     * * `requires_restart` - Whether changing the value `max_allowed_packet` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_allowed_packet`.
     * 
     * ## max_heap_table_size
     * 
     * The following arguments are supported in the `max_heap_table_size` specification block:
     * 
     * * `description` - The description of `max_heap_table_size`.
     * 
     * * `example` - An example of a valid value for `max_heap_table_size`.
     * 
     * * `maximum` - The maximum valid value of `max_heap_table_size`.
     * 
     * * `minimum` - The minimum valid value of `max_heap_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `max_heap_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_heap_table_size`.
     * 
     * ## net_buffer_length
     * 
     * The following arguments are supported in the `net_buffer_length` specification block:
     * 
     * * `description` - The description of `net_buffer_length`.
     * 
     * * `example` - An example of a valid value for `net_buffer_length`.
     * 
     * * `maximum` - The maximum valid value of `net_buffer_length`.
     * 
     * * `minimum` - The minimum valid value of `net_buffer_length`.
     * 
     * * `requires_restart` - Whether changing the value `net_buffer_length` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_buffer_length`.
     * 
     * ## net_read_timeout
     * 
     * The following arguments are supported in the `net_read_timeout` specification block:
     * 
     * * `description` - The description of `net_read_timeout`.
     * 
     * * `example` - An example of a valid value for `net_read_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_read_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_read_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_read_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_read_timeout`.
     * 
     * ## net_write_timeout
     * 
     * The following arguments are supported in the `net_write_timeout` specification block:
     * 
     * * `description` - The description of `net_write_timeout`.
     * 
     * * `example` - An example of a valid value for `net_write_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_write_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_write_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_write_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_write_timeout`.
     * 
     * ## sort_buffer_size
     * 
     * The following arguments are supported in the `sort_buffer_size` specification block:
     * 
     * * `description` - The description of `sort_buffer_size`.
     * 
     * * `example` - An example of a valid value for `sort_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `sort_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `sort_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `sort_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sort_buffer_size`.
     * 
     * ## sql_mode
     * 
     * The following arguments are supported in the `sql_mode` specification block:
     * 
     * * `description` - The description of `sql_mode`.
     * 
     * * `example` - An example of a valid value for `sql_mode`.
     * 
     * * `maxLength` - The maximum valid length of `sql_mode`.
     * 
     * * `pattern` - The pattern to match for `sql_mode`.
     * 
     * * `requires_restart` - Whether changing the value `sql_mode` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_mode`.
     * 
     * ## sql_require_primary_key
     * 
     * The following arguments are supported in the `sql_require_primary_key` specification block:
     * 
     * * `description` - The description of `sql_require_primary_key`.
     * 
     * * `example` - An example of a valid value for `sql_require_primary_key`.
     * 
     * * `requires_restart` - Whether changing the value `sql_require_primary_key` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_require_primary_key`.
     * 
     * ## tmp_table_size
     * 
     * The following arguments are supported in the `tmp_table_size` specification block:
     * 
     * * `description` - The description of `tmp_table_size`.
     * 
     * * `example` - An example of a valid value for `tmp_table_size`.
     * 
     * * `maximum` - The maximum valid value of `tmp_table_size`.
     * 
     * * `minimum` - The minimum valid value of `tmp_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `tmp_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `tmp_table_size`.
     * 
     * ## wait_timeout
     * 
     * The following arguments are supported in the `wait_timeout` specification block:
     * 
     * * `description` - The description of `wait_timeout`.
     * 
     * * `example` - An example of a valid value for `wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `wait_timeout`.
     * 
     */
    public static Output<GetDatabaseMysqlConfigResult> getDatabaseMysqlConfig(InvokeArgs args) {
        return getDatabaseMysqlConfig(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode MySQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabaseMysqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## binlog_retention_period
     * 
     * The following arguments are supported in the `binlog_retention_period` specification block:
     * 
     * * `description` - The description of `binlog_retention_period`.
     * 
     * * `example` - An example of a valid value for `binlog_retention_period`.
     * 
     * * `maximum` - The maximum valid value of `binlog_retention_period`.
     * 
     * * `minimum` - The minimum valid value of `binlog_retention_period`.
     * 
     * * `requires_restart` - Whether changing the value `binlog_retention_period` requires the DB to restart.
     * 
     * * `type` - The type of the value of `binlog_retention_period`.
     * 
     * ## mysql
     * 
     * The following arguments are supported in the `mysql` specification block:
     * 
     * * `connect_timeout` - The number of seconds that the mysqld server waits for a connect packet before responding with &#34;Bad handshake&#34;.
     * 
     * * `default_time_zone` - Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or `SYSTEM` to use the MySQL server default.
     * 
     * * `group_concat_max_len` - The maximum permitted result length in bytes for the `GROUP_CONCAT()` function.
     * 
     * * `information_schema_stats_expiry` - The time, in seconds, before cached statistics expire.
     * 
     * * `innodb_change_buffer_max_size` - Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
     * 
     * * `innodb_flush_neighbors` - Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
     * 
     * * `innodb_ft_min_token_size` - Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_ft_server_stopword_table` - This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
     * 
     * * `innodb_lock_wait_timeout` - The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
     * 
     * * `innodb_log_buffer_size` - The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
     * 
     * * `innodb_online_alter_log_max_size` - The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
     * 
     * * `innodb_read_io_threads` - The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_rollback_on_timeout` - When enabled, a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_thread_concurrency` - Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
     * 
     * * `innodb_write_io_threads` - The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `interactive_timeout` - The number of seconds the server waits for activity on an interactive connection before closing it.
     * 
     * * `internal_tmp_mem_storage_engine` - The storage engine for in-memory internal temporary tables.
     * 
     * * `max_allowed_packet` - Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
     * 
     * * `max_heap_table_size` - Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
     * 
     * * `net_buffer_length` - Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `net_read_timeout` - The number of seconds to wait for more data from a connection before aborting the read.
     * 
     * * `net_write_timeout` - The number of seconds to wait for a block to be written to a connection before aborting the write.
     * 
     * * `sort_buffer_size` - Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
     * 
     * * `sql_mode` - Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
     * 
     * * `sql_require_primary_key` - Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
     * 
     * * `tmp_table_size` - Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
     * 
     * * `wait_timeout` - The number of seconds the server waits for activity on a noninteractive connection before closing it.
     * 
     * ## connect_timeout
     * 
     * The following arguments are supported in the `connect_timeout` specification block:
     * 
     * * `description` - The description of `connect_timeout`.
     * 
     * * `example` - An example of a valid value for `connect_timeout`.
     * 
     * * `maximum` - The maximum valid value of  `connect_timeout`.
     * 
     * * `minimum` - The minimum valid value of  `connect_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `connect_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `connect_timeout`.
     * 
     * ## default_time_zone
     * 
     * The following arguments are supported in the `default_time_zone` specification block:
     * 
     * * `description` - The description of `default_time_zone`.
     * 
     * * `example` - An example of a valid value for `default_time_zone`.
     * 
     * * `maxLength` - The maximum length of the `default_time_zone` value.
     * 
     * * `minLength` - The minimum length of the `default_time_zone` value.
     * 
     * * `pattern` - A regular expression that the `default_time_zone` value must match.
     * 
     * * `requires_restart` - Whether changing the value `default_time_zone` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_time_zone`.
     * 
     * ## group_concat_max_len
     * 
     * The following arguments are supported in the `group_concat_max_len` specification block:
     * 
     * * `description` - The description of `group_concat_max_len`.
     * 
     * * `example` - An example of a valid value for `group_concat_max_len`.
     * 
     * * `maximum` - The maximum valid value of `group_concat_max_len`.
     * 
     * * `minimum` - The minimum valid value of `group_concat_max_len`.
     * 
     * * `requires_restart` - Whether changing the value `group_concat_max_len` requires the DB to restart.
     * 
     * * `type` - The type of the value of `group_concat_max_len`.
     * 
     * ## information_schema_stats_expiry
     * 
     * The following arguments are supported in the `information_schema_stats_expiry` specification block:
     * 
     * * `description` - The description of `information_schema_stats_expiry`.
     * 
     * * `example` - An example of a valid value for `information_schema_stats_expiry`.
     * 
     * * `maximum` - The maximum valid value of `information_schema_stats_expiry`.
     * 
     * * `minimum` - The minimum valid value of `information_schema_stats_expiry`.
     * 
     * * `requires_restart` - Whether changing the value `information_schema_stats_expiry` requires the DB to restart.
     * 
     * * `type` - The type of the value of `information_schema_stats_expiry`.
     * 
     * ## innodb_change_buffer_max_size
     * 
     * The following arguments are supported in the `innodb_change_buffer_max_size` specification block:
     * 
     * * `description` - The description of `innodb_change_buffer_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_change_buffer_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_change_buffer_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_change_buffer_max_size`.
     * 
     * ## innodb_flush_neighbors
     * 
     * The following arguments are supported in the `innodb_flush_neighbors` specification block:
     * 
     * * `description` - The description of `innodb_flush_neighbors`.
     * 
     * * `example` - An example of a valid value for `innodb_flush_neighbors`.
     * 
     * * `maximum` - The maximum valid value of `innodb_flush_neighbors`.
     * 
     * * `minimum` - The minimum valid value of `innodb_flush_neighbors`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_flush_neighbors` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_flush_neighbors`.
     * 
     * ## innodb_ft_min_token_size
     * 
     * The following arguments are supported in the `innodb_ft_min_token_size` specification block:
     * 
     * * `description` - The description of `innodb_ft_min_token_size`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_min_token_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_ft_min_token_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_ft_min_token_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_min_token_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_min_token_size`.
     * 
     * ## innodb_ft_server_stopword_table
     * 
     * The following arguments are supported in the `innodb_ft_server_stopword_table` specification block:
     * 
     * * `description` - The description of `innodb_ft_server_stopword_table`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_server_stopword_table`.
     * 
     * * `maxLength` - The maximum length of the value for `innodb_ft_server_stopword_table`.
     * 
     * * `pattern` - A regex pattern that a value of `innodb_ft_server_stopword_table` must match.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_server_stopword_table` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_server_stopword_table`.
     * 
     * ## innodb_lock_wait_timeout
     * 
     * The following arguments are supported in the `innodb_lock_wait_timeout` specification block:
     * 
     * * `description` - The description of `innodb_lock_wait_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_lock_wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_lock_wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_lock_wait_timeout`.
     * 
     * ## innodb_log_buffer_size
     * 
     * The following arguments are supported in the `innodb_log_buffer_size` specification block:
     * 
     * * `description` - The description of `innodb_log_buffer_size`.
     * 
     * * `example` - An example of a valid value for `innodb_log_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_log_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_log_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_log_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_log_buffer_size`.
     * 
     * ## innodb_online_alter_log_max_size
     * 
     * The following arguments are supported in the `innodb_online_alter_log_max_size` specification block:
     * 
     * * `description` - The description of `innodb_online_alter_log_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_online_alter_log_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_online_alter_log_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_online_alter_log_max_size`.
     * 
     * ## innodb_read_io_threads
     * 
     * The following arguments are supported in the `innodb_read_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_read_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_read_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_read_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_read_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_read_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_read_io_threads`.
     * 
     * ## innodb_rollback_on_timeout
     * 
     * The following arguments are supported in the `innodb_rollback_on_timeout` specification block:
     * 
     * * `description` - The description of `innodb_rollback_on_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_rollback_on_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_rollback_on_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_rollback_on_timeout`.
     * 
     * ## innodb_thread_concurrency
     * 
     * The following arguments are supported in the `innodb_thread_concurrency` specification block:
     * 
     * * `description` - The description of `innodb_thread_concurrency`.
     * 
     * * `example` - An example of a valid value for `innodb_thread_concurrency`.
     * 
     * * `maximum` - The maximum valid value of `innodb_thread_concurrency`.
     * 
     * * `minimum` - The minimum valid value of `innodb_thread_concurrency`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_thread_concurrency` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_thread_concurrency`.
     * 
     * ## innodb_write_io_threads
     * 
     * The following arguments are supported in the `innodb_write_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_write_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_write_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_write_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_write_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_write_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_write_io_threads`.
     * 
     * ## interactive_timeout
     * 
     * The following arguments are supported in the `interactive_timeout` specification block:
     * 
     * * `description` - The description of `interactive_timeout`.
     * 
     * * `example` - An example of a valid value for `interactive_timeout`.
     * 
     * * `maximum` - The maximum valid value of `interactive_timeout`.
     * 
     * * `minimum` - The minimum valid value of `interactive_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `interactive_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `interactive_timeout`.
     * 
     * ## internal_tmp_mem_storage_engine
     * 
     * The following arguments are supported in the `internal_tmp_mem_storage_engine` specification block:
     * 
     * * `description` - The description of `internal_tmp_mem_storage_engine`.
     * 
     * * `enum` - A list of valid enum values for `internal_tmp_mem_storage_engine`.
     * 
     * * `example` - An example of a valid value for `internal_tmp_mem_storage_engine`.
     * 
     * * `requires_restart` - Whether changing the value `internal_tmp_mem_storage_engine` requires the DB to restart.
     * 
     * * `type` - The type of the value of `internal_tmp_mem_storage_engine`.
     * 
     * ## max_allowed_packet
     * 
     * The following arguments are supported in the `max_allowed_packet` specification block:
     * 
     * * `description` - The description of `max_allowed_packet`.
     * 
     * * `example` - An example of a valid value for `max_allowed_packet`.
     * 
     * * `maximum` - The maximum valid value of `max_allowed_packet`.
     * 
     * * `minimum` - The minimum valid value of `max_allowed_packet`.
     * 
     * * `requires_restart` - Whether changing the value `max_allowed_packet` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_allowed_packet`.
     * 
     * ## max_heap_table_size
     * 
     * The following arguments are supported in the `max_heap_table_size` specification block:
     * 
     * * `description` - The description of `max_heap_table_size`.
     * 
     * * `example` - An example of a valid value for `max_heap_table_size`.
     * 
     * * `maximum` - The maximum valid value of `max_heap_table_size`.
     * 
     * * `minimum` - The minimum valid value of `max_heap_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `max_heap_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_heap_table_size`.
     * 
     * ## net_buffer_length
     * 
     * The following arguments are supported in the `net_buffer_length` specification block:
     * 
     * * `description` - The description of `net_buffer_length`.
     * 
     * * `example` - An example of a valid value for `net_buffer_length`.
     * 
     * * `maximum` - The maximum valid value of `net_buffer_length`.
     * 
     * * `minimum` - The minimum valid value of `net_buffer_length`.
     * 
     * * `requires_restart` - Whether changing the value `net_buffer_length` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_buffer_length`.
     * 
     * ## net_read_timeout
     * 
     * The following arguments are supported in the `net_read_timeout` specification block:
     * 
     * * `description` - The description of `net_read_timeout`.
     * 
     * * `example` - An example of a valid value for `net_read_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_read_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_read_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_read_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_read_timeout`.
     * 
     * ## net_write_timeout
     * 
     * The following arguments are supported in the `net_write_timeout` specification block:
     * 
     * * `description` - The description of `net_write_timeout`.
     * 
     * * `example` - An example of a valid value for `net_write_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_write_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_write_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_write_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_write_timeout`.
     * 
     * ## sort_buffer_size
     * 
     * The following arguments are supported in the `sort_buffer_size` specification block:
     * 
     * * `description` - The description of `sort_buffer_size`.
     * 
     * * `example` - An example of a valid value for `sort_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `sort_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `sort_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `sort_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sort_buffer_size`.
     * 
     * ## sql_mode
     * 
     * The following arguments are supported in the `sql_mode` specification block:
     * 
     * * `description` - The description of `sql_mode`.
     * 
     * * `example` - An example of a valid value for `sql_mode`.
     * 
     * * `maxLength` - The maximum valid length of `sql_mode`.
     * 
     * * `pattern` - The pattern to match for `sql_mode`.
     * 
     * * `requires_restart` - Whether changing the value `sql_mode` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_mode`.
     * 
     * ## sql_require_primary_key
     * 
     * The following arguments are supported in the `sql_require_primary_key` specification block:
     * 
     * * `description` - The description of `sql_require_primary_key`.
     * 
     * * `example` - An example of a valid value for `sql_require_primary_key`.
     * 
     * * `requires_restart` - Whether changing the value `sql_require_primary_key` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_require_primary_key`.
     * 
     * ## tmp_table_size
     * 
     * The following arguments are supported in the `tmp_table_size` specification block:
     * 
     * * `description` - The description of `tmp_table_size`.
     * 
     * * `example` - An example of a valid value for `tmp_table_size`.
     * 
     * * `maximum` - The maximum valid value of `tmp_table_size`.
     * 
     * * `minimum` - The minimum valid value of `tmp_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `tmp_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `tmp_table_size`.
     * 
     * ## wait_timeout
     * 
     * The following arguments are supported in the `wait_timeout` specification block:
     * 
     * * `description` - The description of `wait_timeout`.
     * 
     * * `example` - An example of a valid value for `wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `wait_timeout`.
     * 
     */
    public static CompletableFuture<GetDatabaseMysqlConfigResult> getDatabaseMysqlConfigPlain(InvokeArgs args) {
        return getDatabaseMysqlConfigPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode MySQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabaseMysqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## binlog_retention_period
     * 
     * The following arguments are supported in the `binlog_retention_period` specification block:
     * 
     * * `description` - The description of `binlog_retention_period`.
     * 
     * * `example` - An example of a valid value for `binlog_retention_period`.
     * 
     * * `maximum` - The maximum valid value of `binlog_retention_period`.
     * 
     * * `minimum` - The minimum valid value of `binlog_retention_period`.
     * 
     * * `requires_restart` - Whether changing the value `binlog_retention_period` requires the DB to restart.
     * 
     * * `type` - The type of the value of `binlog_retention_period`.
     * 
     * ## mysql
     * 
     * The following arguments are supported in the `mysql` specification block:
     * 
     * * `connect_timeout` - The number of seconds that the mysqld server waits for a connect packet before responding with &#34;Bad handshake&#34;.
     * 
     * * `default_time_zone` - Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or `SYSTEM` to use the MySQL server default.
     * 
     * * `group_concat_max_len` - The maximum permitted result length in bytes for the `GROUP_CONCAT()` function.
     * 
     * * `information_schema_stats_expiry` - The time, in seconds, before cached statistics expire.
     * 
     * * `innodb_change_buffer_max_size` - Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
     * 
     * * `innodb_flush_neighbors` - Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
     * 
     * * `innodb_ft_min_token_size` - Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_ft_server_stopword_table` - This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
     * 
     * * `innodb_lock_wait_timeout` - The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
     * 
     * * `innodb_log_buffer_size` - The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
     * 
     * * `innodb_online_alter_log_max_size` - The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
     * 
     * * `innodb_read_io_threads` - The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_rollback_on_timeout` - When enabled, a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_thread_concurrency` - Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
     * 
     * * `innodb_write_io_threads` - The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `interactive_timeout` - The number of seconds the server waits for activity on an interactive connection before closing it.
     * 
     * * `internal_tmp_mem_storage_engine` - The storage engine for in-memory internal temporary tables.
     * 
     * * `max_allowed_packet` - Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
     * 
     * * `max_heap_table_size` - Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
     * 
     * * `net_buffer_length` - Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `net_read_timeout` - The number of seconds to wait for more data from a connection before aborting the read.
     * 
     * * `net_write_timeout` - The number of seconds to wait for a block to be written to a connection before aborting the write.
     * 
     * * `sort_buffer_size` - Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
     * 
     * * `sql_mode` - Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
     * 
     * * `sql_require_primary_key` - Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
     * 
     * * `tmp_table_size` - Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
     * 
     * * `wait_timeout` - The number of seconds the server waits for activity on a noninteractive connection before closing it.
     * 
     * ## connect_timeout
     * 
     * The following arguments are supported in the `connect_timeout` specification block:
     * 
     * * `description` - The description of `connect_timeout`.
     * 
     * * `example` - An example of a valid value for `connect_timeout`.
     * 
     * * `maximum` - The maximum valid value of  `connect_timeout`.
     * 
     * * `minimum` - The minimum valid value of  `connect_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `connect_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `connect_timeout`.
     * 
     * ## default_time_zone
     * 
     * The following arguments are supported in the `default_time_zone` specification block:
     * 
     * * `description` - The description of `default_time_zone`.
     * 
     * * `example` - An example of a valid value for `default_time_zone`.
     * 
     * * `maxLength` - The maximum length of the `default_time_zone` value.
     * 
     * * `minLength` - The minimum length of the `default_time_zone` value.
     * 
     * * `pattern` - A regular expression that the `default_time_zone` value must match.
     * 
     * * `requires_restart` - Whether changing the value `default_time_zone` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_time_zone`.
     * 
     * ## group_concat_max_len
     * 
     * The following arguments are supported in the `group_concat_max_len` specification block:
     * 
     * * `description` - The description of `group_concat_max_len`.
     * 
     * * `example` - An example of a valid value for `group_concat_max_len`.
     * 
     * * `maximum` - The maximum valid value of `group_concat_max_len`.
     * 
     * * `minimum` - The minimum valid value of `group_concat_max_len`.
     * 
     * * `requires_restart` - Whether changing the value `group_concat_max_len` requires the DB to restart.
     * 
     * * `type` - The type of the value of `group_concat_max_len`.
     * 
     * ## information_schema_stats_expiry
     * 
     * The following arguments are supported in the `information_schema_stats_expiry` specification block:
     * 
     * * `description` - The description of `information_schema_stats_expiry`.
     * 
     * * `example` - An example of a valid value for `information_schema_stats_expiry`.
     * 
     * * `maximum` - The maximum valid value of `information_schema_stats_expiry`.
     * 
     * * `minimum` - The minimum valid value of `information_schema_stats_expiry`.
     * 
     * * `requires_restart` - Whether changing the value `information_schema_stats_expiry` requires the DB to restart.
     * 
     * * `type` - The type of the value of `information_schema_stats_expiry`.
     * 
     * ## innodb_change_buffer_max_size
     * 
     * The following arguments are supported in the `innodb_change_buffer_max_size` specification block:
     * 
     * * `description` - The description of `innodb_change_buffer_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_change_buffer_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_change_buffer_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_change_buffer_max_size`.
     * 
     * ## innodb_flush_neighbors
     * 
     * The following arguments are supported in the `innodb_flush_neighbors` specification block:
     * 
     * * `description` - The description of `innodb_flush_neighbors`.
     * 
     * * `example` - An example of a valid value for `innodb_flush_neighbors`.
     * 
     * * `maximum` - The maximum valid value of `innodb_flush_neighbors`.
     * 
     * * `minimum` - The minimum valid value of `innodb_flush_neighbors`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_flush_neighbors` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_flush_neighbors`.
     * 
     * ## innodb_ft_min_token_size
     * 
     * The following arguments are supported in the `innodb_ft_min_token_size` specification block:
     * 
     * * `description` - The description of `innodb_ft_min_token_size`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_min_token_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_ft_min_token_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_ft_min_token_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_min_token_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_min_token_size`.
     * 
     * ## innodb_ft_server_stopword_table
     * 
     * The following arguments are supported in the `innodb_ft_server_stopword_table` specification block:
     * 
     * * `description` - The description of `innodb_ft_server_stopword_table`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_server_stopword_table`.
     * 
     * * `maxLength` - The maximum length of the value for `innodb_ft_server_stopword_table`.
     * 
     * * `pattern` - A regex pattern that a value of `innodb_ft_server_stopword_table` must match.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_server_stopword_table` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_server_stopword_table`.
     * 
     * ## innodb_lock_wait_timeout
     * 
     * The following arguments are supported in the `innodb_lock_wait_timeout` specification block:
     * 
     * * `description` - The description of `innodb_lock_wait_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_lock_wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_lock_wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_lock_wait_timeout`.
     * 
     * ## innodb_log_buffer_size
     * 
     * The following arguments are supported in the `innodb_log_buffer_size` specification block:
     * 
     * * `description` - The description of `innodb_log_buffer_size`.
     * 
     * * `example` - An example of a valid value for `innodb_log_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_log_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_log_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_log_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_log_buffer_size`.
     * 
     * ## innodb_online_alter_log_max_size
     * 
     * The following arguments are supported in the `innodb_online_alter_log_max_size` specification block:
     * 
     * * `description` - The description of `innodb_online_alter_log_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_online_alter_log_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_online_alter_log_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_online_alter_log_max_size`.
     * 
     * ## innodb_read_io_threads
     * 
     * The following arguments are supported in the `innodb_read_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_read_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_read_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_read_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_read_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_read_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_read_io_threads`.
     * 
     * ## innodb_rollback_on_timeout
     * 
     * The following arguments are supported in the `innodb_rollback_on_timeout` specification block:
     * 
     * * `description` - The description of `innodb_rollback_on_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_rollback_on_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_rollback_on_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_rollback_on_timeout`.
     * 
     * ## innodb_thread_concurrency
     * 
     * The following arguments are supported in the `innodb_thread_concurrency` specification block:
     * 
     * * `description` - The description of `innodb_thread_concurrency`.
     * 
     * * `example` - An example of a valid value for `innodb_thread_concurrency`.
     * 
     * * `maximum` - The maximum valid value of `innodb_thread_concurrency`.
     * 
     * * `minimum` - The minimum valid value of `innodb_thread_concurrency`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_thread_concurrency` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_thread_concurrency`.
     * 
     * ## innodb_write_io_threads
     * 
     * The following arguments are supported in the `innodb_write_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_write_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_write_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_write_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_write_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_write_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_write_io_threads`.
     * 
     * ## interactive_timeout
     * 
     * The following arguments are supported in the `interactive_timeout` specification block:
     * 
     * * `description` - The description of `interactive_timeout`.
     * 
     * * `example` - An example of a valid value for `interactive_timeout`.
     * 
     * * `maximum` - The maximum valid value of `interactive_timeout`.
     * 
     * * `minimum` - The minimum valid value of `interactive_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `interactive_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `interactive_timeout`.
     * 
     * ## internal_tmp_mem_storage_engine
     * 
     * The following arguments are supported in the `internal_tmp_mem_storage_engine` specification block:
     * 
     * * `description` - The description of `internal_tmp_mem_storage_engine`.
     * 
     * * `enum` - A list of valid enum values for `internal_tmp_mem_storage_engine`.
     * 
     * * `example` - An example of a valid value for `internal_tmp_mem_storage_engine`.
     * 
     * * `requires_restart` - Whether changing the value `internal_tmp_mem_storage_engine` requires the DB to restart.
     * 
     * * `type` - The type of the value of `internal_tmp_mem_storage_engine`.
     * 
     * ## max_allowed_packet
     * 
     * The following arguments are supported in the `max_allowed_packet` specification block:
     * 
     * * `description` - The description of `max_allowed_packet`.
     * 
     * * `example` - An example of a valid value for `max_allowed_packet`.
     * 
     * * `maximum` - The maximum valid value of `max_allowed_packet`.
     * 
     * * `minimum` - The minimum valid value of `max_allowed_packet`.
     * 
     * * `requires_restart` - Whether changing the value `max_allowed_packet` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_allowed_packet`.
     * 
     * ## max_heap_table_size
     * 
     * The following arguments are supported in the `max_heap_table_size` specification block:
     * 
     * * `description` - The description of `max_heap_table_size`.
     * 
     * * `example` - An example of a valid value for `max_heap_table_size`.
     * 
     * * `maximum` - The maximum valid value of `max_heap_table_size`.
     * 
     * * `minimum` - The minimum valid value of `max_heap_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `max_heap_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_heap_table_size`.
     * 
     * ## net_buffer_length
     * 
     * The following arguments are supported in the `net_buffer_length` specification block:
     * 
     * * `description` - The description of `net_buffer_length`.
     * 
     * * `example` - An example of a valid value for `net_buffer_length`.
     * 
     * * `maximum` - The maximum valid value of `net_buffer_length`.
     * 
     * * `minimum` - The minimum valid value of `net_buffer_length`.
     * 
     * * `requires_restart` - Whether changing the value `net_buffer_length` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_buffer_length`.
     * 
     * ## net_read_timeout
     * 
     * The following arguments are supported in the `net_read_timeout` specification block:
     * 
     * * `description` - The description of `net_read_timeout`.
     * 
     * * `example` - An example of a valid value for `net_read_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_read_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_read_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_read_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_read_timeout`.
     * 
     * ## net_write_timeout
     * 
     * The following arguments are supported in the `net_write_timeout` specification block:
     * 
     * * `description` - The description of `net_write_timeout`.
     * 
     * * `example` - An example of a valid value for `net_write_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_write_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_write_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_write_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_write_timeout`.
     * 
     * ## sort_buffer_size
     * 
     * The following arguments are supported in the `sort_buffer_size` specification block:
     * 
     * * `description` - The description of `sort_buffer_size`.
     * 
     * * `example` - An example of a valid value for `sort_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `sort_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `sort_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `sort_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sort_buffer_size`.
     * 
     * ## sql_mode
     * 
     * The following arguments are supported in the `sql_mode` specification block:
     * 
     * * `description` - The description of `sql_mode`.
     * 
     * * `example` - An example of a valid value for `sql_mode`.
     * 
     * * `maxLength` - The maximum valid length of `sql_mode`.
     * 
     * * `pattern` - The pattern to match for `sql_mode`.
     * 
     * * `requires_restart` - Whether changing the value `sql_mode` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_mode`.
     * 
     * ## sql_require_primary_key
     * 
     * The following arguments are supported in the `sql_require_primary_key` specification block:
     * 
     * * `description` - The description of `sql_require_primary_key`.
     * 
     * * `example` - An example of a valid value for `sql_require_primary_key`.
     * 
     * * `requires_restart` - Whether changing the value `sql_require_primary_key` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_require_primary_key`.
     * 
     * ## tmp_table_size
     * 
     * The following arguments are supported in the `tmp_table_size` specification block:
     * 
     * * `description` - The description of `tmp_table_size`.
     * 
     * * `example` - An example of a valid value for `tmp_table_size`.
     * 
     * * `maximum` - The maximum valid value of `tmp_table_size`.
     * 
     * * `minimum` - The minimum valid value of `tmp_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `tmp_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `tmp_table_size`.
     * 
     * ## wait_timeout
     * 
     * The following arguments are supported in the `wait_timeout` specification block:
     * 
     * * `description` - The description of `wait_timeout`.
     * 
     * * `example` - An example of a valid value for `wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `wait_timeout`.
     * 
     */
    public static Output<GetDatabaseMysqlConfigResult> getDatabaseMysqlConfig(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseMysqlConfig:getDatabaseMysqlConfig", TypeShape.of(GetDatabaseMysqlConfigResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode MySQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabaseMysqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## binlog_retention_period
     * 
     * The following arguments are supported in the `binlog_retention_period` specification block:
     * 
     * * `description` - The description of `binlog_retention_period`.
     * 
     * * `example` - An example of a valid value for `binlog_retention_period`.
     * 
     * * `maximum` - The maximum valid value of `binlog_retention_period`.
     * 
     * * `minimum` - The minimum valid value of `binlog_retention_period`.
     * 
     * * `requires_restart` - Whether changing the value `binlog_retention_period` requires the DB to restart.
     * 
     * * `type` - The type of the value of `binlog_retention_period`.
     * 
     * ## mysql
     * 
     * The following arguments are supported in the `mysql` specification block:
     * 
     * * `connect_timeout` - The number of seconds that the mysqld server waits for a connect packet before responding with &#34;Bad handshake&#34;.
     * 
     * * `default_time_zone` - Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or `SYSTEM` to use the MySQL server default.
     * 
     * * `group_concat_max_len` - The maximum permitted result length in bytes for the `GROUP_CONCAT()` function.
     * 
     * * `information_schema_stats_expiry` - The time, in seconds, before cached statistics expire.
     * 
     * * `innodb_change_buffer_max_size` - Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
     * 
     * * `innodb_flush_neighbors` - Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
     * 
     * * `innodb_ft_min_token_size` - Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_ft_server_stopword_table` - This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
     * 
     * * `innodb_lock_wait_timeout` - The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
     * 
     * * `innodb_log_buffer_size` - The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
     * 
     * * `innodb_online_alter_log_max_size` - The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
     * 
     * * `innodb_read_io_threads` - The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_rollback_on_timeout` - When enabled, a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_thread_concurrency` - Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
     * 
     * * `innodb_write_io_threads` - The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `interactive_timeout` - The number of seconds the server waits for activity on an interactive connection before closing it.
     * 
     * * `internal_tmp_mem_storage_engine` - The storage engine for in-memory internal temporary tables.
     * 
     * * `max_allowed_packet` - Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
     * 
     * * `max_heap_table_size` - Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
     * 
     * * `net_buffer_length` - Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `net_read_timeout` - The number of seconds to wait for more data from a connection before aborting the read.
     * 
     * * `net_write_timeout` - The number of seconds to wait for a block to be written to a connection before aborting the write.
     * 
     * * `sort_buffer_size` - Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
     * 
     * * `sql_mode` - Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
     * 
     * * `sql_require_primary_key` - Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
     * 
     * * `tmp_table_size` - Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
     * 
     * * `wait_timeout` - The number of seconds the server waits for activity on a noninteractive connection before closing it.
     * 
     * ## connect_timeout
     * 
     * The following arguments are supported in the `connect_timeout` specification block:
     * 
     * * `description` - The description of `connect_timeout`.
     * 
     * * `example` - An example of a valid value for `connect_timeout`.
     * 
     * * `maximum` - The maximum valid value of  `connect_timeout`.
     * 
     * * `minimum` - The minimum valid value of  `connect_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `connect_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `connect_timeout`.
     * 
     * ## default_time_zone
     * 
     * The following arguments are supported in the `default_time_zone` specification block:
     * 
     * * `description` - The description of `default_time_zone`.
     * 
     * * `example` - An example of a valid value for `default_time_zone`.
     * 
     * * `maxLength` - The maximum length of the `default_time_zone` value.
     * 
     * * `minLength` - The minimum length of the `default_time_zone` value.
     * 
     * * `pattern` - A regular expression that the `default_time_zone` value must match.
     * 
     * * `requires_restart` - Whether changing the value `default_time_zone` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_time_zone`.
     * 
     * ## group_concat_max_len
     * 
     * The following arguments are supported in the `group_concat_max_len` specification block:
     * 
     * * `description` - The description of `group_concat_max_len`.
     * 
     * * `example` - An example of a valid value for `group_concat_max_len`.
     * 
     * * `maximum` - The maximum valid value of `group_concat_max_len`.
     * 
     * * `minimum` - The minimum valid value of `group_concat_max_len`.
     * 
     * * `requires_restart` - Whether changing the value `group_concat_max_len` requires the DB to restart.
     * 
     * * `type` - The type of the value of `group_concat_max_len`.
     * 
     * ## information_schema_stats_expiry
     * 
     * The following arguments are supported in the `information_schema_stats_expiry` specification block:
     * 
     * * `description` - The description of `information_schema_stats_expiry`.
     * 
     * * `example` - An example of a valid value for `information_schema_stats_expiry`.
     * 
     * * `maximum` - The maximum valid value of `information_schema_stats_expiry`.
     * 
     * * `minimum` - The minimum valid value of `information_schema_stats_expiry`.
     * 
     * * `requires_restart` - Whether changing the value `information_schema_stats_expiry` requires the DB to restart.
     * 
     * * `type` - The type of the value of `information_schema_stats_expiry`.
     * 
     * ## innodb_change_buffer_max_size
     * 
     * The following arguments are supported in the `innodb_change_buffer_max_size` specification block:
     * 
     * * `description` - The description of `innodb_change_buffer_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_change_buffer_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_change_buffer_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_change_buffer_max_size`.
     * 
     * ## innodb_flush_neighbors
     * 
     * The following arguments are supported in the `innodb_flush_neighbors` specification block:
     * 
     * * `description` - The description of `innodb_flush_neighbors`.
     * 
     * * `example` - An example of a valid value for `innodb_flush_neighbors`.
     * 
     * * `maximum` - The maximum valid value of `innodb_flush_neighbors`.
     * 
     * * `minimum` - The minimum valid value of `innodb_flush_neighbors`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_flush_neighbors` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_flush_neighbors`.
     * 
     * ## innodb_ft_min_token_size
     * 
     * The following arguments are supported in the `innodb_ft_min_token_size` specification block:
     * 
     * * `description` - The description of `innodb_ft_min_token_size`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_min_token_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_ft_min_token_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_ft_min_token_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_min_token_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_min_token_size`.
     * 
     * ## innodb_ft_server_stopword_table
     * 
     * The following arguments are supported in the `innodb_ft_server_stopword_table` specification block:
     * 
     * * `description` - The description of `innodb_ft_server_stopword_table`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_server_stopword_table`.
     * 
     * * `maxLength` - The maximum length of the value for `innodb_ft_server_stopword_table`.
     * 
     * * `pattern` - A regex pattern that a value of `innodb_ft_server_stopword_table` must match.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_server_stopword_table` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_server_stopword_table`.
     * 
     * ## innodb_lock_wait_timeout
     * 
     * The following arguments are supported in the `innodb_lock_wait_timeout` specification block:
     * 
     * * `description` - The description of `innodb_lock_wait_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_lock_wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_lock_wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_lock_wait_timeout`.
     * 
     * ## innodb_log_buffer_size
     * 
     * The following arguments are supported in the `innodb_log_buffer_size` specification block:
     * 
     * * `description` - The description of `innodb_log_buffer_size`.
     * 
     * * `example` - An example of a valid value for `innodb_log_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_log_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_log_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_log_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_log_buffer_size`.
     * 
     * ## innodb_online_alter_log_max_size
     * 
     * The following arguments are supported in the `innodb_online_alter_log_max_size` specification block:
     * 
     * * `description` - The description of `innodb_online_alter_log_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_online_alter_log_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_online_alter_log_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_online_alter_log_max_size`.
     * 
     * ## innodb_read_io_threads
     * 
     * The following arguments are supported in the `innodb_read_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_read_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_read_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_read_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_read_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_read_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_read_io_threads`.
     * 
     * ## innodb_rollback_on_timeout
     * 
     * The following arguments are supported in the `innodb_rollback_on_timeout` specification block:
     * 
     * * `description` - The description of `innodb_rollback_on_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_rollback_on_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_rollback_on_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_rollback_on_timeout`.
     * 
     * ## innodb_thread_concurrency
     * 
     * The following arguments are supported in the `innodb_thread_concurrency` specification block:
     * 
     * * `description` - The description of `innodb_thread_concurrency`.
     * 
     * * `example` - An example of a valid value for `innodb_thread_concurrency`.
     * 
     * * `maximum` - The maximum valid value of `innodb_thread_concurrency`.
     * 
     * * `minimum` - The minimum valid value of `innodb_thread_concurrency`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_thread_concurrency` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_thread_concurrency`.
     * 
     * ## innodb_write_io_threads
     * 
     * The following arguments are supported in the `innodb_write_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_write_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_write_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_write_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_write_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_write_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_write_io_threads`.
     * 
     * ## interactive_timeout
     * 
     * The following arguments are supported in the `interactive_timeout` specification block:
     * 
     * * `description` - The description of `interactive_timeout`.
     * 
     * * `example` - An example of a valid value for `interactive_timeout`.
     * 
     * * `maximum` - The maximum valid value of `interactive_timeout`.
     * 
     * * `minimum` - The minimum valid value of `interactive_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `interactive_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `interactive_timeout`.
     * 
     * ## internal_tmp_mem_storage_engine
     * 
     * The following arguments are supported in the `internal_tmp_mem_storage_engine` specification block:
     * 
     * * `description` - The description of `internal_tmp_mem_storage_engine`.
     * 
     * * `enum` - A list of valid enum values for `internal_tmp_mem_storage_engine`.
     * 
     * * `example` - An example of a valid value for `internal_tmp_mem_storage_engine`.
     * 
     * * `requires_restart` - Whether changing the value `internal_tmp_mem_storage_engine` requires the DB to restart.
     * 
     * * `type` - The type of the value of `internal_tmp_mem_storage_engine`.
     * 
     * ## max_allowed_packet
     * 
     * The following arguments are supported in the `max_allowed_packet` specification block:
     * 
     * * `description` - The description of `max_allowed_packet`.
     * 
     * * `example` - An example of a valid value for `max_allowed_packet`.
     * 
     * * `maximum` - The maximum valid value of `max_allowed_packet`.
     * 
     * * `minimum` - The minimum valid value of `max_allowed_packet`.
     * 
     * * `requires_restart` - Whether changing the value `max_allowed_packet` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_allowed_packet`.
     * 
     * ## max_heap_table_size
     * 
     * The following arguments are supported in the `max_heap_table_size` specification block:
     * 
     * * `description` - The description of `max_heap_table_size`.
     * 
     * * `example` - An example of a valid value for `max_heap_table_size`.
     * 
     * * `maximum` - The maximum valid value of `max_heap_table_size`.
     * 
     * * `minimum` - The minimum valid value of `max_heap_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `max_heap_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_heap_table_size`.
     * 
     * ## net_buffer_length
     * 
     * The following arguments are supported in the `net_buffer_length` specification block:
     * 
     * * `description` - The description of `net_buffer_length`.
     * 
     * * `example` - An example of a valid value for `net_buffer_length`.
     * 
     * * `maximum` - The maximum valid value of `net_buffer_length`.
     * 
     * * `minimum` - The minimum valid value of `net_buffer_length`.
     * 
     * * `requires_restart` - Whether changing the value `net_buffer_length` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_buffer_length`.
     * 
     * ## net_read_timeout
     * 
     * The following arguments are supported in the `net_read_timeout` specification block:
     * 
     * * `description` - The description of `net_read_timeout`.
     * 
     * * `example` - An example of a valid value for `net_read_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_read_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_read_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_read_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_read_timeout`.
     * 
     * ## net_write_timeout
     * 
     * The following arguments are supported in the `net_write_timeout` specification block:
     * 
     * * `description` - The description of `net_write_timeout`.
     * 
     * * `example` - An example of a valid value for `net_write_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_write_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_write_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_write_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_write_timeout`.
     * 
     * ## sort_buffer_size
     * 
     * The following arguments are supported in the `sort_buffer_size` specification block:
     * 
     * * `description` - The description of `sort_buffer_size`.
     * 
     * * `example` - An example of a valid value for `sort_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `sort_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `sort_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `sort_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sort_buffer_size`.
     * 
     * ## sql_mode
     * 
     * The following arguments are supported in the `sql_mode` specification block:
     * 
     * * `description` - The description of `sql_mode`.
     * 
     * * `example` - An example of a valid value for `sql_mode`.
     * 
     * * `maxLength` - The maximum valid length of `sql_mode`.
     * 
     * * `pattern` - The pattern to match for `sql_mode`.
     * 
     * * `requires_restart` - Whether changing the value `sql_mode` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_mode`.
     * 
     * ## sql_require_primary_key
     * 
     * The following arguments are supported in the `sql_require_primary_key` specification block:
     * 
     * * `description` - The description of `sql_require_primary_key`.
     * 
     * * `example` - An example of a valid value for `sql_require_primary_key`.
     * 
     * * `requires_restart` - Whether changing the value `sql_require_primary_key` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_require_primary_key`.
     * 
     * ## tmp_table_size
     * 
     * The following arguments are supported in the `tmp_table_size` specification block:
     * 
     * * `description` - The description of `tmp_table_size`.
     * 
     * * `example` - An example of a valid value for `tmp_table_size`.
     * 
     * * `maximum` - The maximum valid value of `tmp_table_size`.
     * 
     * * `minimum` - The minimum valid value of `tmp_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `tmp_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `tmp_table_size`.
     * 
     * ## wait_timeout
     * 
     * The following arguments are supported in the `wait_timeout` specification block:
     * 
     * * `description` - The description of `wait_timeout`.
     * 
     * * `example` - An example of a valid value for `wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `wait_timeout`.
     * 
     */
    public static Output<GetDatabaseMysqlConfigResult> getDatabaseMysqlConfig(InvokeArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseMysqlConfig:getDatabaseMysqlConfig", TypeShape.of(GetDatabaseMysqlConfigResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode MySQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabaseMysqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## binlog_retention_period
     * 
     * The following arguments are supported in the `binlog_retention_period` specification block:
     * 
     * * `description` - The description of `binlog_retention_period`.
     * 
     * * `example` - An example of a valid value for `binlog_retention_period`.
     * 
     * * `maximum` - The maximum valid value of `binlog_retention_period`.
     * 
     * * `minimum` - The minimum valid value of `binlog_retention_period`.
     * 
     * * `requires_restart` - Whether changing the value `binlog_retention_period` requires the DB to restart.
     * 
     * * `type` - The type of the value of `binlog_retention_period`.
     * 
     * ## mysql
     * 
     * The following arguments are supported in the `mysql` specification block:
     * 
     * * `connect_timeout` - The number of seconds that the mysqld server waits for a connect packet before responding with &#34;Bad handshake&#34;.
     * 
     * * `default_time_zone` - Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or `SYSTEM` to use the MySQL server default.
     * 
     * * `group_concat_max_len` - The maximum permitted result length in bytes for the `GROUP_CONCAT()` function.
     * 
     * * `information_schema_stats_expiry` - The time, in seconds, before cached statistics expire.
     * 
     * * `innodb_change_buffer_max_size` - Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
     * 
     * * `innodb_flush_neighbors` - Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
     * 
     * * `innodb_ft_min_token_size` - Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_ft_server_stopword_table` - This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
     * 
     * * `innodb_lock_wait_timeout` - The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
     * 
     * * `innodb_log_buffer_size` - The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
     * 
     * * `innodb_online_alter_log_max_size` - The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
     * 
     * * `innodb_read_io_threads` - The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_rollback_on_timeout` - When enabled, a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `innodb_thread_concurrency` - Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
     * 
     * * `innodb_write_io_threads` - The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `interactive_timeout` - The number of seconds the server waits for activity on an interactive connection before closing it.
     * 
     * * `internal_tmp_mem_storage_engine` - The storage engine for in-memory internal temporary tables.
     * 
     * * `max_allowed_packet` - Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
     * 
     * * `max_heap_table_size` - Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
     * 
     * * `net_buffer_length` - Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
     * 
     * * `net_read_timeout` - The number of seconds to wait for more data from a connection before aborting the read.
     * 
     * * `net_write_timeout` - The number of seconds to wait for a block to be written to a connection before aborting the write.
     * 
     * * `sort_buffer_size` - Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
     * 
     * * `sql_mode` - Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
     * 
     * * `sql_require_primary_key` - Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
     * 
     * * `tmp_table_size` - Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
     * 
     * * `wait_timeout` - The number of seconds the server waits for activity on a noninteractive connection before closing it.
     * 
     * ## connect_timeout
     * 
     * The following arguments are supported in the `connect_timeout` specification block:
     * 
     * * `description` - The description of `connect_timeout`.
     * 
     * * `example` - An example of a valid value for `connect_timeout`.
     * 
     * * `maximum` - The maximum valid value of  `connect_timeout`.
     * 
     * * `minimum` - The minimum valid value of  `connect_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `connect_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `connect_timeout`.
     * 
     * ## default_time_zone
     * 
     * The following arguments are supported in the `default_time_zone` specification block:
     * 
     * * `description` - The description of `default_time_zone`.
     * 
     * * `example` - An example of a valid value for `default_time_zone`.
     * 
     * * `maxLength` - The maximum length of the `default_time_zone` value.
     * 
     * * `minLength` - The minimum length of the `default_time_zone` value.
     * 
     * * `pattern` - A regular expression that the `default_time_zone` value must match.
     * 
     * * `requires_restart` - Whether changing the value `default_time_zone` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_time_zone`.
     * 
     * ## group_concat_max_len
     * 
     * The following arguments are supported in the `group_concat_max_len` specification block:
     * 
     * * `description` - The description of `group_concat_max_len`.
     * 
     * * `example` - An example of a valid value for `group_concat_max_len`.
     * 
     * * `maximum` - The maximum valid value of `group_concat_max_len`.
     * 
     * * `minimum` - The minimum valid value of `group_concat_max_len`.
     * 
     * * `requires_restart` - Whether changing the value `group_concat_max_len` requires the DB to restart.
     * 
     * * `type` - The type of the value of `group_concat_max_len`.
     * 
     * ## information_schema_stats_expiry
     * 
     * The following arguments are supported in the `information_schema_stats_expiry` specification block:
     * 
     * * `description` - The description of `information_schema_stats_expiry`.
     * 
     * * `example` - An example of a valid value for `information_schema_stats_expiry`.
     * 
     * * `maximum` - The maximum valid value of `information_schema_stats_expiry`.
     * 
     * * `minimum` - The minimum valid value of `information_schema_stats_expiry`.
     * 
     * * `requires_restart` - Whether changing the value `information_schema_stats_expiry` requires the DB to restart.
     * 
     * * `type` - The type of the value of `information_schema_stats_expiry`.
     * 
     * ## innodb_change_buffer_max_size
     * 
     * The following arguments are supported in the `innodb_change_buffer_max_size` specification block:
     * 
     * * `description` - The description of `innodb_change_buffer_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_change_buffer_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_change_buffer_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_change_buffer_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_change_buffer_max_size`.
     * 
     * ## innodb_flush_neighbors
     * 
     * The following arguments are supported in the `innodb_flush_neighbors` specification block:
     * 
     * * `description` - The description of `innodb_flush_neighbors`.
     * 
     * * `example` - An example of a valid value for `innodb_flush_neighbors`.
     * 
     * * `maximum` - The maximum valid value of `innodb_flush_neighbors`.
     * 
     * * `minimum` - The minimum valid value of `innodb_flush_neighbors`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_flush_neighbors` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_flush_neighbors`.
     * 
     * ## innodb_ft_min_token_size
     * 
     * The following arguments are supported in the `innodb_ft_min_token_size` specification block:
     * 
     * * `description` - The description of `innodb_ft_min_token_size`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_min_token_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_ft_min_token_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_ft_min_token_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_min_token_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_min_token_size`.
     * 
     * ## innodb_ft_server_stopword_table
     * 
     * The following arguments are supported in the `innodb_ft_server_stopword_table` specification block:
     * 
     * * `description` - The description of `innodb_ft_server_stopword_table`.
     * 
     * * `example` - An example of a valid value for `innodb_ft_server_stopword_table`.
     * 
     * * `maxLength` - The maximum length of the value for `innodb_ft_server_stopword_table`.
     * 
     * * `pattern` - A regex pattern that a value of `innodb_ft_server_stopword_table` must match.
     * 
     * * `requires_restart` - Whether changing the value `innodb_ft_server_stopword_table` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_ft_server_stopword_table`.
     * 
     * ## innodb_lock_wait_timeout
     * 
     * The following arguments are supported in the `innodb_lock_wait_timeout` specification block:
     * 
     * * `description` - The description of `innodb_lock_wait_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_lock_wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `innodb_lock_wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_lock_wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_lock_wait_timeout`.
     * 
     * ## innodb_log_buffer_size
     * 
     * The following arguments are supported in the `innodb_log_buffer_size` specification block:
     * 
     * * `description` - The description of `innodb_log_buffer_size`.
     * 
     * * `example` - An example of a valid value for `innodb_log_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_log_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_log_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_log_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_log_buffer_size`.
     * 
     * ## innodb_online_alter_log_max_size
     * 
     * The following arguments are supported in the `innodb_online_alter_log_max_size` specification block:
     * 
     * * `description` - The description of `innodb_online_alter_log_max_size`.
     * 
     * * `example` - An example of a valid value for `innodb_online_alter_log_max_size`.
     * 
     * * `maximum` - The maximum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `minimum` - The minimum valid value of `innodb_online_alter_log_max_size`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_online_alter_log_max_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_online_alter_log_max_size`.
     * 
     * ## innodb_read_io_threads
     * 
     * The following arguments are supported in the `innodb_read_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_read_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_read_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_read_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_read_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_read_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_read_io_threads`.
     * 
     * ## innodb_rollback_on_timeout
     * 
     * The following arguments are supported in the `innodb_rollback_on_timeout` specification block:
     * 
     * * `description` - The description of `innodb_rollback_on_timeout`.
     * 
     * * `example` - An example of a valid value for `innodb_rollback_on_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_rollback_on_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_rollback_on_timeout`.
     * 
     * ## innodb_thread_concurrency
     * 
     * The following arguments are supported in the `innodb_thread_concurrency` specification block:
     * 
     * * `description` - The description of `innodb_thread_concurrency`.
     * 
     * * `example` - An example of a valid value for `innodb_thread_concurrency`.
     * 
     * * `maximum` - The maximum valid value of `innodb_thread_concurrency`.
     * 
     * * `minimum` - The minimum valid value of `innodb_thread_concurrency`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_thread_concurrency` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_thread_concurrency`.
     * 
     * ## innodb_write_io_threads
     * 
     * The following arguments are supported in the `innodb_write_io_threads` specification block:
     * 
     * * `description` - The description of `innodb_write_io_threads`.
     * 
     * * `example` - An example of a valid value for `innodb_write_io_threads`.
     * 
     * * `maximum` - The maximum valid value of `innodb_write_io_threads`.
     * 
     * * `minimum` - The minimum valid value of `innodb_write_io_threads`.
     * 
     * * `requires_restart` - Whether changing the value `innodb_write_io_threads` requires the DB to restart.
     * 
     * * `type` - The type of the value of `innodb_write_io_threads`.
     * 
     * ## interactive_timeout
     * 
     * The following arguments are supported in the `interactive_timeout` specification block:
     * 
     * * `description` - The description of `interactive_timeout`.
     * 
     * * `example` - An example of a valid value for `interactive_timeout`.
     * 
     * * `maximum` - The maximum valid value of `interactive_timeout`.
     * 
     * * `minimum` - The minimum valid value of `interactive_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `interactive_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `interactive_timeout`.
     * 
     * ## internal_tmp_mem_storage_engine
     * 
     * The following arguments are supported in the `internal_tmp_mem_storage_engine` specification block:
     * 
     * * `description` - The description of `internal_tmp_mem_storage_engine`.
     * 
     * * `enum` - A list of valid enum values for `internal_tmp_mem_storage_engine`.
     * 
     * * `example` - An example of a valid value for `internal_tmp_mem_storage_engine`.
     * 
     * * `requires_restart` - Whether changing the value `internal_tmp_mem_storage_engine` requires the DB to restart.
     * 
     * * `type` - The type of the value of `internal_tmp_mem_storage_engine`.
     * 
     * ## max_allowed_packet
     * 
     * The following arguments are supported in the `max_allowed_packet` specification block:
     * 
     * * `description` - The description of `max_allowed_packet`.
     * 
     * * `example` - An example of a valid value for `max_allowed_packet`.
     * 
     * * `maximum` - The maximum valid value of `max_allowed_packet`.
     * 
     * * `minimum` - The minimum valid value of `max_allowed_packet`.
     * 
     * * `requires_restart` - Whether changing the value `max_allowed_packet` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_allowed_packet`.
     * 
     * ## max_heap_table_size
     * 
     * The following arguments are supported in the `max_heap_table_size` specification block:
     * 
     * * `description` - The description of `max_heap_table_size`.
     * 
     * * `example` - An example of a valid value for `max_heap_table_size`.
     * 
     * * `maximum` - The maximum valid value of `max_heap_table_size`.
     * 
     * * `minimum` - The minimum valid value of `max_heap_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `max_heap_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_heap_table_size`.
     * 
     * ## net_buffer_length
     * 
     * The following arguments are supported in the `net_buffer_length` specification block:
     * 
     * * `description` - The description of `net_buffer_length`.
     * 
     * * `example` - An example of a valid value for `net_buffer_length`.
     * 
     * * `maximum` - The maximum valid value of `net_buffer_length`.
     * 
     * * `minimum` - The minimum valid value of `net_buffer_length`.
     * 
     * * `requires_restart` - Whether changing the value `net_buffer_length` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_buffer_length`.
     * 
     * ## net_read_timeout
     * 
     * The following arguments are supported in the `net_read_timeout` specification block:
     * 
     * * `description` - The description of `net_read_timeout`.
     * 
     * * `example` - An example of a valid value for `net_read_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_read_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_read_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_read_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_read_timeout`.
     * 
     * ## net_write_timeout
     * 
     * The following arguments are supported in the `net_write_timeout` specification block:
     * 
     * * `description` - The description of `net_write_timeout`.
     * 
     * * `example` - An example of a valid value for `net_write_timeout`.
     * 
     * * `maximum` - The maximum valid value of `net_write_timeout`.
     * 
     * * `minimum` - The minimum valid value of `net_write_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `net_write_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `net_write_timeout`.
     * 
     * ## sort_buffer_size
     * 
     * The following arguments are supported in the `sort_buffer_size` specification block:
     * 
     * * `description` - The description of `sort_buffer_size`.
     * 
     * * `example` - An example of a valid value for `sort_buffer_size`.
     * 
     * * `maximum` - The maximum valid value of `sort_buffer_size`.
     * 
     * * `minimum` - The minimum valid value of `sort_buffer_size`.
     * 
     * * `requires_restart` - Whether changing the value `sort_buffer_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sort_buffer_size`.
     * 
     * ## sql_mode
     * 
     * The following arguments are supported in the `sql_mode` specification block:
     * 
     * * `description` - The description of `sql_mode`.
     * 
     * * `example` - An example of a valid value for `sql_mode`.
     * 
     * * `maxLength` - The maximum valid length of `sql_mode`.
     * 
     * * `pattern` - The pattern to match for `sql_mode`.
     * 
     * * `requires_restart` - Whether changing the value `sql_mode` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_mode`.
     * 
     * ## sql_require_primary_key
     * 
     * The following arguments are supported in the `sql_require_primary_key` specification block:
     * 
     * * `description` - The description of `sql_require_primary_key`.
     * 
     * * `example` - An example of a valid value for `sql_require_primary_key`.
     * 
     * * `requires_restart` - Whether changing the value `sql_require_primary_key` requires the DB to restart.
     * 
     * * `type` - The type of the value of `sql_require_primary_key`.
     * 
     * ## tmp_table_size
     * 
     * The following arguments are supported in the `tmp_table_size` specification block:
     * 
     * * `description` - The description of `tmp_table_size`.
     * 
     * * `example` - An example of a valid value for `tmp_table_size`.
     * 
     * * `maximum` - The maximum valid value of `tmp_table_size`.
     * 
     * * `minimum` - The minimum valid value of `tmp_table_size`.
     * 
     * * `requires_restart` - Whether changing the value `tmp_table_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `tmp_table_size`.
     * 
     * ## wait_timeout
     * 
     * The following arguments are supported in the `wait_timeout` specification block:
     * 
     * * `description` - The description of `wait_timeout`.
     * 
     * * `example` - An example of a valid value for `wait_timeout`.
     * 
     * * `maximum` - The maximum valid value of `wait_timeout`.
     * 
     * * `minimum` - The minimum valid value of `wait_timeout`.
     * 
     * * `requires_restart` - Whether changing the value `wait_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `wait_timeout`.
     * 
     */
    public static CompletableFuture<GetDatabaseMysqlConfigResult> getDatabaseMysqlConfigPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDatabaseMysqlConfig:getDatabaseMysqlConfig", TypeShape.of(GetDatabaseMysqlConfigResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlV2Args;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysqlV2(GetDatabaseMysqlV2Args.builder()
     *             .id("12345")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pending_updates
     * 
     * The following arguments are exposed by each entry in the `pending_updates` attribute:
     * 
     * * `deadline` - The time when a mandatory update needs to be applied.
     * 
     * * `description` - A description of the update.
     * 
     * * `planned_for` - The date and time a maintenance update will be applied.
     * 
     * ## updates
     * 
     * The following arguments are supported in the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - The frequency at which maintenance occurs. (`weekly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     */
    public static Output<GetDatabaseMysqlV2Result> getDatabaseMysqlV2(GetDatabaseMysqlV2Args args) {
        return getDatabaseMysqlV2(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlV2Args;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysqlV2(GetDatabaseMysqlV2Args.builder()
     *             .id("12345")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pending_updates
     * 
     * The following arguments are exposed by each entry in the `pending_updates` attribute:
     * 
     * * `deadline` - The time when a mandatory update needs to be applied.
     * 
     * * `description` - A description of the update.
     * 
     * * `planned_for` - The date and time a maintenance update will be applied.
     * 
     * ## updates
     * 
     * The following arguments are supported in the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - The frequency at which maintenance occurs. (`weekly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     */
    public static CompletableFuture<GetDatabaseMysqlV2Result> getDatabaseMysqlV2Plain(GetDatabaseMysqlV2PlainArgs args) {
        return getDatabaseMysqlV2Plain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlV2Args;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysqlV2(GetDatabaseMysqlV2Args.builder()
     *             .id("12345")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pending_updates
     * 
     * The following arguments are exposed by each entry in the `pending_updates` attribute:
     * 
     * * `deadline` - The time when a mandatory update needs to be applied.
     * 
     * * `description` - A description of the update.
     * 
     * * `planned_for` - The date and time a maintenance update will be applied.
     * 
     * ## updates
     * 
     * The following arguments are supported in the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - The frequency at which maintenance occurs. (`weekly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     */
    public static Output<GetDatabaseMysqlV2Result> getDatabaseMysqlV2(GetDatabaseMysqlV2Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseMysqlV2:getDatabaseMysqlV2", TypeShape.of(GetDatabaseMysqlV2Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlV2Args;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysqlV2(GetDatabaseMysqlV2Args.builder()
     *             .id("12345")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pending_updates
     * 
     * The following arguments are exposed by each entry in the `pending_updates` attribute:
     * 
     * * `deadline` - The time when a mandatory update needs to be applied.
     * 
     * * `description` - A description of the update.
     * 
     * * `planned_for` - The date and time a maintenance update will be applied.
     * 
     * ## updates
     * 
     * The following arguments are supported in the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - The frequency at which maintenance occurs. (`weekly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     */
    public static Output<GetDatabaseMysqlV2Result> getDatabaseMysqlV2(GetDatabaseMysqlV2Args args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabaseMysqlV2:getDatabaseMysqlV2", TypeShape.of(GetDatabaseMysqlV2Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode MySQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance).
     * 
     * ## Example Usage
     * 
     * Get information about a MySQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabaseMysqlV2Args;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabaseMysqlV2(GetDatabaseMysqlV2Args.builder()
     *             .id("12345")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pending_updates
     * 
     * The following arguments are exposed by each entry in the `pending_updates` attribute:
     * 
     * * `deadline` - The time when a mandatory update needs to be applied.
     * 
     * * `description` - A description of the update.
     * 
     * * `planned_for` - The date and time a maintenance update will be applied.
     * 
     * ## updates
     * 
     * The following arguments are supported in the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - The frequency at which maintenance occurs. (`weekly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     */
    public static CompletableFuture<GetDatabaseMysqlV2Result> getDatabaseMysqlV2Plain(GetDatabaseMysqlV2PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDatabaseMysqlV2:getDatabaseMysqlV2", TypeShape.of(GetDatabaseMysqlV2Result.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabasePostgresqlV2 for all future implementations.
     * 
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresql(GetDatabasePostgresqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static Output<GetDatabasePostgresqlResult> getDatabasePostgresql() {
        return getDatabasePostgresql(GetDatabasePostgresqlArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabasePostgresqlV2 for all future implementations.
     * 
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresql(GetDatabasePostgresqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static CompletableFuture<GetDatabasePostgresqlResult> getDatabasePostgresqlPlain() {
        return getDatabasePostgresqlPlain(GetDatabasePostgresqlPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabasePostgresqlV2 for all future implementations.
     * 
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresql(GetDatabasePostgresqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static Output<GetDatabasePostgresqlResult> getDatabasePostgresql(GetDatabasePostgresqlArgs args) {
        return getDatabasePostgresql(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabasePostgresqlV2 for all future implementations.
     * 
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresql(GetDatabasePostgresqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static CompletableFuture<GetDatabasePostgresqlResult> getDatabasePostgresqlPlain(GetDatabasePostgresqlPlainArgs args) {
        return getDatabasePostgresqlPlain(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabasePostgresqlV2 for all future implementations.
     * 
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresql(GetDatabasePostgresqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static Output<GetDatabasePostgresqlResult> getDatabasePostgresql(GetDatabasePostgresqlArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabasePostgresql:getDatabasePostgresql", TypeShape.of(GetDatabasePostgresqlResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabasePostgresqlV2 for all future implementations.
     * 
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresql(GetDatabasePostgresqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static Output<GetDatabasePostgresqlResult> getDatabasePostgresql(GetDatabasePostgresqlArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabasePostgresql:getDatabasePostgresql", TypeShape.of(GetDatabasePostgresqlResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATION NOTICE:** This data source has been deprecated. Please use linode.DatabasePostgresqlV2 for all future implementations.
     * 
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresql(GetDatabasePostgresqlArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## updates
     * 
     * The following arguments are exported by the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - Whether maintenance occurs on a weekly or monthly basis. (`weekly`, `monthly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     * * `week_of_month` - The week of the month to perform monthly frequency updates. Required for `monthly` frequency updates. (`1`..`4`)
     * 
     */
    public static CompletableFuture<GetDatabasePostgresqlResult> getDatabasePostgresqlPlain(GetDatabasePostgresqlPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDatabasePostgresql:getDatabasePostgresql", TypeShape.of(GetDatabasePostgresqlResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode PostgreSQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabasePostgresqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pg_stat_monitor_enable
     * 
     * The following arguments are supported in the `pg_stat_monitor_enable` specification block:
     * 
     * * `description` - The description of `pg_stat_monitor_enable`.
     * 
     * * `requires_restart` - Whether changing the value `pg_stat_monitor_enable` requires the DB to restart.
     * 
     * * `type` - The type of the value of `pg_stat_monitor_enable`.
     * 
     * ## pglookout
     * 
     * The following arguments are supported in the `pglookout` specification block:
     * 
     * * `max_failover_replication_time_lag` - The maximum failover replication time lag for `pglookout`.
     * 
     * ## max_failover_replication_time_lag
     * 
     * The following arguments are supported in the `max_failover_replication_time_lag` specification block:
     * 
     * * `description` - The description of `max_failover_replication_time_lag`.
     * 
     * * `maximum` - The maximum valid value for `max_failover_replication_time_lag`.
     * 
     * * `minimum` - The minimum valid value for `max_failover_replication_time_lag`.
     * 
     * * `requires_restart` - Whether changing the value of `max_failover_replication_time_lag` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_failover_replication_time_lag`.
     * 
     * ## shared_buffers_percentage
     * 
     * The following arguments are supported in the `shared_buffers_percentage` specification block:
     * 
     * * `description` - The description of `shared_buffers_percentage`.
     * 
     * * `example` - An example of a valid value for `shared_buffers_percentage`.
     * 
     * * `maximum` - The maximum valid value for `shared_buffers_percentage`.
     * 
     * * `minimum` - The minimum valid value for `shared_buffers_percentage`.
     * 
     * * `requires_restart` - Whether changing the value of `shared_buffers_percentage` requires the DB to restart.
     * 
     * * `type` - The type of the value of `shared_buffers_percentage`.
     * 
     * ## work_mem
     * 
     * The following arguments are supported in the `work_mem` specification block:
     * 
     * * `description` - The description of `work_mem`.
     * 
     * * `example` - An example of a valid value for `work_mem`.
     * 
     * * `maximum` - The maximum valid value for `work_mem`.
     * 
     * * `minimum` - The minimum valid value for `work_mem`.
     * 
     * * `requires_restart` - Whether changing the value of `work_mem` requires the DB to restart.
     * 
     * * `type` - The type of the value of `work_mem`.
     * 
     * ## pg
     * 
     * The following arguments are supported in the `pg` specification block:
     * 
     * * `autovacuum_analyze_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_analyze_threshold` - (Optional) Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
     * 
     * * `autovacuum_max_workers` - (Optional) Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
     * 
     * * `autovacuum_naptime` - (Optional) Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
     * 
     * * `autovacuum_vacuum_cost_delay` - (Optional) Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
     * 
     * * `autovacuum_vacuum_cost_limit` - (Optional) Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
     * 
     * * `autovacuum_vacuum_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_vacuum_threshold` - (Optional) Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
     * 
     * * `bgwriter_delay` - (Optional) Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
     * 
     * * `bgwriter_flush_after` - (Optional) Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
     * 
     * * `bgwriter_lru_maxpages` - (Optional) In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
     * 
     * * `bgwriter_lru_multiplier` - (Optional) The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
     * 
     * * `deadlock_timeout` - (Optional) This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
     * 
     * * `default_toast_compression` - (Optional) Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
     * 
     * * `idle_in_transaction_session_timeout` - (Optional) Time out sessions with open transactions after this number of milliseconds.
     * 
     * * `jit` - (Optional) Controls system-wide use of Just-in-Time Compilation (JIT).
     * 
     * * `max_files_per_process` - (Optional) PostgreSQL maximum number of files that can be open per process.
     * 
     * * `max_locks_per_transaction` - (Optional) PostgreSQL maximum locks per transaction.
     * 
     * * `max_logical_replication_workers` - (Optional) PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
     * 
     * * `max_parallel_workers` - (Optional) Sets the maximum number of workers that the system can support for parallel queries.
     * 
     * * `max_parallel_workers_per_gather` - (Optional) Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
     * 
     * * `max_pred_locks_per_transaction` - (Optional) PostgreSQL maximum predicate locks per transaction.
     * 
     * * `max_replication_slots` - (Optional) PostgreSQL maximum replication slots.
     * 
     * * `max_slot_wal_keep_size` - (Optional) PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
     * 
     * * `max_stack_depth` - (Optional) Maximum depth of the stack in bytes.
     * 
     * * `max_standby_archive_delay` - (Optional) Max standby archive delay in milliseconds.
     * 
     * * `max_standby_streaming_delay` - (Optional) Max standby streaming delay in milliseconds.
     * 
     * * `max_wal_senders` - (Optional) PostgreSQL maximum WAL senders.
     * 
     * * `max_worker_processes` - (Optional) Sets the maximum number of background processes that the system can support.
     * 
     * * `password_encryption` - (Optional) Chooses the algorithm for encrypting passwords.
     * 
     * * `pg_partman_bgw.interval` - (Optional) Sets the time interval to run pg_partman&#39;s scheduled tasks.
     * 
     * * `pg_partman_bgw.role` - (Optional) Controls which role to use for pg_partman&#39;s scheduled background tasks.
     * 
     * * `pg_stat_monitor.pgsm_enable_query_plan` - (Optional) Enables or disables query plan monitoring.
     * 
     * * `pg_stat_monitor.pgsm_max_buckets` - (Optional) Sets the maximum number of buckets.
     * 
     * * `pg_stat_statements.track` - (Optional) Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
     * 
     * * `temp_file_limit` - (Optional) PostgreSQL temporary file limit in KiB, -1 for unlimited.
     * 
     * * `timezone` - (Optional) PostgreSQL service timezone.
     * 
     * * `track_activity_query_size` - (Optional) Specifies the number of bytes reserved to track the currently executing command for each active session.
     * 
     * * `track_commit_timestamp` - (Optional) Record commit time of transactions.
     * 
     * * `track_functions` - (Optional) Enables tracking of function call counts and time used.
     * 
     * * `track_io_timing` - (Optional) Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
     * 
     * * `wal_sender_timeout` - (Optional) Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
     * 
     * * `wal_writer_delay` - (Optional) WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
     * 
     * ## autovacuum_analyze_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_analyze_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_scale_factor`.
     * 
     * ## autovacuum_analyze_threshold
     * 
     * The following arguments are supported in the `autovacuum_analyze_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_threshold`.
     * 
     * ## autovacuum_max_workers
     * 
     * The following arguments are supported in the `autovacuum_max_workers` specification block:
     * 
     * * `description` - The description of `autovacuum_max_workers`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_max_workers`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_max_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_max_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_max_workers`.
     * 
     * ## autovacuum_naptime
     * 
     * The following arguments are supported in the `autovacuum_naptime` specification block:
     * 
     * * `description` - The description of `autovacuum_naptime`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_naptime`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_naptime`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_naptime` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_naptime`.
     * 
     * ## autovacuum_vacuum_cost_delay
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_delay` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_delay`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_delay`.
     * 
     * ## autovacuum_vacuum_cost_limit
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_limit` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_limit`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_limit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_limit`.
     * 
     * ## autovacuum_vacuum_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_vacuum_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_scale_factor`.
     * 
     * ## autovacuum_vacuum_threshold
     * 
     * The following arguments are supported in the `autovacuum_vacuum_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_threshold`.
     * 
     * ## bgwriter_delay
     * 
     * The following arguments are supported in the `bgwriter_delay` specification block:
     * 
     * * `description` - The description of `bgwriter_delay`.
     * 
     * * `example` - An example of a valid value for `bgwriter_delay`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_delay`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_delay`.
     * 
     * ## bgwriter_flush_after
     * 
     * The following arguments are supported in the `bgwriter_flush_after` specification block:
     * 
     * * `description` - The description of `bgwriter_flush_after`.
     * 
     * * `example` - An example of a valid value for `bgwriter_flush_after`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_flush_after`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_flush_after`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_flush_after` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_flush_after`.
     * 
     * ## bgwriter_lru_maxpages
     * 
     * The following arguments are supported in the `bgwriter_lru_maxpages` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_maxpages`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_maxpages`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_maxpages` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_maxpages`.
     * 
     * ## bgwriter_lru_multiplier
     * 
     * The following arguments are supported in the `bgwriter_lru_multiplier` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_multiplier`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_multiplier`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_multiplier` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_multiplier`.
     * 
     * ## deadlock_timeout
     * 
     * The following arguments are supported in the `deadlock_timeout` specification block:
     * 
     * * `description` - The description of `deadlock_timeout`.
     * 
     * * `example` - An example of a valid value for `deadlock_timeout`.
     * 
     * * `maximum` - The maximum valid value for `deadlock_timeout`.
     * 
     * * `minimum` - The minimum valid value for `deadlock_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `deadlock_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `deadlock_timeout`.
     * 
     * ## default_toast_compression
     * 
     * The following arguments are supported in the `default_toast_compression` specification block:
     * 
     * * `description` - The description of `default_toast_compression`.
     * 
     * * `enum` - A list of valid compression methods for `default_toast_compression`.
     * 
     * * `example` - An example of a valid value for `default_toast_compression`.
     * 
     * * `requires_restart` - Whether changing the value of `default_toast_compression` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_toast_compression`.
     * 
     * ## idle_in_transaction_session_timeout
     * 
     * The following arguments are supported in the `idle_in_transaction_session_timeout` specification block:
     * 
     * * `description` - The description of `idle_in_transaction_session_timeout`.
     * 
     * * `maximum` - The maximum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `minimum` - The minimum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `idle_in_transaction_session_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `idle_in_transaction_session_timeout`.
     * 
     * ## jit
     * 
     * The following arguments are supported in the `jit` specification block:
     * 
     * * `description` - The description of `jit`.
     * 
     * * `example` - An example of a valid value for `jit`.
     * 
     * * `requires_restart` - Whether changing the value of `jit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `jit`.
     * 
     * ## max_files_per_process
     * 
     * The following arguments are supported in the `max_files_per_process` specification block:
     * 
     * * `description` - The description of `max_files_per_process`.
     * 
     * * `maximum` - The maximum valid value for `max_files_per_process`.
     * 
     * * `minimum` - The minimum valid value for `max_files_per_process`.
     * 
     * * `requires_restart` - Whether changing the value of `max_files_per_process` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_files_per_process`.
     * 
     * ## max_locks_per_transaction
     * 
     * The following arguments are supported in the `max_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_locks_per_transaction`.
     * 
     * ## max_logical_replication_workers
     * 
     * The following arguments are supported in the `max_logical_replication_workers` specification block:
     * 
     * * `description` - The description of `max_logical_replication_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_logical_replication_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_logical_replication_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_logical_replication_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_logical_replication_workers`.
     * 
     * ## max_parallel_workers
     * 
     * The following arguments are supported in the `max_parallel_workers` specification block:
     * 
     * * `description` - The description of `max_parallel_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers`.
     * 
     * ## max_parallel_workers_per_gather
     * 
     * The following arguments are supported in the `max_parallel_workers_per_gather` specification block:
     * 
     * * `description` - The description of `max_parallel_workers_per_gather`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers_per_gather` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers_per_gather`.
     * 
     * ## max_pred_locks_per_transaction
     * 
     * The following arguments are supported in the `max_pred_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_pred_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_pred_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_pred_locks_per_transaction`.
     * 
     * ## max_replication_slots
     * 
     * The following arguments are supported in the `max_replication_slots` specification block:
     * 
     * * `description` - The description of `max_replication_slots`.
     * 
     * * `maximum` - The maximum valid value for `max_replication_slots`.
     * 
     * * `minimum` - The minimum valid value for `max_replication_slots`.
     * 
     * * `requires_restart` - Whether changing the value of `max_replication_slots` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_replication_slots`.
     * 
     * ## max_slot_wal_keep_size
     * 
     * The following arguments are supported in the `max_slot_wal_keep_size` specification block:
     * 
     * * `description` - The description of `max_slot_wal_keep_size`.
     * 
     * * `maximum` - The maximum valid value for `max_slot_wal_keep_size`.
     * 
     * * `minimum` - The minimum valid value for `max_slot_wal_keep_size`.
     * 
     * * `requires_restart` - Whether changing the value of `max_slot_wal_keep_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_slot_wal_keep_size`.
     * 
     * ## max_stack_depth
     * 
     * The following arguments are supported in the `max_stack_depth` specification block:
     * 
     * * `description` - The description of `max_stack_depth`.
     * 
     * * `maximum` - The maximum valid value for `max_stack_depth`.
     * 
     * * `minimum` - The minimum valid value for `max_stack_depth`.
     * 
     * * `requires_restart` - Whether changing the value of `max_stack_depth` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_stack_depth`.
     * 
     * ## max_standby_archive_delay
     * 
     * The following arguments are supported in the `max_standby_archive_delay` specification block:
     * 
     * * `description` - The description of `max_standby_archive_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_archive_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_archive_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_archive_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_archive_delay`.
     * 
     * ## max_standby_streaming_delay
     * 
     * The following arguments are supported in the `max_standby_streaming_delay` specification block:
     * 
     * * `description` - The description of `max_standby_streaming_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_streaming_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_streaming_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_streaming_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_streaming_delay`.
     * 
     * ## max_wal_senders
     * 
     * The following arguments are supported in the `max_wal_senders` specification block:
     * 
     * * `description` - The description of `max_wal_senders`.
     * 
     * * `maximum` - The maximum valid value for `max_wal_senders`.
     * 
     * * `minimum` - The minimum valid value for `max_wal_senders`.
     * 
     * * `requires_restart` - Whether changing the value of `max_wal_senders` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_wal_senders`.
     * 
     * ## max_worker_processes
     * 
     * The following arguments are supported in the `max_worker_processes` specification block:
     * 
     * * `description` - The description of `max_worker_processes`.
     * 
     * * `maximum` - The maximum valid value for `max_worker_processes`.
     * 
     * * `minimum` - The minimum valid value for `max_worker_processes`.
     * 
     * * `requires_restart` - Whether changing the value of `max_worker_processes` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_worker_processes`.
     * 
     * ## password_encryption
     * 
     * The following arguments are supported in the `password_encryption` specification block:
     * 
     * * `description` - The description of the `password_encryption` setting.
     * 
     * * `enum` - A list of valid values for the `password_encryption` setting.
     * 
     * * `example` - An example value for the `password_encryption` setting.
     * 
     * * `requires_restart` - Whether changing the value of `password_encryption` requires the DB to restart.
     * 
     * * `type` - A list of types for the `password_encryption` setting.
     * 
     * ## pg_partman_bgw_interval
     * 
     * The following arguments are supported in the `pg_partman_bgw_interval` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_interval` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_interval` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_interval` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_interval` setting.
     * 
     * ## pg_partman_bgw_role
     * 
     * The following arguments are supported in the `pg_partman_bgw_role` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_role` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_role` setting.
     * 
     * * `maxLength` - The maximum length for the `pg_partman_bgw_role` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `pg_partman_bgw_role` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_role` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_role` setting.
     * 
     * ## pg_stat_monitor_pgsm_enable_query_plan
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_enable_query_plan` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_enable_query_plan` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * ## pg_stat_monitor_pgsm_max_buckets
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_max_buckets` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_max_buckets` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * ## pg_stat_statements_track
     * 
     * The following arguments are supported in the `pg_stat_statements_track` specification block:
     * 
     * * `description` - The description of the `pg_stat_statements_track` setting.
     * 
     * * `enum` - A list of valid values for the `pg_stat_statements_track` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_statements_track` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_statements_track` setting.
     * 
     * ## temp_file_limit
     * 
     * The following arguments are supported in the `temp_file_limit` specification block:
     * 
     * * `description` - The description of the `temp_file_limit` setting.
     * 
     * * `example` - An example value for the `temp_file_limit` setting.
     * 
     * * `maximum` - The maximum allowed value for the `temp_file_limit` setting.
     * 
     * * `minimum` - The minimum allowed value for the `temp_file_limit` setting.
     * 
     * * `requires_restart` - Whether changing the value of `temp_file_limit` requires the DB to restart.
     * 
     * * `type` - The type of the `temp_file_limit` setting.
     * 
     * ## timezone
     * 
     * The following arguments are supported in the `timezone` specification block:
     * 
     * * `description` - The description of the `timezone` setting.
     * 
     * * `example` - An example value for the `timezone` setting.
     * 
     * * `maxLength` - The maximum length for the `timezone` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `timezone` setting.
     * 
     * * `requires_restart` - Whether changing the value of `timezone` requires the DB to restart.
     * 
     * * `type` - The type of the `timezone` setting.
     * 
     * ## track_activity_query_size
     * 
     * The following arguments are supported in the `track_activity_query_size` specification block:
     * 
     * * `description` - The description of the `track_activity_query_size` setting.
     * 
     * * `example` - An example value for the `track_activity_query_size` setting.
     * 
     * * `maximum` - The maximum allowed value for the `track_activity_query_size` setting.
     * 
     * * `minimum` - The minimum allowed value for the `track_activity_query_size` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_activity_query_size` requires the DB to restart.
     * 
     * * `type` - The type of the `track_activity_query_size` setting.
     * 
     * ## track_commit_timestamp
     * 
     * The following arguments are supported in the `track_commit_timestamp` specification block:
     * 
     * * `description` - The description of the `track_commit_timestamp` setting.
     * 
     * * `enum` - A list of valid values for the `track_commit_timestamp` setting.
     * 
     * * `example` - An example value for the `track_commit_timestamp` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_commit_timestamp` requires the DB to restart.
     * 
     * * `type` - The type of the `track_commit_timestamp` setting.
     * 
     * ## track_functions
     * 
     * The following arguments are supported in the `track_functions` specification block:
     * 
     * * `description` - The description of the `track_functions` setting.
     * 
     * * `enum` - A list of valid values for the `track_functions` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_functions` requires the DB to restart.
     * 
     * * `type` - The type of the `track_functions` setting.
     * 
     * ## track_io_timing
     * 
     * The following arguments are supported in the `track_io_timing` specification block:
     * 
     * * `description` - The description of the `track_io_timing` setting.
     * 
     * * `enum` - A list of valid values for the `track_io_timing` setting.
     * 
     * * `example` - An example value for the `track_io_timing` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_io_timing` requires the DB to restart.
     * 
     * * `type` - The type of the `track_io_timing` setting.
     * 
     * ## wal_sender_timeout
     * 
     * The following arguments are supported in the `wal_sender_timeout` specification block:
     * 
     * * `description` - The description of the `wal_sender_timeout` setting.
     * 
     * * `example` - An example value for the `wal_sender_timeout` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_sender_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_sender_timeout` setting.
     * 
     * ## wal_writer_delay
     * 
     * The following arguments are supported in the `wal_writer_delay` specification block:
     * 
     * * `description` - The description of the `wal_writer_delay` setting.
     * 
     * * `example` - An example value for the `wal_writer_delay` setting.
     * 
     * * `maximum` - The maximum allowed value for the `wal_writer_delay` setting.
     * 
     * * `minimum` - The minimum allowed value for the `wal_writer_delay` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_writer_delay` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_writer_delay` setting.
     * 
     */
    public static Output<GetDatabasePostgresqlConfigResult> getDatabasePostgresqlConfig() {
        return getDatabasePostgresqlConfig(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode PostgreSQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabasePostgresqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pg_stat_monitor_enable
     * 
     * The following arguments are supported in the `pg_stat_monitor_enable` specification block:
     * 
     * * `description` - The description of `pg_stat_monitor_enable`.
     * 
     * * `requires_restart` - Whether changing the value `pg_stat_monitor_enable` requires the DB to restart.
     * 
     * * `type` - The type of the value of `pg_stat_monitor_enable`.
     * 
     * ## pglookout
     * 
     * The following arguments are supported in the `pglookout` specification block:
     * 
     * * `max_failover_replication_time_lag` - The maximum failover replication time lag for `pglookout`.
     * 
     * ## max_failover_replication_time_lag
     * 
     * The following arguments are supported in the `max_failover_replication_time_lag` specification block:
     * 
     * * `description` - The description of `max_failover_replication_time_lag`.
     * 
     * * `maximum` - The maximum valid value for `max_failover_replication_time_lag`.
     * 
     * * `minimum` - The minimum valid value for `max_failover_replication_time_lag`.
     * 
     * * `requires_restart` - Whether changing the value of `max_failover_replication_time_lag` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_failover_replication_time_lag`.
     * 
     * ## shared_buffers_percentage
     * 
     * The following arguments are supported in the `shared_buffers_percentage` specification block:
     * 
     * * `description` - The description of `shared_buffers_percentage`.
     * 
     * * `example` - An example of a valid value for `shared_buffers_percentage`.
     * 
     * * `maximum` - The maximum valid value for `shared_buffers_percentage`.
     * 
     * * `minimum` - The minimum valid value for `shared_buffers_percentage`.
     * 
     * * `requires_restart` - Whether changing the value of `shared_buffers_percentage` requires the DB to restart.
     * 
     * * `type` - The type of the value of `shared_buffers_percentage`.
     * 
     * ## work_mem
     * 
     * The following arguments are supported in the `work_mem` specification block:
     * 
     * * `description` - The description of `work_mem`.
     * 
     * * `example` - An example of a valid value for `work_mem`.
     * 
     * * `maximum` - The maximum valid value for `work_mem`.
     * 
     * * `minimum` - The minimum valid value for `work_mem`.
     * 
     * * `requires_restart` - Whether changing the value of `work_mem` requires the DB to restart.
     * 
     * * `type` - The type of the value of `work_mem`.
     * 
     * ## pg
     * 
     * The following arguments are supported in the `pg` specification block:
     * 
     * * `autovacuum_analyze_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_analyze_threshold` - (Optional) Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
     * 
     * * `autovacuum_max_workers` - (Optional) Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
     * 
     * * `autovacuum_naptime` - (Optional) Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
     * 
     * * `autovacuum_vacuum_cost_delay` - (Optional) Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
     * 
     * * `autovacuum_vacuum_cost_limit` - (Optional) Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
     * 
     * * `autovacuum_vacuum_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_vacuum_threshold` - (Optional) Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
     * 
     * * `bgwriter_delay` - (Optional) Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
     * 
     * * `bgwriter_flush_after` - (Optional) Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
     * 
     * * `bgwriter_lru_maxpages` - (Optional) In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
     * 
     * * `bgwriter_lru_multiplier` - (Optional) The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
     * 
     * * `deadlock_timeout` - (Optional) This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
     * 
     * * `default_toast_compression` - (Optional) Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
     * 
     * * `idle_in_transaction_session_timeout` - (Optional) Time out sessions with open transactions after this number of milliseconds.
     * 
     * * `jit` - (Optional) Controls system-wide use of Just-in-Time Compilation (JIT).
     * 
     * * `max_files_per_process` - (Optional) PostgreSQL maximum number of files that can be open per process.
     * 
     * * `max_locks_per_transaction` - (Optional) PostgreSQL maximum locks per transaction.
     * 
     * * `max_logical_replication_workers` - (Optional) PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
     * 
     * * `max_parallel_workers` - (Optional) Sets the maximum number of workers that the system can support for parallel queries.
     * 
     * * `max_parallel_workers_per_gather` - (Optional) Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
     * 
     * * `max_pred_locks_per_transaction` - (Optional) PostgreSQL maximum predicate locks per transaction.
     * 
     * * `max_replication_slots` - (Optional) PostgreSQL maximum replication slots.
     * 
     * * `max_slot_wal_keep_size` - (Optional) PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
     * 
     * * `max_stack_depth` - (Optional) Maximum depth of the stack in bytes.
     * 
     * * `max_standby_archive_delay` - (Optional) Max standby archive delay in milliseconds.
     * 
     * * `max_standby_streaming_delay` - (Optional) Max standby streaming delay in milliseconds.
     * 
     * * `max_wal_senders` - (Optional) PostgreSQL maximum WAL senders.
     * 
     * * `max_worker_processes` - (Optional) Sets the maximum number of background processes that the system can support.
     * 
     * * `password_encryption` - (Optional) Chooses the algorithm for encrypting passwords.
     * 
     * * `pg_partman_bgw.interval` - (Optional) Sets the time interval to run pg_partman&#39;s scheduled tasks.
     * 
     * * `pg_partman_bgw.role` - (Optional) Controls which role to use for pg_partman&#39;s scheduled background tasks.
     * 
     * * `pg_stat_monitor.pgsm_enable_query_plan` - (Optional) Enables or disables query plan monitoring.
     * 
     * * `pg_stat_monitor.pgsm_max_buckets` - (Optional) Sets the maximum number of buckets.
     * 
     * * `pg_stat_statements.track` - (Optional) Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
     * 
     * * `temp_file_limit` - (Optional) PostgreSQL temporary file limit in KiB, -1 for unlimited.
     * 
     * * `timezone` - (Optional) PostgreSQL service timezone.
     * 
     * * `track_activity_query_size` - (Optional) Specifies the number of bytes reserved to track the currently executing command for each active session.
     * 
     * * `track_commit_timestamp` - (Optional) Record commit time of transactions.
     * 
     * * `track_functions` - (Optional) Enables tracking of function call counts and time used.
     * 
     * * `track_io_timing` - (Optional) Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
     * 
     * * `wal_sender_timeout` - (Optional) Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
     * 
     * * `wal_writer_delay` - (Optional) WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
     * 
     * ## autovacuum_analyze_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_analyze_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_scale_factor`.
     * 
     * ## autovacuum_analyze_threshold
     * 
     * The following arguments are supported in the `autovacuum_analyze_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_threshold`.
     * 
     * ## autovacuum_max_workers
     * 
     * The following arguments are supported in the `autovacuum_max_workers` specification block:
     * 
     * * `description` - The description of `autovacuum_max_workers`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_max_workers`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_max_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_max_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_max_workers`.
     * 
     * ## autovacuum_naptime
     * 
     * The following arguments are supported in the `autovacuum_naptime` specification block:
     * 
     * * `description` - The description of `autovacuum_naptime`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_naptime`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_naptime`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_naptime` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_naptime`.
     * 
     * ## autovacuum_vacuum_cost_delay
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_delay` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_delay`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_delay`.
     * 
     * ## autovacuum_vacuum_cost_limit
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_limit` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_limit`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_limit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_limit`.
     * 
     * ## autovacuum_vacuum_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_vacuum_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_scale_factor`.
     * 
     * ## autovacuum_vacuum_threshold
     * 
     * The following arguments are supported in the `autovacuum_vacuum_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_threshold`.
     * 
     * ## bgwriter_delay
     * 
     * The following arguments are supported in the `bgwriter_delay` specification block:
     * 
     * * `description` - The description of `bgwriter_delay`.
     * 
     * * `example` - An example of a valid value for `bgwriter_delay`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_delay`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_delay`.
     * 
     * ## bgwriter_flush_after
     * 
     * The following arguments are supported in the `bgwriter_flush_after` specification block:
     * 
     * * `description` - The description of `bgwriter_flush_after`.
     * 
     * * `example` - An example of a valid value for `bgwriter_flush_after`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_flush_after`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_flush_after`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_flush_after` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_flush_after`.
     * 
     * ## bgwriter_lru_maxpages
     * 
     * The following arguments are supported in the `bgwriter_lru_maxpages` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_maxpages`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_maxpages`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_maxpages` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_maxpages`.
     * 
     * ## bgwriter_lru_multiplier
     * 
     * The following arguments are supported in the `bgwriter_lru_multiplier` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_multiplier`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_multiplier`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_multiplier` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_multiplier`.
     * 
     * ## deadlock_timeout
     * 
     * The following arguments are supported in the `deadlock_timeout` specification block:
     * 
     * * `description` - The description of `deadlock_timeout`.
     * 
     * * `example` - An example of a valid value for `deadlock_timeout`.
     * 
     * * `maximum` - The maximum valid value for `deadlock_timeout`.
     * 
     * * `minimum` - The minimum valid value for `deadlock_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `deadlock_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `deadlock_timeout`.
     * 
     * ## default_toast_compression
     * 
     * The following arguments are supported in the `default_toast_compression` specification block:
     * 
     * * `description` - The description of `default_toast_compression`.
     * 
     * * `enum` - A list of valid compression methods for `default_toast_compression`.
     * 
     * * `example` - An example of a valid value for `default_toast_compression`.
     * 
     * * `requires_restart` - Whether changing the value of `default_toast_compression` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_toast_compression`.
     * 
     * ## idle_in_transaction_session_timeout
     * 
     * The following arguments are supported in the `idle_in_transaction_session_timeout` specification block:
     * 
     * * `description` - The description of `idle_in_transaction_session_timeout`.
     * 
     * * `maximum` - The maximum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `minimum` - The minimum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `idle_in_transaction_session_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `idle_in_transaction_session_timeout`.
     * 
     * ## jit
     * 
     * The following arguments are supported in the `jit` specification block:
     * 
     * * `description` - The description of `jit`.
     * 
     * * `example` - An example of a valid value for `jit`.
     * 
     * * `requires_restart` - Whether changing the value of `jit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `jit`.
     * 
     * ## max_files_per_process
     * 
     * The following arguments are supported in the `max_files_per_process` specification block:
     * 
     * * `description` - The description of `max_files_per_process`.
     * 
     * * `maximum` - The maximum valid value for `max_files_per_process`.
     * 
     * * `minimum` - The minimum valid value for `max_files_per_process`.
     * 
     * * `requires_restart` - Whether changing the value of `max_files_per_process` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_files_per_process`.
     * 
     * ## max_locks_per_transaction
     * 
     * The following arguments are supported in the `max_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_locks_per_transaction`.
     * 
     * ## max_logical_replication_workers
     * 
     * The following arguments are supported in the `max_logical_replication_workers` specification block:
     * 
     * * `description` - The description of `max_logical_replication_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_logical_replication_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_logical_replication_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_logical_replication_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_logical_replication_workers`.
     * 
     * ## max_parallel_workers
     * 
     * The following arguments are supported in the `max_parallel_workers` specification block:
     * 
     * * `description` - The description of `max_parallel_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers`.
     * 
     * ## max_parallel_workers_per_gather
     * 
     * The following arguments are supported in the `max_parallel_workers_per_gather` specification block:
     * 
     * * `description` - The description of `max_parallel_workers_per_gather`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers_per_gather` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers_per_gather`.
     * 
     * ## max_pred_locks_per_transaction
     * 
     * The following arguments are supported in the `max_pred_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_pred_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_pred_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_pred_locks_per_transaction`.
     * 
     * ## max_replication_slots
     * 
     * The following arguments are supported in the `max_replication_slots` specification block:
     * 
     * * `description` - The description of `max_replication_slots`.
     * 
     * * `maximum` - The maximum valid value for `max_replication_slots`.
     * 
     * * `minimum` - The minimum valid value for `max_replication_slots`.
     * 
     * * `requires_restart` - Whether changing the value of `max_replication_slots` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_replication_slots`.
     * 
     * ## max_slot_wal_keep_size
     * 
     * The following arguments are supported in the `max_slot_wal_keep_size` specification block:
     * 
     * * `description` - The description of `max_slot_wal_keep_size`.
     * 
     * * `maximum` - The maximum valid value for `max_slot_wal_keep_size`.
     * 
     * * `minimum` - The minimum valid value for `max_slot_wal_keep_size`.
     * 
     * * `requires_restart` - Whether changing the value of `max_slot_wal_keep_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_slot_wal_keep_size`.
     * 
     * ## max_stack_depth
     * 
     * The following arguments are supported in the `max_stack_depth` specification block:
     * 
     * * `description` - The description of `max_stack_depth`.
     * 
     * * `maximum` - The maximum valid value for `max_stack_depth`.
     * 
     * * `minimum` - The minimum valid value for `max_stack_depth`.
     * 
     * * `requires_restart` - Whether changing the value of `max_stack_depth` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_stack_depth`.
     * 
     * ## max_standby_archive_delay
     * 
     * The following arguments are supported in the `max_standby_archive_delay` specification block:
     * 
     * * `description` - The description of `max_standby_archive_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_archive_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_archive_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_archive_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_archive_delay`.
     * 
     * ## max_standby_streaming_delay
     * 
     * The following arguments are supported in the `max_standby_streaming_delay` specification block:
     * 
     * * `description` - The description of `max_standby_streaming_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_streaming_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_streaming_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_streaming_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_streaming_delay`.
     * 
     * ## max_wal_senders
     * 
     * The following arguments are supported in the `max_wal_senders` specification block:
     * 
     * * `description` - The description of `max_wal_senders`.
     * 
     * * `maximum` - The maximum valid value for `max_wal_senders`.
     * 
     * * `minimum` - The minimum valid value for `max_wal_senders`.
     * 
     * * `requires_restart` - Whether changing the value of `max_wal_senders` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_wal_senders`.
     * 
     * ## max_worker_processes
     * 
     * The following arguments are supported in the `max_worker_processes` specification block:
     * 
     * * `description` - The description of `max_worker_processes`.
     * 
     * * `maximum` - The maximum valid value for `max_worker_processes`.
     * 
     * * `minimum` - The minimum valid value for `max_worker_processes`.
     * 
     * * `requires_restart` - Whether changing the value of `max_worker_processes` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_worker_processes`.
     * 
     * ## password_encryption
     * 
     * The following arguments are supported in the `password_encryption` specification block:
     * 
     * * `description` - The description of the `password_encryption` setting.
     * 
     * * `enum` - A list of valid values for the `password_encryption` setting.
     * 
     * * `example` - An example value for the `password_encryption` setting.
     * 
     * * `requires_restart` - Whether changing the value of `password_encryption` requires the DB to restart.
     * 
     * * `type` - A list of types for the `password_encryption` setting.
     * 
     * ## pg_partman_bgw_interval
     * 
     * The following arguments are supported in the `pg_partman_bgw_interval` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_interval` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_interval` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_interval` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_interval` setting.
     * 
     * ## pg_partman_bgw_role
     * 
     * The following arguments are supported in the `pg_partman_bgw_role` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_role` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_role` setting.
     * 
     * * `maxLength` - The maximum length for the `pg_partman_bgw_role` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `pg_partman_bgw_role` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_role` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_role` setting.
     * 
     * ## pg_stat_monitor_pgsm_enable_query_plan
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_enable_query_plan` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_enable_query_plan` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * ## pg_stat_monitor_pgsm_max_buckets
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_max_buckets` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_max_buckets` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * ## pg_stat_statements_track
     * 
     * The following arguments are supported in the `pg_stat_statements_track` specification block:
     * 
     * * `description` - The description of the `pg_stat_statements_track` setting.
     * 
     * * `enum` - A list of valid values for the `pg_stat_statements_track` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_statements_track` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_statements_track` setting.
     * 
     * ## temp_file_limit
     * 
     * The following arguments are supported in the `temp_file_limit` specification block:
     * 
     * * `description` - The description of the `temp_file_limit` setting.
     * 
     * * `example` - An example value for the `temp_file_limit` setting.
     * 
     * * `maximum` - The maximum allowed value for the `temp_file_limit` setting.
     * 
     * * `minimum` - The minimum allowed value for the `temp_file_limit` setting.
     * 
     * * `requires_restart` - Whether changing the value of `temp_file_limit` requires the DB to restart.
     * 
     * * `type` - The type of the `temp_file_limit` setting.
     * 
     * ## timezone
     * 
     * The following arguments are supported in the `timezone` specification block:
     * 
     * * `description` - The description of the `timezone` setting.
     * 
     * * `example` - An example value for the `timezone` setting.
     * 
     * * `maxLength` - The maximum length for the `timezone` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `timezone` setting.
     * 
     * * `requires_restart` - Whether changing the value of `timezone` requires the DB to restart.
     * 
     * * `type` - The type of the `timezone` setting.
     * 
     * ## track_activity_query_size
     * 
     * The following arguments are supported in the `track_activity_query_size` specification block:
     * 
     * * `description` - The description of the `track_activity_query_size` setting.
     * 
     * * `example` - An example value for the `track_activity_query_size` setting.
     * 
     * * `maximum` - The maximum allowed value for the `track_activity_query_size` setting.
     * 
     * * `minimum` - The minimum allowed value for the `track_activity_query_size` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_activity_query_size` requires the DB to restart.
     * 
     * * `type` - The type of the `track_activity_query_size` setting.
     * 
     * ## track_commit_timestamp
     * 
     * The following arguments are supported in the `track_commit_timestamp` specification block:
     * 
     * * `description` - The description of the `track_commit_timestamp` setting.
     * 
     * * `enum` - A list of valid values for the `track_commit_timestamp` setting.
     * 
     * * `example` - An example value for the `track_commit_timestamp` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_commit_timestamp` requires the DB to restart.
     * 
     * * `type` - The type of the `track_commit_timestamp` setting.
     * 
     * ## track_functions
     * 
     * The following arguments are supported in the `track_functions` specification block:
     * 
     * * `description` - The description of the `track_functions` setting.
     * 
     * * `enum` - A list of valid values for the `track_functions` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_functions` requires the DB to restart.
     * 
     * * `type` - The type of the `track_functions` setting.
     * 
     * ## track_io_timing
     * 
     * The following arguments are supported in the `track_io_timing` specification block:
     * 
     * * `description` - The description of the `track_io_timing` setting.
     * 
     * * `enum` - A list of valid values for the `track_io_timing` setting.
     * 
     * * `example` - An example value for the `track_io_timing` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_io_timing` requires the DB to restart.
     * 
     * * `type` - The type of the `track_io_timing` setting.
     * 
     * ## wal_sender_timeout
     * 
     * The following arguments are supported in the `wal_sender_timeout` specification block:
     * 
     * * `description` - The description of the `wal_sender_timeout` setting.
     * 
     * * `example` - An example value for the `wal_sender_timeout` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_sender_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_sender_timeout` setting.
     * 
     * ## wal_writer_delay
     * 
     * The following arguments are supported in the `wal_writer_delay` specification block:
     * 
     * * `description` - The description of the `wal_writer_delay` setting.
     * 
     * * `example` - An example value for the `wal_writer_delay` setting.
     * 
     * * `maximum` - The maximum allowed value for the `wal_writer_delay` setting.
     * 
     * * `minimum` - The minimum allowed value for the `wal_writer_delay` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_writer_delay` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_writer_delay` setting.
     * 
     */
    public static CompletableFuture<GetDatabasePostgresqlConfigResult> getDatabasePostgresqlConfigPlain() {
        return getDatabasePostgresqlConfigPlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode PostgreSQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabasePostgresqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pg_stat_monitor_enable
     * 
     * The following arguments are supported in the `pg_stat_monitor_enable` specification block:
     * 
     * * `description` - The description of `pg_stat_monitor_enable`.
     * 
     * * `requires_restart` - Whether changing the value `pg_stat_monitor_enable` requires the DB to restart.
     * 
     * * `type` - The type of the value of `pg_stat_monitor_enable`.
     * 
     * ## pglookout
     * 
     * The following arguments are supported in the `pglookout` specification block:
     * 
     * * `max_failover_replication_time_lag` - The maximum failover replication time lag for `pglookout`.
     * 
     * ## max_failover_replication_time_lag
     * 
     * The following arguments are supported in the `max_failover_replication_time_lag` specification block:
     * 
     * * `description` - The description of `max_failover_replication_time_lag`.
     * 
     * * `maximum` - The maximum valid value for `max_failover_replication_time_lag`.
     * 
     * * `minimum` - The minimum valid value for `max_failover_replication_time_lag`.
     * 
     * * `requires_restart` - Whether changing the value of `max_failover_replication_time_lag` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_failover_replication_time_lag`.
     * 
     * ## shared_buffers_percentage
     * 
     * The following arguments are supported in the `shared_buffers_percentage` specification block:
     * 
     * * `description` - The description of `shared_buffers_percentage`.
     * 
     * * `example` - An example of a valid value for `shared_buffers_percentage`.
     * 
     * * `maximum` - The maximum valid value for `shared_buffers_percentage`.
     * 
     * * `minimum` - The minimum valid value for `shared_buffers_percentage`.
     * 
     * * `requires_restart` - Whether changing the value of `shared_buffers_percentage` requires the DB to restart.
     * 
     * * `type` - The type of the value of `shared_buffers_percentage`.
     * 
     * ## work_mem
     * 
     * The following arguments are supported in the `work_mem` specification block:
     * 
     * * `description` - The description of `work_mem`.
     * 
     * * `example` - An example of a valid value for `work_mem`.
     * 
     * * `maximum` - The maximum valid value for `work_mem`.
     * 
     * * `minimum` - The minimum valid value for `work_mem`.
     * 
     * * `requires_restart` - Whether changing the value of `work_mem` requires the DB to restart.
     * 
     * * `type` - The type of the value of `work_mem`.
     * 
     * ## pg
     * 
     * The following arguments are supported in the `pg` specification block:
     * 
     * * `autovacuum_analyze_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_analyze_threshold` - (Optional) Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
     * 
     * * `autovacuum_max_workers` - (Optional) Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
     * 
     * * `autovacuum_naptime` - (Optional) Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
     * 
     * * `autovacuum_vacuum_cost_delay` - (Optional) Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
     * 
     * * `autovacuum_vacuum_cost_limit` - (Optional) Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
     * 
     * * `autovacuum_vacuum_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_vacuum_threshold` - (Optional) Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
     * 
     * * `bgwriter_delay` - (Optional) Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
     * 
     * * `bgwriter_flush_after` - (Optional) Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
     * 
     * * `bgwriter_lru_maxpages` - (Optional) In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
     * 
     * * `bgwriter_lru_multiplier` - (Optional) The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
     * 
     * * `deadlock_timeout` - (Optional) This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
     * 
     * * `default_toast_compression` - (Optional) Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
     * 
     * * `idle_in_transaction_session_timeout` - (Optional) Time out sessions with open transactions after this number of milliseconds.
     * 
     * * `jit` - (Optional) Controls system-wide use of Just-in-Time Compilation (JIT).
     * 
     * * `max_files_per_process` - (Optional) PostgreSQL maximum number of files that can be open per process.
     * 
     * * `max_locks_per_transaction` - (Optional) PostgreSQL maximum locks per transaction.
     * 
     * * `max_logical_replication_workers` - (Optional) PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
     * 
     * * `max_parallel_workers` - (Optional) Sets the maximum number of workers that the system can support for parallel queries.
     * 
     * * `max_parallel_workers_per_gather` - (Optional) Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
     * 
     * * `max_pred_locks_per_transaction` - (Optional) PostgreSQL maximum predicate locks per transaction.
     * 
     * * `max_replication_slots` - (Optional) PostgreSQL maximum replication slots.
     * 
     * * `max_slot_wal_keep_size` - (Optional) PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
     * 
     * * `max_stack_depth` - (Optional) Maximum depth of the stack in bytes.
     * 
     * * `max_standby_archive_delay` - (Optional) Max standby archive delay in milliseconds.
     * 
     * * `max_standby_streaming_delay` - (Optional) Max standby streaming delay in milliseconds.
     * 
     * * `max_wal_senders` - (Optional) PostgreSQL maximum WAL senders.
     * 
     * * `max_worker_processes` - (Optional) Sets the maximum number of background processes that the system can support.
     * 
     * * `password_encryption` - (Optional) Chooses the algorithm for encrypting passwords.
     * 
     * * `pg_partman_bgw.interval` - (Optional) Sets the time interval to run pg_partman&#39;s scheduled tasks.
     * 
     * * `pg_partman_bgw.role` - (Optional) Controls which role to use for pg_partman&#39;s scheduled background tasks.
     * 
     * * `pg_stat_monitor.pgsm_enable_query_plan` - (Optional) Enables or disables query plan monitoring.
     * 
     * * `pg_stat_monitor.pgsm_max_buckets` - (Optional) Sets the maximum number of buckets.
     * 
     * * `pg_stat_statements.track` - (Optional) Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
     * 
     * * `temp_file_limit` - (Optional) PostgreSQL temporary file limit in KiB, -1 for unlimited.
     * 
     * * `timezone` - (Optional) PostgreSQL service timezone.
     * 
     * * `track_activity_query_size` - (Optional) Specifies the number of bytes reserved to track the currently executing command for each active session.
     * 
     * * `track_commit_timestamp` - (Optional) Record commit time of transactions.
     * 
     * * `track_functions` - (Optional) Enables tracking of function call counts and time used.
     * 
     * * `track_io_timing` - (Optional) Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
     * 
     * * `wal_sender_timeout` - (Optional) Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
     * 
     * * `wal_writer_delay` - (Optional) WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
     * 
     * ## autovacuum_analyze_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_analyze_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_scale_factor`.
     * 
     * ## autovacuum_analyze_threshold
     * 
     * The following arguments are supported in the `autovacuum_analyze_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_threshold`.
     * 
     * ## autovacuum_max_workers
     * 
     * The following arguments are supported in the `autovacuum_max_workers` specification block:
     * 
     * * `description` - The description of `autovacuum_max_workers`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_max_workers`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_max_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_max_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_max_workers`.
     * 
     * ## autovacuum_naptime
     * 
     * The following arguments are supported in the `autovacuum_naptime` specification block:
     * 
     * * `description` - The description of `autovacuum_naptime`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_naptime`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_naptime`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_naptime` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_naptime`.
     * 
     * ## autovacuum_vacuum_cost_delay
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_delay` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_delay`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_delay`.
     * 
     * ## autovacuum_vacuum_cost_limit
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_limit` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_limit`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_limit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_limit`.
     * 
     * ## autovacuum_vacuum_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_vacuum_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_scale_factor`.
     * 
     * ## autovacuum_vacuum_threshold
     * 
     * The following arguments are supported in the `autovacuum_vacuum_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_threshold`.
     * 
     * ## bgwriter_delay
     * 
     * The following arguments are supported in the `bgwriter_delay` specification block:
     * 
     * * `description` - The description of `bgwriter_delay`.
     * 
     * * `example` - An example of a valid value for `bgwriter_delay`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_delay`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_delay`.
     * 
     * ## bgwriter_flush_after
     * 
     * The following arguments are supported in the `bgwriter_flush_after` specification block:
     * 
     * * `description` - The description of `bgwriter_flush_after`.
     * 
     * * `example` - An example of a valid value for `bgwriter_flush_after`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_flush_after`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_flush_after`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_flush_after` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_flush_after`.
     * 
     * ## bgwriter_lru_maxpages
     * 
     * The following arguments are supported in the `bgwriter_lru_maxpages` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_maxpages`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_maxpages`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_maxpages` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_maxpages`.
     * 
     * ## bgwriter_lru_multiplier
     * 
     * The following arguments are supported in the `bgwriter_lru_multiplier` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_multiplier`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_multiplier`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_multiplier` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_multiplier`.
     * 
     * ## deadlock_timeout
     * 
     * The following arguments are supported in the `deadlock_timeout` specification block:
     * 
     * * `description` - The description of `deadlock_timeout`.
     * 
     * * `example` - An example of a valid value for `deadlock_timeout`.
     * 
     * * `maximum` - The maximum valid value for `deadlock_timeout`.
     * 
     * * `minimum` - The minimum valid value for `deadlock_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `deadlock_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `deadlock_timeout`.
     * 
     * ## default_toast_compression
     * 
     * The following arguments are supported in the `default_toast_compression` specification block:
     * 
     * * `description` - The description of `default_toast_compression`.
     * 
     * * `enum` - A list of valid compression methods for `default_toast_compression`.
     * 
     * * `example` - An example of a valid value for `default_toast_compression`.
     * 
     * * `requires_restart` - Whether changing the value of `default_toast_compression` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_toast_compression`.
     * 
     * ## idle_in_transaction_session_timeout
     * 
     * The following arguments are supported in the `idle_in_transaction_session_timeout` specification block:
     * 
     * * `description` - The description of `idle_in_transaction_session_timeout`.
     * 
     * * `maximum` - The maximum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `minimum` - The minimum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `idle_in_transaction_session_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `idle_in_transaction_session_timeout`.
     * 
     * ## jit
     * 
     * The following arguments are supported in the `jit` specification block:
     * 
     * * `description` - The description of `jit`.
     * 
     * * `example` - An example of a valid value for `jit`.
     * 
     * * `requires_restart` - Whether changing the value of `jit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `jit`.
     * 
     * ## max_files_per_process
     * 
     * The following arguments are supported in the `max_files_per_process` specification block:
     * 
     * * `description` - The description of `max_files_per_process`.
     * 
     * * `maximum` - The maximum valid value for `max_files_per_process`.
     * 
     * * `minimum` - The minimum valid value for `max_files_per_process`.
     * 
     * * `requires_restart` - Whether changing the value of `max_files_per_process` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_files_per_process`.
     * 
     * ## max_locks_per_transaction
     * 
     * The following arguments are supported in the `max_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_locks_per_transaction`.
     * 
     * ## max_logical_replication_workers
     * 
     * The following arguments are supported in the `max_logical_replication_workers` specification block:
     * 
     * * `description` - The description of `max_logical_replication_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_logical_replication_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_logical_replication_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_logical_replication_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_logical_replication_workers`.
     * 
     * ## max_parallel_workers
     * 
     * The following arguments are supported in the `max_parallel_workers` specification block:
     * 
     * * `description` - The description of `max_parallel_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers`.
     * 
     * ## max_parallel_workers_per_gather
     * 
     * The following arguments are supported in the `max_parallel_workers_per_gather` specification block:
     * 
     * * `description` - The description of `max_parallel_workers_per_gather`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers_per_gather` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers_per_gather`.
     * 
     * ## max_pred_locks_per_transaction
     * 
     * The following arguments are supported in the `max_pred_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_pred_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_pred_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_pred_locks_per_transaction`.
     * 
     * ## max_replication_slots
     * 
     * The following arguments are supported in the `max_replication_slots` specification block:
     * 
     * * `description` - The description of `max_replication_slots`.
     * 
     * * `maximum` - The maximum valid value for `max_replication_slots`.
     * 
     * * `minimum` - The minimum valid value for `max_replication_slots`.
     * 
     * * `requires_restart` - Whether changing the value of `max_replication_slots` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_replication_slots`.
     * 
     * ## max_slot_wal_keep_size
     * 
     * The following arguments are supported in the `max_slot_wal_keep_size` specification block:
     * 
     * * `description` - The description of `max_slot_wal_keep_size`.
     * 
     * * `maximum` - The maximum valid value for `max_slot_wal_keep_size`.
     * 
     * * `minimum` - The minimum valid value for `max_slot_wal_keep_size`.
     * 
     * * `requires_restart` - Whether changing the value of `max_slot_wal_keep_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_slot_wal_keep_size`.
     * 
     * ## max_stack_depth
     * 
     * The following arguments are supported in the `max_stack_depth` specification block:
     * 
     * * `description` - The description of `max_stack_depth`.
     * 
     * * `maximum` - The maximum valid value for `max_stack_depth`.
     * 
     * * `minimum` - The minimum valid value for `max_stack_depth`.
     * 
     * * `requires_restart` - Whether changing the value of `max_stack_depth` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_stack_depth`.
     * 
     * ## max_standby_archive_delay
     * 
     * The following arguments are supported in the `max_standby_archive_delay` specification block:
     * 
     * * `description` - The description of `max_standby_archive_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_archive_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_archive_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_archive_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_archive_delay`.
     * 
     * ## max_standby_streaming_delay
     * 
     * The following arguments are supported in the `max_standby_streaming_delay` specification block:
     * 
     * * `description` - The description of `max_standby_streaming_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_streaming_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_streaming_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_streaming_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_streaming_delay`.
     * 
     * ## max_wal_senders
     * 
     * The following arguments are supported in the `max_wal_senders` specification block:
     * 
     * * `description` - The description of `max_wal_senders`.
     * 
     * * `maximum` - The maximum valid value for `max_wal_senders`.
     * 
     * * `minimum` - The minimum valid value for `max_wal_senders`.
     * 
     * * `requires_restart` - Whether changing the value of `max_wal_senders` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_wal_senders`.
     * 
     * ## max_worker_processes
     * 
     * The following arguments are supported in the `max_worker_processes` specification block:
     * 
     * * `description` - The description of `max_worker_processes`.
     * 
     * * `maximum` - The maximum valid value for `max_worker_processes`.
     * 
     * * `minimum` - The minimum valid value for `max_worker_processes`.
     * 
     * * `requires_restart` - Whether changing the value of `max_worker_processes` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_worker_processes`.
     * 
     * ## password_encryption
     * 
     * The following arguments are supported in the `password_encryption` specification block:
     * 
     * * `description` - The description of the `password_encryption` setting.
     * 
     * * `enum` - A list of valid values for the `password_encryption` setting.
     * 
     * * `example` - An example value for the `password_encryption` setting.
     * 
     * * `requires_restart` - Whether changing the value of `password_encryption` requires the DB to restart.
     * 
     * * `type` - A list of types for the `password_encryption` setting.
     * 
     * ## pg_partman_bgw_interval
     * 
     * The following arguments are supported in the `pg_partman_bgw_interval` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_interval` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_interval` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_interval` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_interval` setting.
     * 
     * ## pg_partman_bgw_role
     * 
     * The following arguments are supported in the `pg_partman_bgw_role` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_role` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_role` setting.
     * 
     * * `maxLength` - The maximum length for the `pg_partman_bgw_role` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `pg_partman_bgw_role` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_role` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_role` setting.
     * 
     * ## pg_stat_monitor_pgsm_enable_query_plan
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_enable_query_plan` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_enable_query_plan` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * ## pg_stat_monitor_pgsm_max_buckets
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_max_buckets` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_max_buckets` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * ## pg_stat_statements_track
     * 
     * The following arguments are supported in the `pg_stat_statements_track` specification block:
     * 
     * * `description` - The description of the `pg_stat_statements_track` setting.
     * 
     * * `enum` - A list of valid values for the `pg_stat_statements_track` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_statements_track` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_statements_track` setting.
     * 
     * ## temp_file_limit
     * 
     * The following arguments are supported in the `temp_file_limit` specification block:
     * 
     * * `description` - The description of the `temp_file_limit` setting.
     * 
     * * `example` - An example value for the `temp_file_limit` setting.
     * 
     * * `maximum` - The maximum allowed value for the `temp_file_limit` setting.
     * 
     * * `minimum` - The minimum allowed value for the `temp_file_limit` setting.
     * 
     * * `requires_restart` - Whether changing the value of `temp_file_limit` requires the DB to restart.
     * 
     * * `type` - The type of the `temp_file_limit` setting.
     * 
     * ## timezone
     * 
     * The following arguments are supported in the `timezone` specification block:
     * 
     * * `description` - The description of the `timezone` setting.
     * 
     * * `example` - An example value for the `timezone` setting.
     * 
     * * `maxLength` - The maximum length for the `timezone` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `timezone` setting.
     * 
     * * `requires_restart` - Whether changing the value of `timezone` requires the DB to restart.
     * 
     * * `type` - The type of the `timezone` setting.
     * 
     * ## track_activity_query_size
     * 
     * The following arguments are supported in the `track_activity_query_size` specification block:
     * 
     * * `description` - The description of the `track_activity_query_size` setting.
     * 
     * * `example` - An example value for the `track_activity_query_size` setting.
     * 
     * * `maximum` - The maximum allowed value for the `track_activity_query_size` setting.
     * 
     * * `minimum` - The minimum allowed value for the `track_activity_query_size` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_activity_query_size` requires the DB to restart.
     * 
     * * `type` - The type of the `track_activity_query_size` setting.
     * 
     * ## track_commit_timestamp
     * 
     * The following arguments are supported in the `track_commit_timestamp` specification block:
     * 
     * * `description` - The description of the `track_commit_timestamp` setting.
     * 
     * * `enum` - A list of valid values for the `track_commit_timestamp` setting.
     * 
     * * `example` - An example value for the `track_commit_timestamp` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_commit_timestamp` requires the DB to restart.
     * 
     * * `type` - The type of the `track_commit_timestamp` setting.
     * 
     * ## track_functions
     * 
     * The following arguments are supported in the `track_functions` specification block:
     * 
     * * `description` - The description of the `track_functions` setting.
     * 
     * * `enum` - A list of valid values for the `track_functions` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_functions` requires the DB to restart.
     * 
     * * `type` - The type of the `track_functions` setting.
     * 
     * ## track_io_timing
     * 
     * The following arguments are supported in the `track_io_timing` specification block:
     * 
     * * `description` - The description of the `track_io_timing` setting.
     * 
     * * `enum` - A list of valid values for the `track_io_timing` setting.
     * 
     * * `example` - An example value for the `track_io_timing` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_io_timing` requires the DB to restart.
     * 
     * * `type` - The type of the `track_io_timing` setting.
     * 
     * ## wal_sender_timeout
     * 
     * The following arguments are supported in the `wal_sender_timeout` specification block:
     * 
     * * `description` - The description of the `wal_sender_timeout` setting.
     * 
     * * `example` - An example value for the `wal_sender_timeout` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_sender_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_sender_timeout` setting.
     * 
     * ## wal_writer_delay
     * 
     * The following arguments are supported in the `wal_writer_delay` specification block:
     * 
     * * `description` - The description of the `wal_writer_delay` setting.
     * 
     * * `example` - An example value for the `wal_writer_delay` setting.
     * 
     * * `maximum` - The maximum allowed value for the `wal_writer_delay` setting.
     * 
     * * `minimum` - The minimum allowed value for the `wal_writer_delay` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_writer_delay` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_writer_delay` setting.
     * 
     */
    public static Output<GetDatabasePostgresqlConfigResult> getDatabasePostgresqlConfig(InvokeArgs args) {
        return getDatabasePostgresqlConfig(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode PostgreSQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabasePostgresqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pg_stat_monitor_enable
     * 
     * The following arguments are supported in the `pg_stat_monitor_enable` specification block:
     * 
     * * `description` - The description of `pg_stat_monitor_enable`.
     * 
     * * `requires_restart` - Whether changing the value `pg_stat_monitor_enable` requires the DB to restart.
     * 
     * * `type` - The type of the value of `pg_stat_monitor_enable`.
     * 
     * ## pglookout
     * 
     * The following arguments are supported in the `pglookout` specification block:
     * 
     * * `max_failover_replication_time_lag` - The maximum failover replication time lag for `pglookout`.
     * 
     * ## max_failover_replication_time_lag
     * 
     * The following arguments are supported in the `max_failover_replication_time_lag` specification block:
     * 
     * * `description` - The description of `max_failover_replication_time_lag`.
     * 
     * * `maximum` - The maximum valid value for `max_failover_replication_time_lag`.
     * 
     * * `minimum` - The minimum valid value for `max_failover_replication_time_lag`.
     * 
     * * `requires_restart` - Whether changing the value of `max_failover_replication_time_lag` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_failover_replication_time_lag`.
     * 
     * ## shared_buffers_percentage
     * 
     * The following arguments are supported in the `shared_buffers_percentage` specification block:
     * 
     * * `description` - The description of `shared_buffers_percentage`.
     * 
     * * `example` - An example of a valid value for `shared_buffers_percentage`.
     * 
     * * `maximum` - The maximum valid value for `shared_buffers_percentage`.
     * 
     * * `minimum` - The minimum valid value for `shared_buffers_percentage`.
     * 
     * * `requires_restart` - Whether changing the value of `shared_buffers_percentage` requires the DB to restart.
     * 
     * * `type` - The type of the value of `shared_buffers_percentage`.
     * 
     * ## work_mem
     * 
     * The following arguments are supported in the `work_mem` specification block:
     * 
     * * `description` - The description of `work_mem`.
     * 
     * * `example` - An example of a valid value for `work_mem`.
     * 
     * * `maximum` - The maximum valid value for `work_mem`.
     * 
     * * `minimum` - The minimum valid value for `work_mem`.
     * 
     * * `requires_restart` - Whether changing the value of `work_mem` requires the DB to restart.
     * 
     * * `type` - The type of the value of `work_mem`.
     * 
     * ## pg
     * 
     * The following arguments are supported in the `pg` specification block:
     * 
     * * `autovacuum_analyze_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_analyze_threshold` - (Optional) Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
     * 
     * * `autovacuum_max_workers` - (Optional) Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
     * 
     * * `autovacuum_naptime` - (Optional) Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
     * 
     * * `autovacuum_vacuum_cost_delay` - (Optional) Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
     * 
     * * `autovacuum_vacuum_cost_limit` - (Optional) Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
     * 
     * * `autovacuum_vacuum_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_vacuum_threshold` - (Optional) Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
     * 
     * * `bgwriter_delay` - (Optional) Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
     * 
     * * `bgwriter_flush_after` - (Optional) Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
     * 
     * * `bgwriter_lru_maxpages` - (Optional) In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
     * 
     * * `bgwriter_lru_multiplier` - (Optional) The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
     * 
     * * `deadlock_timeout` - (Optional) This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
     * 
     * * `default_toast_compression` - (Optional) Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
     * 
     * * `idle_in_transaction_session_timeout` - (Optional) Time out sessions with open transactions after this number of milliseconds.
     * 
     * * `jit` - (Optional) Controls system-wide use of Just-in-Time Compilation (JIT).
     * 
     * * `max_files_per_process` - (Optional) PostgreSQL maximum number of files that can be open per process.
     * 
     * * `max_locks_per_transaction` - (Optional) PostgreSQL maximum locks per transaction.
     * 
     * * `max_logical_replication_workers` - (Optional) PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
     * 
     * * `max_parallel_workers` - (Optional) Sets the maximum number of workers that the system can support for parallel queries.
     * 
     * * `max_parallel_workers_per_gather` - (Optional) Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
     * 
     * * `max_pred_locks_per_transaction` - (Optional) PostgreSQL maximum predicate locks per transaction.
     * 
     * * `max_replication_slots` - (Optional) PostgreSQL maximum replication slots.
     * 
     * * `max_slot_wal_keep_size` - (Optional) PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
     * 
     * * `max_stack_depth` - (Optional) Maximum depth of the stack in bytes.
     * 
     * * `max_standby_archive_delay` - (Optional) Max standby archive delay in milliseconds.
     * 
     * * `max_standby_streaming_delay` - (Optional) Max standby streaming delay in milliseconds.
     * 
     * * `max_wal_senders` - (Optional) PostgreSQL maximum WAL senders.
     * 
     * * `max_worker_processes` - (Optional) Sets the maximum number of background processes that the system can support.
     * 
     * * `password_encryption` - (Optional) Chooses the algorithm for encrypting passwords.
     * 
     * * `pg_partman_bgw.interval` - (Optional) Sets the time interval to run pg_partman&#39;s scheduled tasks.
     * 
     * * `pg_partman_bgw.role` - (Optional) Controls which role to use for pg_partman&#39;s scheduled background tasks.
     * 
     * * `pg_stat_monitor.pgsm_enable_query_plan` - (Optional) Enables or disables query plan monitoring.
     * 
     * * `pg_stat_monitor.pgsm_max_buckets` - (Optional) Sets the maximum number of buckets.
     * 
     * * `pg_stat_statements.track` - (Optional) Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
     * 
     * * `temp_file_limit` - (Optional) PostgreSQL temporary file limit in KiB, -1 for unlimited.
     * 
     * * `timezone` - (Optional) PostgreSQL service timezone.
     * 
     * * `track_activity_query_size` - (Optional) Specifies the number of bytes reserved to track the currently executing command for each active session.
     * 
     * * `track_commit_timestamp` - (Optional) Record commit time of transactions.
     * 
     * * `track_functions` - (Optional) Enables tracking of function call counts and time used.
     * 
     * * `track_io_timing` - (Optional) Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
     * 
     * * `wal_sender_timeout` - (Optional) Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
     * 
     * * `wal_writer_delay` - (Optional) WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
     * 
     * ## autovacuum_analyze_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_analyze_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_scale_factor`.
     * 
     * ## autovacuum_analyze_threshold
     * 
     * The following arguments are supported in the `autovacuum_analyze_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_threshold`.
     * 
     * ## autovacuum_max_workers
     * 
     * The following arguments are supported in the `autovacuum_max_workers` specification block:
     * 
     * * `description` - The description of `autovacuum_max_workers`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_max_workers`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_max_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_max_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_max_workers`.
     * 
     * ## autovacuum_naptime
     * 
     * The following arguments are supported in the `autovacuum_naptime` specification block:
     * 
     * * `description` - The description of `autovacuum_naptime`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_naptime`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_naptime`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_naptime` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_naptime`.
     * 
     * ## autovacuum_vacuum_cost_delay
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_delay` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_delay`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_delay`.
     * 
     * ## autovacuum_vacuum_cost_limit
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_limit` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_limit`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_limit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_limit`.
     * 
     * ## autovacuum_vacuum_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_vacuum_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_scale_factor`.
     * 
     * ## autovacuum_vacuum_threshold
     * 
     * The following arguments are supported in the `autovacuum_vacuum_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_threshold`.
     * 
     * ## bgwriter_delay
     * 
     * The following arguments are supported in the `bgwriter_delay` specification block:
     * 
     * * `description` - The description of `bgwriter_delay`.
     * 
     * * `example` - An example of a valid value for `bgwriter_delay`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_delay`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_delay`.
     * 
     * ## bgwriter_flush_after
     * 
     * The following arguments are supported in the `bgwriter_flush_after` specification block:
     * 
     * * `description` - The description of `bgwriter_flush_after`.
     * 
     * * `example` - An example of a valid value for `bgwriter_flush_after`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_flush_after`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_flush_after`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_flush_after` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_flush_after`.
     * 
     * ## bgwriter_lru_maxpages
     * 
     * The following arguments are supported in the `bgwriter_lru_maxpages` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_maxpages`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_maxpages`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_maxpages` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_maxpages`.
     * 
     * ## bgwriter_lru_multiplier
     * 
     * The following arguments are supported in the `bgwriter_lru_multiplier` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_multiplier`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_multiplier`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_multiplier` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_multiplier`.
     * 
     * ## deadlock_timeout
     * 
     * The following arguments are supported in the `deadlock_timeout` specification block:
     * 
     * * `description` - The description of `deadlock_timeout`.
     * 
     * * `example` - An example of a valid value for `deadlock_timeout`.
     * 
     * * `maximum` - The maximum valid value for `deadlock_timeout`.
     * 
     * * `minimum` - The minimum valid value for `deadlock_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `deadlock_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `deadlock_timeout`.
     * 
     * ## default_toast_compression
     * 
     * The following arguments are supported in the `default_toast_compression` specification block:
     * 
     * * `description` - The description of `default_toast_compression`.
     * 
     * * `enum` - A list of valid compression methods for `default_toast_compression`.
     * 
     * * `example` - An example of a valid value for `default_toast_compression`.
     * 
     * * `requires_restart` - Whether changing the value of `default_toast_compression` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_toast_compression`.
     * 
     * ## idle_in_transaction_session_timeout
     * 
     * The following arguments are supported in the `idle_in_transaction_session_timeout` specification block:
     * 
     * * `description` - The description of `idle_in_transaction_session_timeout`.
     * 
     * * `maximum` - The maximum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `minimum` - The minimum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `idle_in_transaction_session_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `idle_in_transaction_session_timeout`.
     * 
     * ## jit
     * 
     * The following arguments are supported in the `jit` specification block:
     * 
     * * `description` - The description of `jit`.
     * 
     * * `example` - An example of a valid value for `jit`.
     * 
     * * `requires_restart` - Whether changing the value of `jit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `jit`.
     * 
     * ## max_files_per_process
     * 
     * The following arguments are supported in the `max_files_per_process` specification block:
     * 
     * * `description` - The description of `max_files_per_process`.
     * 
     * * `maximum` - The maximum valid value for `max_files_per_process`.
     * 
     * * `minimum` - The minimum valid value for `max_files_per_process`.
     * 
     * * `requires_restart` - Whether changing the value of `max_files_per_process` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_files_per_process`.
     * 
     * ## max_locks_per_transaction
     * 
     * The following arguments are supported in the `max_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_locks_per_transaction`.
     * 
     * ## max_logical_replication_workers
     * 
     * The following arguments are supported in the `max_logical_replication_workers` specification block:
     * 
     * * `description` - The description of `max_logical_replication_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_logical_replication_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_logical_replication_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_logical_replication_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_logical_replication_workers`.
     * 
     * ## max_parallel_workers
     * 
     * The following arguments are supported in the `max_parallel_workers` specification block:
     * 
     * * `description` - The description of `max_parallel_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers`.
     * 
     * ## max_parallel_workers_per_gather
     * 
     * The following arguments are supported in the `max_parallel_workers_per_gather` specification block:
     * 
     * * `description` - The description of `max_parallel_workers_per_gather`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers_per_gather` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers_per_gather`.
     * 
     * ## max_pred_locks_per_transaction
     * 
     * The following arguments are supported in the `max_pred_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_pred_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_pred_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_pred_locks_per_transaction`.
     * 
     * ## max_replication_slots
     * 
     * The following arguments are supported in the `max_replication_slots` specification block:
     * 
     * * `description` - The description of `max_replication_slots`.
     * 
     * * `maximum` - The maximum valid value for `max_replication_slots`.
     * 
     * * `minimum` - The minimum valid value for `max_replication_slots`.
     * 
     * * `requires_restart` - Whether changing the value of `max_replication_slots` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_replication_slots`.
     * 
     * ## max_slot_wal_keep_size
     * 
     * The following arguments are supported in the `max_slot_wal_keep_size` specification block:
     * 
     * * `description` - The description of `max_slot_wal_keep_size`.
     * 
     * * `maximum` - The maximum valid value for `max_slot_wal_keep_size`.
     * 
     * * `minimum` - The minimum valid value for `max_slot_wal_keep_size`.
     * 
     * * `requires_restart` - Whether changing the value of `max_slot_wal_keep_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_slot_wal_keep_size`.
     * 
     * ## max_stack_depth
     * 
     * The following arguments are supported in the `max_stack_depth` specification block:
     * 
     * * `description` - The description of `max_stack_depth`.
     * 
     * * `maximum` - The maximum valid value for `max_stack_depth`.
     * 
     * * `minimum` - The minimum valid value for `max_stack_depth`.
     * 
     * * `requires_restart` - Whether changing the value of `max_stack_depth` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_stack_depth`.
     * 
     * ## max_standby_archive_delay
     * 
     * The following arguments are supported in the `max_standby_archive_delay` specification block:
     * 
     * * `description` - The description of `max_standby_archive_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_archive_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_archive_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_archive_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_archive_delay`.
     * 
     * ## max_standby_streaming_delay
     * 
     * The following arguments are supported in the `max_standby_streaming_delay` specification block:
     * 
     * * `description` - The description of `max_standby_streaming_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_streaming_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_streaming_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_streaming_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_streaming_delay`.
     * 
     * ## max_wal_senders
     * 
     * The following arguments are supported in the `max_wal_senders` specification block:
     * 
     * * `description` - The description of `max_wal_senders`.
     * 
     * * `maximum` - The maximum valid value for `max_wal_senders`.
     * 
     * * `minimum` - The minimum valid value for `max_wal_senders`.
     * 
     * * `requires_restart` - Whether changing the value of `max_wal_senders` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_wal_senders`.
     * 
     * ## max_worker_processes
     * 
     * The following arguments are supported in the `max_worker_processes` specification block:
     * 
     * * `description` - The description of `max_worker_processes`.
     * 
     * * `maximum` - The maximum valid value for `max_worker_processes`.
     * 
     * * `minimum` - The minimum valid value for `max_worker_processes`.
     * 
     * * `requires_restart` - Whether changing the value of `max_worker_processes` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_worker_processes`.
     * 
     * ## password_encryption
     * 
     * The following arguments are supported in the `password_encryption` specification block:
     * 
     * * `description` - The description of the `password_encryption` setting.
     * 
     * * `enum` - A list of valid values for the `password_encryption` setting.
     * 
     * * `example` - An example value for the `password_encryption` setting.
     * 
     * * `requires_restart` - Whether changing the value of `password_encryption` requires the DB to restart.
     * 
     * * `type` - A list of types for the `password_encryption` setting.
     * 
     * ## pg_partman_bgw_interval
     * 
     * The following arguments are supported in the `pg_partman_bgw_interval` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_interval` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_interval` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_interval` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_interval` setting.
     * 
     * ## pg_partman_bgw_role
     * 
     * The following arguments are supported in the `pg_partman_bgw_role` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_role` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_role` setting.
     * 
     * * `maxLength` - The maximum length for the `pg_partman_bgw_role` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `pg_partman_bgw_role` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_role` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_role` setting.
     * 
     * ## pg_stat_monitor_pgsm_enable_query_plan
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_enable_query_plan` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_enable_query_plan` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * ## pg_stat_monitor_pgsm_max_buckets
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_max_buckets` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_max_buckets` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * ## pg_stat_statements_track
     * 
     * The following arguments are supported in the `pg_stat_statements_track` specification block:
     * 
     * * `description` - The description of the `pg_stat_statements_track` setting.
     * 
     * * `enum` - A list of valid values for the `pg_stat_statements_track` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_statements_track` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_statements_track` setting.
     * 
     * ## temp_file_limit
     * 
     * The following arguments are supported in the `temp_file_limit` specification block:
     * 
     * * `description` - The description of the `temp_file_limit` setting.
     * 
     * * `example` - An example value for the `temp_file_limit` setting.
     * 
     * * `maximum` - The maximum allowed value for the `temp_file_limit` setting.
     * 
     * * `minimum` - The minimum allowed value for the `temp_file_limit` setting.
     * 
     * * `requires_restart` - Whether changing the value of `temp_file_limit` requires the DB to restart.
     * 
     * * `type` - The type of the `temp_file_limit` setting.
     * 
     * ## timezone
     * 
     * The following arguments are supported in the `timezone` specification block:
     * 
     * * `description` - The description of the `timezone` setting.
     * 
     * * `example` - An example value for the `timezone` setting.
     * 
     * * `maxLength` - The maximum length for the `timezone` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `timezone` setting.
     * 
     * * `requires_restart` - Whether changing the value of `timezone` requires the DB to restart.
     * 
     * * `type` - The type of the `timezone` setting.
     * 
     * ## track_activity_query_size
     * 
     * The following arguments are supported in the `track_activity_query_size` specification block:
     * 
     * * `description` - The description of the `track_activity_query_size` setting.
     * 
     * * `example` - An example value for the `track_activity_query_size` setting.
     * 
     * * `maximum` - The maximum allowed value for the `track_activity_query_size` setting.
     * 
     * * `minimum` - The minimum allowed value for the `track_activity_query_size` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_activity_query_size` requires the DB to restart.
     * 
     * * `type` - The type of the `track_activity_query_size` setting.
     * 
     * ## track_commit_timestamp
     * 
     * The following arguments are supported in the `track_commit_timestamp` specification block:
     * 
     * * `description` - The description of the `track_commit_timestamp` setting.
     * 
     * * `enum` - A list of valid values for the `track_commit_timestamp` setting.
     * 
     * * `example` - An example value for the `track_commit_timestamp` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_commit_timestamp` requires the DB to restart.
     * 
     * * `type` - The type of the `track_commit_timestamp` setting.
     * 
     * ## track_functions
     * 
     * The following arguments are supported in the `track_functions` specification block:
     * 
     * * `description` - The description of the `track_functions` setting.
     * 
     * * `enum` - A list of valid values for the `track_functions` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_functions` requires the DB to restart.
     * 
     * * `type` - The type of the `track_functions` setting.
     * 
     * ## track_io_timing
     * 
     * The following arguments are supported in the `track_io_timing` specification block:
     * 
     * * `description` - The description of the `track_io_timing` setting.
     * 
     * * `enum` - A list of valid values for the `track_io_timing` setting.
     * 
     * * `example` - An example value for the `track_io_timing` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_io_timing` requires the DB to restart.
     * 
     * * `type` - The type of the `track_io_timing` setting.
     * 
     * ## wal_sender_timeout
     * 
     * The following arguments are supported in the `wal_sender_timeout` specification block:
     * 
     * * `description` - The description of the `wal_sender_timeout` setting.
     * 
     * * `example` - An example value for the `wal_sender_timeout` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_sender_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_sender_timeout` setting.
     * 
     * ## wal_writer_delay
     * 
     * The following arguments are supported in the `wal_writer_delay` specification block:
     * 
     * * `description` - The description of the `wal_writer_delay` setting.
     * 
     * * `example` - An example value for the `wal_writer_delay` setting.
     * 
     * * `maximum` - The maximum allowed value for the `wal_writer_delay` setting.
     * 
     * * `minimum` - The minimum allowed value for the `wal_writer_delay` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_writer_delay` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_writer_delay` setting.
     * 
     */
    public static CompletableFuture<GetDatabasePostgresqlConfigResult> getDatabasePostgresqlConfigPlain(InvokeArgs args) {
        return getDatabasePostgresqlConfigPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode PostgreSQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabasePostgresqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pg_stat_monitor_enable
     * 
     * The following arguments are supported in the `pg_stat_monitor_enable` specification block:
     * 
     * * `description` - The description of `pg_stat_monitor_enable`.
     * 
     * * `requires_restart` - Whether changing the value `pg_stat_monitor_enable` requires the DB to restart.
     * 
     * * `type` - The type of the value of `pg_stat_monitor_enable`.
     * 
     * ## pglookout
     * 
     * The following arguments are supported in the `pglookout` specification block:
     * 
     * * `max_failover_replication_time_lag` - The maximum failover replication time lag for `pglookout`.
     * 
     * ## max_failover_replication_time_lag
     * 
     * The following arguments are supported in the `max_failover_replication_time_lag` specification block:
     * 
     * * `description` - The description of `max_failover_replication_time_lag`.
     * 
     * * `maximum` - The maximum valid value for `max_failover_replication_time_lag`.
     * 
     * * `minimum` - The minimum valid value for `max_failover_replication_time_lag`.
     * 
     * * `requires_restart` - Whether changing the value of `max_failover_replication_time_lag` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_failover_replication_time_lag`.
     * 
     * ## shared_buffers_percentage
     * 
     * The following arguments are supported in the `shared_buffers_percentage` specification block:
     * 
     * * `description` - The description of `shared_buffers_percentage`.
     * 
     * * `example` - An example of a valid value for `shared_buffers_percentage`.
     * 
     * * `maximum` - The maximum valid value for `shared_buffers_percentage`.
     * 
     * * `minimum` - The minimum valid value for `shared_buffers_percentage`.
     * 
     * * `requires_restart` - Whether changing the value of `shared_buffers_percentage` requires the DB to restart.
     * 
     * * `type` - The type of the value of `shared_buffers_percentage`.
     * 
     * ## work_mem
     * 
     * The following arguments are supported in the `work_mem` specification block:
     * 
     * * `description` - The description of `work_mem`.
     * 
     * * `example` - An example of a valid value for `work_mem`.
     * 
     * * `maximum` - The maximum valid value for `work_mem`.
     * 
     * * `minimum` - The minimum valid value for `work_mem`.
     * 
     * * `requires_restart` - Whether changing the value of `work_mem` requires the DB to restart.
     * 
     * * `type` - The type of the value of `work_mem`.
     * 
     * ## pg
     * 
     * The following arguments are supported in the `pg` specification block:
     * 
     * * `autovacuum_analyze_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_analyze_threshold` - (Optional) Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
     * 
     * * `autovacuum_max_workers` - (Optional) Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
     * 
     * * `autovacuum_naptime` - (Optional) Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
     * 
     * * `autovacuum_vacuum_cost_delay` - (Optional) Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
     * 
     * * `autovacuum_vacuum_cost_limit` - (Optional) Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
     * 
     * * `autovacuum_vacuum_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_vacuum_threshold` - (Optional) Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
     * 
     * * `bgwriter_delay` - (Optional) Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
     * 
     * * `bgwriter_flush_after` - (Optional) Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
     * 
     * * `bgwriter_lru_maxpages` - (Optional) In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
     * 
     * * `bgwriter_lru_multiplier` - (Optional) The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
     * 
     * * `deadlock_timeout` - (Optional) This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
     * 
     * * `default_toast_compression` - (Optional) Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
     * 
     * * `idle_in_transaction_session_timeout` - (Optional) Time out sessions with open transactions after this number of milliseconds.
     * 
     * * `jit` - (Optional) Controls system-wide use of Just-in-Time Compilation (JIT).
     * 
     * * `max_files_per_process` - (Optional) PostgreSQL maximum number of files that can be open per process.
     * 
     * * `max_locks_per_transaction` - (Optional) PostgreSQL maximum locks per transaction.
     * 
     * * `max_logical_replication_workers` - (Optional) PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
     * 
     * * `max_parallel_workers` - (Optional) Sets the maximum number of workers that the system can support for parallel queries.
     * 
     * * `max_parallel_workers_per_gather` - (Optional) Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
     * 
     * * `max_pred_locks_per_transaction` - (Optional) PostgreSQL maximum predicate locks per transaction.
     * 
     * * `max_replication_slots` - (Optional) PostgreSQL maximum replication slots.
     * 
     * * `max_slot_wal_keep_size` - (Optional) PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
     * 
     * * `max_stack_depth` - (Optional) Maximum depth of the stack in bytes.
     * 
     * * `max_standby_archive_delay` - (Optional) Max standby archive delay in milliseconds.
     * 
     * * `max_standby_streaming_delay` - (Optional) Max standby streaming delay in milliseconds.
     * 
     * * `max_wal_senders` - (Optional) PostgreSQL maximum WAL senders.
     * 
     * * `max_worker_processes` - (Optional) Sets the maximum number of background processes that the system can support.
     * 
     * * `password_encryption` - (Optional) Chooses the algorithm for encrypting passwords.
     * 
     * * `pg_partman_bgw.interval` - (Optional) Sets the time interval to run pg_partman&#39;s scheduled tasks.
     * 
     * * `pg_partman_bgw.role` - (Optional) Controls which role to use for pg_partman&#39;s scheduled background tasks.
     * 
     * * `pg_stat_monitor.pgsm_enable_query_plan` - (Optional) Enables or disables query plan monitoring.
     * 
     * * `pg_stat_monitor.pgsm_max_buckets` - (Optional) Sets the maximum number of buckets.
     * 
     * * `pg_stat_statements.track` - (Optional) Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
     * 
     * * `temp_file_limit` - (Optional) PostgreSQL temporary file limit in KiB, -1 for unlimited.
     * 
     * * `timezone` - (Optional) PostgreSQL service timezone.
     * 
     * * `track_activity_query_size` - (Optional) Specifies the number of bytes reserved to track the currently executing command for each active session.
     * 
     * * `track_commit_timestamp` - (Optional) Record commit time of transactions.
     * 
     * * `track_functions` - (Optional) Enables tracking of function call counts and time used.
     * 
     * * `track_io_timing` - (Optional) Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
     * 
     * * `wal_sender_timeout` - (Optional) Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
     * 
     * * `wal_writer_delay` - (Optional) WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
     * 
     * ## autovacuum_analyze_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_analyze_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_scale_factor`.
     * 
     * ## autovacuum_analyze_threshold
     * 
     * The following arguments are supported in the `autovacuum_analyze_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_threshold`.
     * 
     * ## autovacuum_max_workers
     * 
     * The following arguments are supported in the `autovacuum_max_workers` specification block:
     * 
     * * `description` - The description of `autovacuum_max_workers`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_max_workers`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_max_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_max_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_max_workers`.
     * 
     * ## autovacuum_naptime
     * 
     * The following arguments are supported in the `autovacuum_naptime` specification block:
     * 
     * * `description` - The description of `autovacuum_naptime`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_naptime`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_naptime`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_naptime` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_naptime`.
     * 
     * ## autovacuum_vacuum_cost_delay
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_delay` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_delay`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_delay`.
     * 
     * ## autovacuum_vacuum_cost_limit
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_limit` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_limit`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_limit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_limit`.
     * 
     * ## autovacuum_vacuum_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_vacuum_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_scale_factor`.
     * 
     * ## autovacuum_vacuum_threshold
     * 
     * The following arguments are supported in the `autovacuum_vacuum_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_threshold`.
     * 
     * ## bgwriter_delay
     * 
     * The following arguments are supported in the `bgwriter_delay` specification block:
     * 
     * * `description` - The description of `bgwriter_delay`.
     * 
     * * `example` - An example of a valid value for `bgwriter_delay`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_delay`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_delay`.
     * 
     * ## bgwriter_flush_after
     * 
     * The following arguments are supported in the `bgwriter_flush_after` specification block:
     * 
     * * `description` - The description of `bgwriter_flush_after`.
     * 
     * * `example` - An example of a valid value for `bgwriter_flush_after`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_flush_after`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_flush_after`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_flush_after` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_flush_after`.
     * 
     * ## bgwriter_lru_maxpages
     * 
     * The following arguments are supported in the `bgwriter_lru_maxpages` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_maxpages`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_maxpages`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_maxpages` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_maxpages`.
     * 
     * ## bgwriter_lru_multiplier
     * 
     * The following arguments are supported in the `bgwriter_lru_multiplier` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_multiplier`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_multiplier`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_multiplier` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_multiplier`.
     * 
     * ## deadlock_timeout
     * 
     * The following arguments are supported in the `deadlock_timeout` specification block:
     * 
     * * `description` - The description of `deadlock_timeout`.
     * 
     * * `example` - An example of a valid value for `deadlock_timeout`.
     * 
     * * `maximum` - The maximum valid value for `deadlock_timeout`.
     * 
     * * `minimum` - The minimum valid value for `deadlock_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `deadlock_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `deadlock_timeout`.
     * 
     * ## default_toast_compression
     * 
     * The following arguments are supported in the `default_toast_compression` specification block:
     * 
     * * `description` - The description of `default_toast_compression`.
     * 
     * * `enum` - A list of valid compression methods for `default_toast_compression`.
     * 
     * * `example` - An example of a valid value for `default_toast_compression`.
     * 
     * * `requires_restart` - Whether changing the value of `default_toast_compression` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_toast_compression`.
     * 
     * ## idle_in_transaction_session_timeout
     * 
     * The following arguments are supported in the `idle_in_transaction_session_timeout` specification block:
     * 
     * * `description` - The description of `idle_in_transaction_session_timeout`.
     * 
     * * `maximum` - The maximum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `minimum` - The minimum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `idle_in_transaction_session_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `idle_in_transaction_session_timeout`.
     * 
     * ## jit
     * 
     * The following arguments are supported in the `jit` specification block:
     * 
     * * `description` - The description of `jit`.
     * 
     * * `example` - An example of a valid value for `jit`.
     * 
     * * `requires_restart` - Whether changing the value of `jit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `jit`.
     * 
     * ## max_files_per_process
     * 
     * The following arguments are supported in the `max_files_per_process` specification block:
     * 
     * * `description` - The description of `max_files_per_process`.
     * 
     * * `maximum` - The maximum valid value for `max_files_per_process`.
     * 
     * * `minimum` - The minimum valid value for `max_files_per_process`.
     * 
     * * `requires_restart` - Whether changing the value of `max_files_per_process` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_files_per_process`.
     * 
     * ## max_locks_per_transaction
     * 
     * The following arguments are supported in the `max_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_locks_per_transaction`.
     * 
     * ## max_logical_replication_workers
     * 
     * The following arguments are supported in the `max_logical_replication_workers` specification block:
     * 
     * * `description` - The description of `max_logical_replication_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_logical_replication_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_logical_replication_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_logical_replication_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_logical_replication_workers`.
     * 
     * ## max_parallel_workers
     * 
     * The following arguments are supported in the `max_parallel_workers` specification block:
     * 
     * * `description` - The description of `max_parallel_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers`.
     * 
     * ## max_parallel_workers_per_gather
     * 
     * The following arguments are supported in the `max_parallel_workers_per_gather` specification block:
     * 
     * * `description` - The description of `max_parallel_workers_per_gather`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers_per_gather` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers_per_gather`.
     * 
     * ## max_pred_locks_per_transaction
     * 
     * The following arguments are supported in the `max_pred_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_pred_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_pred_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_pred_locks_per_transaction`.
     * 
     * ## max_replication_slots
     * 
     * The following arguments are supported in the `max_replication_slots` specification block:
     * 
     * * `description` - The description of `max_replication_slots`.
     * 
     * * `maximum` - The maximum valid value for `max_replication_slots`.
     * 
     * * `minimum` - The minimum valid value for `max_replication_slots`.
     * 
     * * `requires_restart` - Whether changing the value of `max_replication_slots` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_replication_slots`.
     * 
     * ## max_slot_wal_keep_size
     * 
     * The following arguments are supported in the `max_slot_wal_keep_size` specification block:
     * 
     * * `description` - The description of `max_slot_wal_keep_size`.
     * 
     * * `maximum` - The maximum valid value for `max_slot_wal_keep_size`.
     * 
     * * `minimum` - The minimum valid value for `max_slot_wal_keep_size`.
     * 
     * * `requires_restart` - Whether changing the value of `max_slot_wal_keep_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_slot_wal_keep_size`.
     * 
     * ## max_stack_depth
     * 
     * The following arguments are supported in the `max_stack_depth` specification block:
     * 
     * * `description` - The description of `max_stack_depth`.
     * 
     * * `maximum` - The maximum valid value for `max_stack_depth`.
     * 
     * * `minimum` - The minimum valid value for `max_stack_depth`.
     * 
     * * `requires_restart` - Whether changing the value of `max_stack_depth` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_stack_depth`.
     * 
     * ## max_standby_archive_delay
     * 
     * The following arguments are supported in the `max_standby_archive_delay` specification block:
     * 
     * * `description` - The description of `max_standby_archive_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_archive_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_archive_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_archive_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_archive_delay`.
     * 
     * ## max_standby_streaming_delay
     * 
     * The following arguments are supported in the `max_standby_streaming_delay` specification block:
     * 
     * * `description` - The description of `max_standby_streaming_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_streaming_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_streaming_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_streaming_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_streaming_delay`.
     * 
     * ## max_wal_senders
     * 
     * The following arguments are supported in the `max_wal_senders` specification block:
     * 
     * * `description` - The description of `max_wal_senders`.
     * 
     * * `maximum` - The maximum valid value for `max_wal_senders`.
     * 
     * * `minimum` - The minimum valid value for `max_wal_senders`.
     * 
     * * `requires_restart` - Whether changing the value of `max_wal_senders` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_wal_senders`.
     * 
     * ## max_worker_processes
     * 
     * The following arguments are supported in the `max_worker_processes` specification block:
     * 
     * * `description` - The description of `max_worker_processes`.
     * 
     * * `maximum` - The maximum valid value for `max_worker_processes`.
     * 
     * * `minimum` - The minimum valid value for `max_worker_processes`.
     * 
     * * `requires_restart` - Whether changing the value of `max_worker_processes` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_worker_processes`.
     * 
     * ## password_encryption
     * 
     * The following arguments are supported in the `password_encryption` specification block:
     * 
     * * `description` - The description of the `password_encryption` setting.
     * 
     * * `enum` - A list of valid values for the `password_encryption` setting.
     * 
     * * `example` - An example value for the `password_encryption` setting.
     * 
     * * `requires_restart` - Whether changing the value of `password_encryption` requires the DB to restart.
     * 
     * * `type` - A list of types for the `password_encryption` setting.
     * 
     * ## pg_partman_bgw_interval
     * 
     * The following arguments are supported in the `pg_partman_bgw_interval` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_interval` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_interval` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_interval` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_interval` setting.
     * 
     * ## pg_partman_bgw_role
     * 
     * The following arguments are supported in the `pg_partman_bgw_role` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_role` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_role` setting.
     * 
     * * `maxLength` - The maximum length for the `pg_partman_bgw_role` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `pg_partman_bgw_role` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_role` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_role` setting.
     * 
     * ## pg_stat_monitor_pgsm_enable_query_plan
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_enable_query_plan` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_enable_query_plan` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * ## pg_stat_monitor_pgsm_max_buckets
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_max_buckets` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_max_buckets` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * ## pg_stat_statements_track
     * 
     * The following arguments are supported in the `pg_stat_statements_track` specification block:
     * 
     * * `description` - The description of the `pg_stat_statements_track` setting.
     * 
     * * `enum` - A list of valid values for the `pg_stat_statements_track` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_statements_track` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_statements_track` setting.
     * 
     * ## temp_file_limit
     * 
     * The following arguments are supported in the `temp_file_limit` specification block:
     * 
     * * `description` - The description of the `temp_file_limit` setting.
     * 
     * * `example` - An example value for the `temp_file_limit` setting.
     * 
     * * `maximum` - The maximum allowed value for the `temp_file_limit` setting.
     * 
     * * `minimum` - The minimum allowed value for the `temp_file_limit` setting.
     * 
     * * `requires_restart` - Whether changing the value of `temp_file_limit` requires the DB to restart.
     * 
     * * `type` - The type of the `temp_file_limit` setting.
     * 
     * ## timezone
     * 
     * The following arguments are supported in the `timezone` specification block:
     * 
     * * `description` - The description of the `timezone` setting.
     * 
     * * `example` - An example value for the `timezone` setting.
     * 
     * * `maxLength` - The maximum length for the `timezone` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `timezone` setting.
     * 
     * * `requires_restart` - Whether changing the value of `timezone` requires the DB to restart.
     * 
     * * `type` - The type of the `timezone` setting.
     * 
     * ## track_activity_query_size
     * 
     * The following arguments are supported in the `track_activity_query_size` specification block:
     * 
     * * `description` - The description of the `track_activity_query_size` setting.
     * 
     * * `example` - An example value for the `track_activity_query_size` setting.
     * 
     * * `maximum` - The maximum allowed value for the `track_activity_query_size` setting.
     * 
     * * `minimum` - The minimum allowed value for the `track_activity_query_size` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_activity_query_size` requires the DB to restart.
     * 
     * * `type` - The type of the `track_activity_query_size` setting.
     * 
     * ## track_commit_timestamp
     * 
     * The following arguments are supported in the `track_commit_timestamp` specification block:
     * 
     * * `description` - The description of the `track_commit_timestamp` setting.
     * 
     * * `enum` - A list of valid values for the `track_commit_timestamp` setting.
     * 
     * * `example` - An example value for the `track_commit_timestamp` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_commit_timestamp` requires the DB to restart.
     * 
     * * `type` - The type of the `track_commit_timestamp` setting.
     * 
     * ## track_functions
     * 
     * The following arguments are supported in the `track_functions` specification block:
     * 
     * * `description` - The description of the `track_functions` setting.
     * 
     * * `enum` - A list of valid values for the `track_functions` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_functions` requires the DB to restart.
     * 
     * * `type` - The type of the `track_functions` setting.
     * 
     * ## track_io_timing
     * 
     * The following arguments are supported in the `track_io_timing` specification block:
     * 
     * * `description` - The description of the `track_io_timing` setting.
     * 
     * * `enum` - A list of valid values for the `track_io_timing` setting.
     * 
     * * `example` - An example value for the `track_io_timing` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_io_timing` requires the DB to restart.
     * 
     * * `type` - The type of the `track_io_timing` setting.
     * 
     * ## wal_sender_timeout
     * 
     * The following arguments are supported in the `wal_sender_timeout` specification block:
     * 
     * * `description` - The description of the `wal_sender_timeout` setting.
     * 
     * * `example` - An example value for the `wal_sender_timeout` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_sender_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_sender_timeout` setting.
     * 
     * ## wal_writer_delay
     * 
     * The following arguments are supported in the `wal_writer_delay` specification block:
     * 
     * * `description` - The description of the `wal_writer_delay` setting.
     * 
     * * `example` - An example value for the `wal_writer_delay` setting.
     * 
     * * `maximum` - The maximum allowed value for the `wal_writer_delay` setting.
     * 
     * * `minimum` - The minimum allowed value for the `wal_writer_delay` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_writer_delay` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_writer_delay` setting.
     * 
     */
    public static Output<GetDatabasePostgresqlConfigResult> getDatabasePostgresqlConfig(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabasePostgresqlConfig:getDatabasePostgresqlConfig", TypeShape.of(GetDatabasePostgresqlConfigResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode PostgreSQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabasePostgresqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pg_stat_monitor_enable
     * 
     * The following arguments are supported in the `pg_stat_monitor_enable` specification block:
     * 
     * * `description` - The description of `pg_stat_monitor_enable`.
     * 
     * * `requires_restart` - Whether changing the value `pg_stat_monitor_enable` requires the DB to restart.
     * 
     * * `type` - The type of the value of `pg_stat_monitor_enable`.
     * 
     * ## pglookout
     * 
     * The following arguments are supported in the `pglookout` specification block:
     * 
     * * `max_failover_replication_time_lag` - The maximum failover replication time lag for `pglookout`.
     * 
     * ## max_failover_replication_time_lag
     * 
     * The following arguments are supported in the `max_failover_replication_time_lag` specification block:
     * 
     * * `description` - The description of `max_failover_replication_time_lag`.
     * 
     * * `maximum` - The maximum valid value for `max_failover_replication_time_lag`.
     * 
     * * `minimum` - The minimum valid value for `max_failover_replication_time_lag`.
     * 
     * * `requires_restart` - Whether changing the value of `max_failover_replication_time_lag` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_failover_replication_time_lag`.
     * 
     * ## shared_buffers_percentage
     * 
     * The following arguments are supported in the `shared_buffers_percentage` specification block:
     * 
     * * `description` - The description of `shared_buffers_percentage`.
     * 
     * * `example` - An example of a valid value for `shared_buffers_percentage`.
     * 
     * * `maximum` - The maximum valid value for `shared_buffers_percentage`.
     * 
     * * `minimum` - The minimum valid value for `shared_buffers_percentage`.
     * 
     * * `requires_restart` - Whether changing the value of `shared_buffers_percentage` requires the DB to restart.
     * 
     * * `type` - The type of the value of `shared_buffers_percentage`.
     * 
     * ## work_mem
     * 
     * The following arguments are supported in the `work_mem` specification block:
     * 
     * * `description` - The description of `work_mem`.
     * 
     * * `example` - An example of a valid value for `work_mem`.
     * 
     * * `maximum` - The maximum valid value for `work_mem`.
     * 
     * * `minimum` - The minimum valid value for `work_mem`.
     * 
     * * `requires_restart` - Whether changing the value of `work_mem` requires the DB to restart.
     * 
     * * `type` - The type of the value of `work_mem`.
     * 
     * ## pg
     * 
     * The following arguments are supported in the `pg` specification block:
     * 
     * * `autovacuum_analyze_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_analyze_threshold` - (Optional) Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
     * 
     * * `autovacuum_max_workers` - (Optional) Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
     * 
     * * `autovacuum_naptime` - (Optional) Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
     * 
     * * `autovacuum_vacuum_cost_delay` - (Optional) Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
     * 
     * * `autovacuum_vacuum_cost_limit` - (Optional) Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
     * 
     * * `autovacuum_vacuum_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_vacuum_threshold` - (Optional) Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
     * 
     * * `bgwriter_delay` - (Optional) Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
     * 
     * * `bgwriter_flush_after` - (Optional) Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
     * 
     * * `bgwriter_lru_maxpages` - (Optional) In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
     * 
     * * `bgwriter_lru_multiplier` - (Optional) The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
     * 
     * * `deadlock_timeout` - (Optional) This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
     * 
     * * `default_toast_compression` - (Optional) Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
     * 
     * * `idle_in_transaction_session_timeout` - (Optional) Time out sessions with open transactions after this number of milliseconds.
     * 
     * * `jit` - (Optional) Controls system-wide use of Just-in-Time Compilation (JIT).
     * 
     * * `max_files_per_process` - (Optional) PostgreSQL maximum number of files that can be open per process.
     * 
     * * `max_locks_per_transaction` - (Optional) PostgreSQL maximum locks per transaction.
     * 
     * * `max_logical_replication_workers` - (Optional) PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
     * 
     * * `max_parallel_workers` - (Optional) Sets the maximum number of workers that the system can support for parallel queries.
     * 
     * * `max_parallel_workers_per_gather` - (Optional) Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
     * 
     * * `max_pred_locks_per_transaction` - (Optional) PostgreSQL maximum predicate locks per transaction.
     * 
     * * `max_replication_slots` - (Optional) PostgreSQL maximum replication slots.
     * 
     * * `max_slot_wal_keep_size` - (Optional) PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
     * 
     * * `max_stack_depth` - (Optional) Maximum depth of the stack in bytes.
     * 
     * * `max_standby_archive_delay` - (Optional) Max standby archive delay in milliseconds.
     * 
     * * `max_standby_streaming_delay` - (Optional) Max standby streaming delay in milliseconds.
     * 
     * * `max_wal_senders` - (Optional) PostgreSQL maximum WAL senders.
     * 
     * * `max_worker_processes` - (Optional) Sets the maximum number of background processes that the system can support.
     * 
     * * `password_encryption` - (Optional) Chooses the algorithm for encrypting passwords.
     * 
     * * `pg_partman_bgw.interval` - (Optional) Sets the time interval to run pg_partman&#39;s scheduled tasks.
     * 
     * * `pg_partman_bgw.role` - (Optional) Controls which role to use for pg_partman&#39;s scheduled background tasks.
     * 
     * * `pg_stat_monitor.pgsm_enable_query_plan` - (Optional) Enables or disables query plan monitoring.
     * 
     * * `pg_stat_monitor.pgsm_max_buckets` - (Optional) Sets the maximum number of buckets.
     * 
     * * `pg_stat_statements.track` - (Optional) Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
     * 
     * * `temp_file_limit` - (Optional) PostgreSQL temporary file limit in KiB, -1 for unlimited.
     * 
     * * `timezone` - (Optional) PostgreSQL service timezone.
     * 
     * * `track_activity_query_size` - (Optional) Specifies the number of bytes reserved to track the currently executing command for each active session.
     * 
     * * `track_commit_timestamp` - (Optional) Record commit time of transactions.
     * 
     * * `track_functions` - (Optional) Enables tracking of function call counts and time used.
     * 
     * * `track_io_timing` - (Optional) Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
     * 
     * * `wal_sender_timeout` - (Optional) Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
     * 
     * * `wal_writer_delay` - (Optional) WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
     * 
     * ## autovacuum_analyze_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_analyze_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_scale_factor`.
     * 
     * ## autovacuum_analyze_threshold
     * 
     * The following arguments are supported in the `autovacuum_analyze_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_threshold`.
     * 
     * ## autovacuum_max_workers
     * 
     * The following arguments are supported in the `autovacuum_max_workers` specification block:
     * 
     * * `description` - The description of `autovacuum_max_workers`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_max_workers`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_max_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_max_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_max_workers`.
     * 
     * ## autovacuum_naptime
     * 
     * The following arguments are supported in the `autovacuum_naptime` specification block:
     * 
     * * `description` - The description of `autovacuum_naptime`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_naptime`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_naptime`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_naptime` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_naptime`.
     * 
     * ## autovacuum_vacuum_cost_delay
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_delay` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_delay`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_delay`.
     * 
     * ## autovacuum_vacuum_cost_limit
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_limit` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_limit`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_limit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_limit`.
     * 
     * ## autovacuum_vacuum_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_vacuum_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_scale_factor`.
     * 
     * ## autovacuum_vacuum_threshold
     * 
     * The following arguments are supported in the `autovacuum_vacuum_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_threshold`.
     * 
     * ## bgwriter_delay
     * 
     * The following arguments are supported in the `bgwriter_delay` specification block:
     * 
     * * `description` - The description of `bgwriter_delay`.
     * 
     * * `example` - An example of a valid value for `bgwriter_delay`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_delay`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_delay`.
     * 
     * ## bgwriter_flush_after
     * 
     * The following arguments are supported in the `bgwriter_flush_after` specification block:
     * 
     * * `description` - The description of `bgwriter_flush_after`.
     * 
     * * `example` - An example of a valid value for `bgwriter_flush_after`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_flush_after`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_flush_after`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_flush_after` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_flush_after`.
     * 
     * ## bgwriter_lru_maxpages
     * 
     * The following arguments are supported in the `bgwriter_lru_maxpages` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_maxpages`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_maxpages`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_maxpages` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_maxpages`.
     * 
     * ## bgwriter_lru_multiplier
     * 
     * The following arguments are supported in the `bgwriter_lru_multiplier` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_multiplier`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_multiplier`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_multiplier` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_multiplier`.
     * 
     * ## deadlock_timeout
     * 
     * The following arguments are supported in the `deadlock_timeout` specification block:
     * 
     * * `description` - The description of `deadlock_timeout`.
     * 
     * * `example` - An example of a valid value for `deadlock_timeout`.
     * 
     * * `maximum` - The maximum valid value for `deadlock_timeout`.
     * 
     * * `minimum` - The minimum valid value for `deadlock_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `deadlock_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `deadlock_timeout`.
     * 
     * ## default_toast_compression
     * 
     * The following arguments are supported in the `default_toast_compression` specification block:
     * 
     * * `description` - The description of `default_toast_compression`.
     * 
     * * `enum` - A list of valid compression methods for `default_toast_compression`.
     * 
     * * `example` - An example of a valid value for `default_toast_compression`.
     * 
     * * `requires_restart` - Whether changing the value of `default_toast_compression` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_toast_compression`.
     * 
     * ## idle_in_transaction_session_timeout
     * 
     * The following arguments are supported in the `idle_in_transaction_session_timeout` specification block:
     * 
     * * `description` - The description of `idle_in_transaction_session_timeout`.
     * 
     * * `maximum` - The maximum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `minimum` - The minimum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `idle_in_transaction_session_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `idle_in_transaction_session_timeout`.
     * 
     * ## jit
     * 
     * The following arguments are supported in the `jit` specification block:
     * 
     * * `description` - The description of `jit`.
     * 
     * * `example` - An example of a valid value for `jit`.
     * 
     * * `requires_restart` - Whether changing the value of `jit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `jit`.
     * 
     * ## max_files_per_process
     * 
     * The following arguments are supported in the `max_files_per_process` specification block:
     * 
     * * `description` - The description of `max_files_per_process`.
     * 
     * * `maximum` - The maximum valid value for `max_files_per_process`.
     * 
     * * `minimum` - The minimum valid value for `max_files_per_process`.
     * 
     * * `requires_restart` - Whether changing the value of `max_files_per_process` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_files_per_process`.
     * 
     * ## max_locks_per_transaction
     * 
     * The following arguments are supported in the `max_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_locks_per_transaction`.
     * 
     * ## max_logical_replication_workers
     * 
     * The following arguments are supported in the `max_logical_replication_workers` specification block:
     * 
     * * `description` - The description of `max_logical_replication_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_logical_replication_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_logical_replication_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_logical_replication_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_logical_replication_workers`.
     * 
     * ## max_parallel_workers
     * 
     * The following arguments are supported in the `max_parallel_workers` specification block:
     * 
     * * `description` - The description of `max_parallel_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers`.
     * 
     * ## max_parallel_workers_per_gather
     * 
     * The following arguments are supported in the `max_parallel_workers_per_gather` specification block:
     * 
     * * `description` - The description of `max_parallel_workers_per_gather`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers_per_gather` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers_per_gather`.
     * 
     * ## max_pred_locks_per_transaction
     * 
     * The following arguments are supported in the `max_pred_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_pred_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_pred_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_pred_locks_per_transaction`.
     * 
     * ## max_replication_slots
     * 
     * The following arguments are supported in the `max_replication_slots` specification block:
     * 
     * * `description` - The description of `max_replication_slots`.
     * 
     * * `maximum` - The maximum valid value for `max_replication_slots`.
     * 
     * * `minimum` - The minimum valid value for `max_replication_slots`.
     * 
     * * `requires_restart` - Whether changing the value of `max_replication_slots` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_replication_slots`.
     * 
     * ## max_slot_wal_keep_size
     * 
     * The following arguments are supported in the `max_slot_wal_keep_size` specification block:
     * 
     * * `description` - The description of `max_slot_wal_keep_size`.
     * 
     * * `maximum` - The maximum valid value for `max_slot_wal_keep_size`.
     * 
     * * `minimum` - The minimum valid value for `max_slot_wal_keep_size`.
     * 
     * * `requires_restart` - Whether changing the value of `max_slot_wal_keep_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_slot_wal_keep_size`.
     * 
     * ## max_stack_depth
     * 
     * The following arguments are supported in the `max_stack_depth` specification block:
     * 
     * * `description` - The description of `max_stack_depth`.
     * 
     * * `maximum` - The maximum valid value for `max_stack_depth`.
     * 
     * * `minimum` - The minimum valid value for `max_stack_depth`.
     * 
     * * `requires_restart` - Whether changing the value of `max_stack_depth` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_stack_depth`.
     * 
     * ## max_standby_archive_delay
     * 
     * The following arguments are supported in the `max_standby_archive_delay` specification block:
     * 
     * * `description` - The description of `max_standby_archive_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_archive_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_archive_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_archive_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_archive_delay`.
     * 
     * ## max_standby_streaming_delay
     * 
     * The following arguments are supported in the `max_standby_streaming_delay` specification block:
     * 
     * * `description` - The description of `max_standby_streaming_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_streaming_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_streaming_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_streaming_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_streaming_delay`.
     * 
     * ## max_wal_senders
     * 
     * The following arguments are supported in the `max_wal_senders` specification block:
     * 
     * * `description` - The description of `max_wal_senders`.
     * 
     * * `maximum` - The maximum valid value for `max_wal_senders`.
     * 
     * * `minimum` - The minimum valid value for `max_wal_senders`.
     * 
     * * `requires_restart` - Whether changing the value of `max_wal_senders` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_wal_senders`.
     * 
     * ## max_worker_processes
     * 
     * The following arguments are supported in the `max_worker_processes` specification block:
     * 
     * * `description` - The description of `max_worker_processes`.
     * 
     * * `maximum` - The maximum valid value for `max_worker_processes`.
     * 
     * * `minimum` - The minimum valid value for `max_worker_processes`.
     * 
     * * `requires_restart` - Whether changing the value of `max_worker_processes` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_worker_processes`.
     * 
     * ## password_encryption
     * 
     * The following arguments are supported in the `password_encryption` specification block:
     * 
     * * `description` - The description of the `password_encryption` setting.
     * 
     * * `enum` - A list of valid values for the `password_encryption` setting.
     * 
     * * `example` - An example value for the `password_encryption` setting.
     * 
     * * `requires_restart` - Whether changing the value of `password_encryption` requires the DB to restart.
     * 
     * * `type` - A list of types for the `password_encryption` setting.
     * 
     * ## pg_partman_bgw_interval
     * 
     * The following arguments are supported in the `pg_partman_bgw_interval` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_interval` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_interval` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_interval` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_interval` setting.
     * 
     * ## pg_partman_bgw_role
     * 
     * The following arguments are supported in the `pg_partman_bgw_role` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_role` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_role` setting.
     * 
     * * `maxLength` - The maximum length for the `pg_partman_bgw_role` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `pg_partman_bgw_role` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_role` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_role` setting.
     * 
     * ## pg_stat_monitor_pgsm_enable_query_plan
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_enable_query_plan` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_enable_query_plan` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * ## pg_stat_monitor_pgsm_max_buckets
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_max_buckets` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_max_buckets` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * ## pg_stat_statements_track
     * 
     * The following arguments are supported in the `pg_stat_statements_track` specification block:
     * 
     * * `description` - The description of the `pg_stat_statements_track` setting.
     * 
     * * `enum` - A list of valid values for the `pg_stat_statements_track` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_statements_track` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_statements_track` setting.
     * 
     * ## temp_file_limit
     * 
     * The following arguments are supported in the `temp_file_limit` specification block:
     * 
     * * `description` - The description of the `temp_file_limit` setting.
     * 
     * * `example` - An example value for the `temp_file_limit` setting.
     * 
     * * `maximum` - The maximum allowed value for the `temp_file_limit` setting.
     * 
     * * `minimum` - The minimum allowed value for the `temp_file_limit` setting.
     * 
     * * `requires_restart` - Whether changing the value of `temp_file_limit` requires the DB to restart.
     * 
     * * `type` - The type of the `temp_file_limit` setting.
     * 
     * ## timezone
     * 
     * The following arguments are supported in the `timezone` specification block:
     * 
     * * `description` - The description of the `timezone` setting.
     * 
     * * `example` - An example value for the `timezone` setting.
     * 
     * * `maxLength` - The maximum length for the `timezone` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `timezone` setting.
     * 
     * * `requires_restart` - Whether changing the value of `timezone` requires the DB to restart.
     * 
     * * `type` - The type of the `timezone` setting.
     * 
     * ## track_activity_query_size
     * 
     * The following arguments are supported in the `track_activity_query_size` specification block:
     * 
     * * `description` - The description of the `track_activity_query_size` setting.
     * 
     * * `example` - An example value for the `track_activity_query_size` setting.
     * 
     * * `maximum` - The maximum allowed value for the `track_activity_query_size` setting.
     * 
     * * `minimum` - The minimum allowed value for the `track_activity_query_size` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_activity_query_size` requires the DB to restart.
     * 
     * * `type` - The type of the `track_activity_query_size` setting.
     * 
     * ## track_commit_timestamp
     * 
     * The following arguments are supported in the `track_commit_timestamp` specification block:
     * 
     * * `description` - The description of the `track_commit_timestamp` setting.
     * 
     * * `enum` - A list of valid values for the `track_commit_timestamp` setting.
     * 
     * * `example` - An example value for the `track_commit_timestamp` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_commit_timestamp` requires the DB to restart.
     * 
     * * `type` - The type of the `track_commit_timestamp` setting.
     * 
     * ## track_functions
     * 
     * The following arguments are supported in the `track_functions` specification block:
     * 
     * * `description` - The description of the `track_functions` setting.
     * 
     * * `enum` - A list of valid values for the `track_functions` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_functions` requires the DB to restart.
     * 
     * * `type` - The type of the `track_functions` setting.
     * 
     * ## track_io_timing
     * 
     * The following arguments are supported in the `track_io_timing` specification block:
     * 
     * * `description` - The description of the `track_io_timing` setting.
     * 
     * * `enum` - A list of valid values for the `track_io_timing` setting.
     * 
     * * `example` - An example value for the `track_io_timing` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_io_timing` requires the DB to restart.
     * 
     * * `type` - The type of the `track_io_timing` setting.
     * 
     * ## wal_sender_timeout
     * 
     * The following arguments are supported in the `wal_sender_timeout` specification block:
     * 
     * * `description` - The description of the `wal_sender_timeout` setting.
     * 
     * * `example` - An example value for the `wal_sender_timeout` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_sender_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_sender_timeout` setting.
     * 
     * ## wal_writer_delay
     * 
     * The following arguments are supported in the `wal_writer_delay` specification block:
     * 
     * * `description` - The description of the `wal_writer_delay` setting.
     * 
     * * `example` - An example value for the `wal_writer_delay` setting.
     * 
     * * `maximum` - The maximum allowed value for the `wal_writer_delay` setting.
     * 
     * * `minimum` - The minimum allowed value for the `wal_writer_delay` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_writer_delay` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_writer_delay` setting.
     * 
     */
    public static Output<GetDatabasePostgresqlConfigResult> getDatabasePostgresqlConfig(InvokeArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabasePostgresqlConfig:getDatabasePostgresqlConfig", TypeShape.of(GetDatabasePostgresqlConfigResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode PostgreSQL Database&#39;s Configuration Options.
     * For more information, see the Linode APIv4 docs.
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database&#39;s configuration options:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db-config = LinodeFunctions.getDatabasePostgresqlConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pg_stat_monitor_enable
     * 
     * The following arguments are supported in the `pg_stat_monitor_enable` specification block:
     * 
     * * `description` - The description of `pg_stat_monitor_enable`.
     * 
     * * `requires_restart` - Whether changing the value `pg_stat_monitor_enable` requires the DB to restart.
     * 
     * * `type` - The type of the value of `pg_stat_monitor_enable`.
     * 
     * ## pglookout
     * 
     * The following arguments are supported in the `pglookout` specification block:
     * 
     * * `max_failover_replication_time_lag` - The maximum failover replication time lag for `pglookout`.
     * 
     * ## max_failover_replication_time_lag
     * 
     * The following arguments are supported in the `max_failover_replication_time_lag` specification block:
     * 
     * * `description` - The description of `max_failover_replication_time_lag`.
     * 
     * * `maximum` - The maximum valid value for `max_failover_replication_time_lag`.
     * 
     * * `minimum` - The minimum valid value for `max_failover_replication_time_lag`.
     * 
     * * `requires_restart` - Whether changing the value of `max_failover_replication_time_lag` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_failover_replication_time_lag`.
     * 
     * ## shared_buffers_percentage
     * 
     * The following arguments are supported in the `shared_buffers_percentage` specification block:
     * 
     * * `description` - The description of `shared_buffers_percentage`.
     * 
     * * `example` - An example of a valid value for `shared_buffers_percentage`.
     * 
     * * `maximum` - The maximum valid value for `shared_buffers_percentage`.
     * 
     * * `minimum` - The minimum valid value for `shared_buffers_percentage`.
     * 
     * * `requires_restart` - Whether changing the value of `shared_buffers_percentage` requires the DB to restart.
     * 
     * * `type` - The type of the value of `shared_buffers_percentage`.
     * 
     * ## work_mem
     * 
     * The following arguments are supported in the `work_mem` specification block:
     * 
     * * `description` - The description of `work_mem`.
     * 
     * * `example` - An example of a valid value for `work_mem`.
     * 
     * * `maximum` - The maximum valid value for `work_mem`.
     * 
     * * `minimum` - The minimum valid value for `work_mem`.
     * 
     * * `requires_restart` - Whether changing the value of `work_mem` requires the DB to restart.
     * 
     * * `type` - The type of the value of `work_mem`.
     * 
     * ## pg
     * 
     * The following arguments are supported in the `pg` specification block:
     * 
     * * `autovacuum_analyze_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_analyze_threshold` - (Optional) Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
     * 
     * * `autovacuum_max_workers` - (Optional) Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
     * 
     * * `autovacuum_naptime` - (Optional) Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
     * 
     * * `autovacuum_vacuum_cost_delay` - (Optional) Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
     * 
     * * `autovacuum_vacuum_cost_limit` - (Optional) Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
     * 
     * * `autovacuum_vacuum_scale_factor` - (Optional) Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
     * 
     * * `autovacuum_vacuum_threshold` - (Optional) Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
     * 
     * * `bgwriter_delay` - (Optional) Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
     * 
     * * `bgwriter_flush_after` - (Optional) Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
     * 
     * * `bgwriter_lru_maxpages` - (Optional) In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
     * 
     * * `bgwriter_lru_multiplier` - (Optional) The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
     * 
     * * `deadlock_timeout` - (Optional) This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
     * 
     * * `default_toast_compression` - (Optional) Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
     * 
     * * `idle_in_transaction_session_timeout` - (Optional) Time out sessions with open transactions after this number of milliseconds.
     * 
     * * `jit` - (Optional) Controls system-wide use of Just-in-Time Compilation (JIT).
     * 
     * * `max_files_per_process` - (Optional) PostgreSQL maximum number of files that can be open per process.
     * 
     * * `max_locks_per_transaction` - (Optional) PostgreSQL maximum locks per transaction.
     * 
     * * `max_logical_replication_workers` - (Optional) PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
     * 
     * * `max_parallel_workers` - (Optional) Sets the maximum number of workers that the system can support for parallel queries.
     * 
     * * `max_parallel_workers_per_gather` - (Optional) Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
     * 
     * * `max_pred_locks_per_transaction` - (Optional) PostgreSQL maximum predicate locks per transaction.
     * 
     * * `max_replication_slots` - (Optional) PostgreSQL maximum replication slots.
     * 
     * * `max_slot_wal_keep_size` - (Optional) PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
     * 
     * * `max_stack_depth` - (Optional) Maximum depth of the stack in bytes.
     * 
     * * `max_standby_archive_delay` - (Optional) Max standby archive delay in milliseconds.
     * 
     * * `max_standby_streaming_delay` - (Optional) Max standby streaming delay in milliseconds.
     * 
     * * `max_wal_senders` - (Optional) PostgreSQL maximum WAL senders.
     * 
     * * `max_worker_processes` - (Optional) Sets the maximum number of background processes that the system can support.
     * 
     * * `password_encryption` - (Optional) Chooses the algorithm for encrypting passwords.
     * 
     * * `pg_partman_bgw.interval` - (Optional) Sets the time interval to run pg_partman&#39;s scheduled tasks.
     * 
     * * `pg_partman_bgw.role` - (Optional) Controls which role to use for pg_partman&#39;s scheduled background tasks.
     * 
     * * `pg_stat_monitor.pgsm_enable_query_plan` - (Optional) Enables or disables query plan monitoring.
     * 
     * * `pg_stat_monitor.pgsm_max_buckets` - (Optional) Sets the maximum number of buckets.
     * 
     * * `pg_stat_statements.track` - (Optional) Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
     * 
     * * `temp_file_limit` - (Optional) PostgreSQL temporary file limit in KiB, -1 for unlimited.
     * 
     * * `timezone` - (Optional) PostgreSQL service timezone.
     * 
     * * `track_activity_query_size` - (Optional) Specifies the number of bytes reserved to track the currently executing command for each active session.
     * 
     * * `track_commit_timestamp` - (Optional) Record commit time of transactions.
     * 
     * * `track_functions` - (Optional) Enables tracking of function call counts and time used.
     * 
     * * `track_io_timing` - (Optional) Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
     * 
     * * `wal_sender_timeout` - (Optional) Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
     * 
     * * `wal_writer_delay` - (Optional) WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
     * 
     * ## autovacuum_analyze_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_analyze_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_scale_factor`.
     * 
     * ## autovacuum_analyze_threshold
     * 
     * The following arguments are supported in the `autovacuum_analyze_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_analyze_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_analyze_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_analyze_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_analyze_threshold`.
     * 
     * ## autovacuum_max_workers
     * 
     * The following arguments are supported in the `autovacuum_max_workers` specification block:
     * 
     * * `description` - The description of `autovacuum_max_workers`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_max_workers`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_max_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_max_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_max_workers`.
     * 
     * ## autovacuum_naptime
     * 
     * The following arguments are supported in the `autovacuum_naptime` specification block:
     * 
     * * `description` - The description of `autovacuum_naptime`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_naptime`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_naptime`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_naptime` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_naptime`.
     * 
     * ## autovacuum_vacuum_cost_delay
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_delay` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_delay`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_delay`.
     * 
     * ## autovacuum_vacuum_cost_limit
     * 
     * The following arguments are supported in the `autovacuum_vacuum_cost_limit` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_cost_limit`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_cost_limit`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_cost_limit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_cost_limit`.
     * 
     * ## autovacuum_vacuum_scale_factor
     * 
     * The following arguments are supported in the `autovacuum_vacuum_scale_factor` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_scale_factor`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_scale_factor`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_scale_factor` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_scale_factor`.
     * 
     * ## autovacuum_vacuum_threshold
     * 
     * The following arguments are supported in the `autovacuum_vacuum_threshold` specification block:
     * 
     * * `description` - The description of `autovacuum_vacuum_threshold`.
     * 
     * * `maximum` - The maximum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `minimum` - The minimum valid value for `autovacuum_vacuum_threshold`.
     * 
     * * `requires_restart` - Whether changing the value of `autovacuum_vacuum_threshold` requires the DB to restart.
     * 
     * * `type` - The type of the value of `autovacuum_vacuum_threshold`.
     * 
     * ## bgwriter_delay
     * 
     * The following arguments are supported in the `bgwriter_delay` specification block:
     * 
     * * `description` - The description of `bgwriter_delay`.
     * 
     * * `example` - An example of a valid value for `bgwriter_delay`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_delay`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_delay`.
     * 
     * ## bgwriter_flush_after
     * 
     * The following arguments are supported in the `bgwriter_flush_after` specification block:
     * 
     * * `description` - The description of `bgwriter_flush_after`.
     * 
     * * `example` - An example of a valid value for `bgwriter_flush_after`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_flush_after`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_flush_after`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_flush_after` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_flush_after`.
     * 
     * ## bgwriter_lru_maxpages
     * 
     * The following arguments are supported in the `bgwriter_lru_maxpages` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_maxpages`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_maxpages`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_maxpages`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_maxpages` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_maxpages`.
     * 
     * ## bgwriter_lru_multiplier
     * 
     * The following arguments are supported in the `bgwriter_lru_multiplier` specification block:
     * 
     * * `description` - The description of `bgwriter_lru_multiplier`.
     * 
     * * `example` - An example of a valid value for `bgwriter_lru_multiplier`.
     * 
     * * `maximum` - The maximum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `minimum` - The minimum valid value for `bgwriter_lru_multiplier`.
     * 
     * * `requires_restart` - Whether changing the value of `bgwriter_lru_multiplier` requires the DB to restart.
     * 
     * * `type` - The type of the value of `bgwriter_lru_multiplier`.
     * 
     * ## deadlock_timeout
     * 
     * The following arguments are supported in the `deadlock_timeout` specification block:
     * 
     * * `description` - The description of `deadlock_timeout`.
     * 
     * * `example` - An example of a valid value for `deadlock_timeout`.
     * 
     * * `maximum` - The maximum valid value for `deadlock_timeout`.
     * 
     * * `minimum` - The minimum valid value for `deadlock_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `deadlock_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `deadlock_timeout`.
     * 
     * ## default_toast_compression
     * 
     * The following arguments are supported in the `default_toast_compression` specification block:
     * 
     * * `description` - The description of `default_toast_compression`.
     * 
     * * `enum` - A list of valid compression methods for `default_toast_compression`.
     * 
     * * `example` - An example of a valid value for `default_toast_compression`.
     * 
     * * `requires_restart` - Whether changing the value of `default_toast_compression` requires the DB to restart.
     * 
     * * `type` - The type of the value of `default_toast_compression`.
     * 
     * ## idle_in_transaction_session_timeout
     * 
     * The following arguments are supported in the `idle_in_transaction_session_timeout` specification block:
     * 
     * * `description` - The description of `idle_in_transaction_session_timeout`.
     * 
     * * `maximum` - The maximum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `minimum` - The minimum valid value for `idle_in_transaction_session_timeout`.
     * 
     * * `requires_restart` - Whether changing the value of `idle_in_transaction_session_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the value of `idle_in_transaction_session_timeout`.
     * 
     * ## jit
     * 
     * The following arguments are supported in the `jit` specification block:
     * 
     * * `description` - The description of `jit`.
     * 
     * * `example` - An example of a valid value for `jit`.
     * 
     * * `requires_restart` - Whether changing the value of `jit` requires the DB to restart.
     * 
     * * `type` - The type of the value of `jit`.
     * 
     * ## max_files_per_process
     * 
     * The following arguments are supported in the `max_files_per_process` specification block:
     * 
     * * `description` - The description of `max_files_per_process`.
     * 
     * * `maximum` - The maximum valid value for `max_files_per_process`.
     * 
     * * `minimum` - The minimum valid value for `max_files_per_process`.
     * 
     * * `requires_restart` - Whether changing the value of `max_files_per_process` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_files_per_process`.
     * 
     * ## max_locks_per_transaction
     * 
     * The following arguments are supported in the `max_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_locks_per_transaction`.
     * 
     * ## max_logical_replication_workers
     * 
     * The following arguments are supported in the `max_logical_replication_workers` specification block:
     * 
     * * `description` - The description of `max_logical_replication_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_logical_replication_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_logical_replication_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_logical_replication_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_logical_replication_workers`.
     * 
     * ## max_parallel_workers
     * 
     * The following arguments are supported in the `max_parallel_workers` specification block:
     * 
     * * `description` - The description of `max_parallel_workers`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers`.
     * 
     * ## max_parallel_workers_per_gather
     * 
     * The following arguments are supported in the `max_parallel_workers_per_gather` specification block:
     * 
     * * `description` - The description of `max_parallel_workers_per_gather`.
     * 
     * * `maximum` - The maximum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `minimum` - The minimum valid value for `max_parallel_workers_per_gather`.
     * 
     * * `requires_restart` - Whether changing the value of `max_parallel_workers_per_gather` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_parallel_workers_per_gather`.
     * 
     * ## max_pred_locks_per_transaction
     * 
     * The following arguments are supported in the `max_pred_locks_per_transaction` specification block:
     * 
     * * `description` - The description of `max_pred_locks_per_transaction`.
     * 
     * * `maximum` - The maximum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `minimum` - The minimum valid value for `max_pred_locks_per_transaction`.
     * 
     * * `requires_restart` - Whether changing the value of `max_pred_locks_per_transaction` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_pred_locks_per_transaction`.
     * 
     * ## max_replication_slots
     * 
     * The following arguments are supported in the `max_replication_slots` specification block:
     * 
     * * `description` - The description of `max_replication_slots`.
     * 
     * * `maximum` - The maximum valid value for `max_replication_slots`.
     * 
     * * `minimum` - The minimum valid value for `max_replication_slots`.
     * 
     * * `requires_restart` - Whether changing the value of `max_replication_slots` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_replication_slots`.
     * 
     * ## max_slot_wal_keep_size
     * 
     * The following arguments are supported in the `max_slot_wal_keep_size` specification block:
     * 
     * * `description` - The description of `max_slot_wal_keep_size`.
     * 
     * * `maximum` - The maximum valid value for `max_slot_wal_keep_size`.
     * 
     * * `minimum` - The minimum valid value for `max_slot_wal_keep_size`.
     * 
     * * `requires_restart` - Whether changing the value of `max_slot_wal_keep_size` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_slot_wal_keep_size`.
     * 
     * ## max_stack_depth
     * 
     * The following arguments are supported in the `max_stack_depth` specification block:
     * 
     * * `description` - The description of `max_stack_depth`.
     * 
     * * `maximum` - The maximum valid value for `max_stack_depth`.
     * 
     * * `minimum` - The minimum valid value for `max_stack_depth`.
     * 
     * * `requires_restart` - Whether changing the value of `max_stack_depth` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_stack_depth`.
     * 
     * ## max_standby_archive_delay
     * 
     * The following arguments are supported in the `max_standby_archive_delay` specification block:
     * 
     * * `description` - The description of `max_standby_archive_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_archive_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_archive_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_archive_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_archive_delay`.
     * 
     * ## max_standby_streaming_delay
     * 
     * The following arguments are supported in the `max_standby_streaming_delay` specification block:
     * 
     * * `description` - The description of `max_standby_streaming_delay`.
     * 
     * * `maximum` - The maximum valid value for `max_standby_streaming_delay`.
     * 
     * * `minimum` - The minimum valid value for `max_standby_streaming_delay`.
     * 
     * * `requires_restart` - Whether changing the value of `max_standby_streaming_delay` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_standby_streaming_delay`.
     * 
     * ## max_wal_senders
     * 
     * The following arguments are supported in the `max_wal_senders` specification block:
     * 
     * * `description` - The description of `max_wal_senders`.
     * 
     * * `maximum` - The maximum valid value for `max_wal_senders`.
     * 
     * * `minimum` - The minimum valid value for `max_wal_senders`.
     * 
     * * `requires_restart` - Whether changing the value of `max_wal_senders` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_wal_senders`.
     * 
     * ## max_worker_processes
     * 
     * The following arguments are supported in the `max_worker_processes` specification block:
     * 
     * * `description` - The description of `max_worker_processes`.
     * 
     * * `maximum` - The maximum valid value for `max_worker_processes`.
     * 
     * * `minimum` - The minimum valid value for `max_worker_processes`.
     * 
     * * `requires_restart` - Whether changing the value of `max_worker_processes` requires the DB to restart.
     * 
     * * `type` - The type of the value of `max_worker_processes`.
     * 
     * ## password_encryption
     * 
     * The following arguments are supported in the `password_encryption` specification block:
     * 
     * * `description` - The description of the `password_encryption` setting.
     * 
     * * `enum` - A list of valid values for the `password_encryption` setting.
     * 
     * * `example` - An example value for the `password_encryption` setting.
     * 
     * * `requires_restart` - Whether changing the value of `password_encryption` requires the DB to restart.
     * 
     * * `type` - A list of types for the `password_encryption` setting.
     * 
     * ## pg_partman_bgw_interval
     * 
     * The following arguments are supported in the `pg_partman_bgw_interval` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_interval` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_interval` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_partman_bgw_interval` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_interval` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_interval` setting.
     * 
     * ## pg_partman_bgw_role
     * 
     * The following arguments are supported in the `pg_partman_bgw_role` specification block:
     * 
     * * `description` - The description of the `pg_partman_bgw_role` setting.
     * 
     * * `example` - An example value for the `pg_partman_bgw_role` setting.
     * 
     * * `maxLength` - The maximum length for the `pg_partman_bgw_role` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `pg_partman_bgw_role` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_partman_bgw_role` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_partman_bgw_role` setting.
     * 
     * ## pg_stat_monitor_pgsm_enable_query_plan
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_enable_query_plan` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_enable_query_plan` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_enable_query_plan` setting.
     * 
     * ## pg_stat_monitor_pgsm_max_buckets
     * 
     * The following arguments are supported in the `pg_stat_monitor_pgsm_max_buckets` specification block:
     * 
     * * `description` - The description of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `example` - An example value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `maximum` - The maximum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `minimum` - The minimum allowed value for the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_monitor_pgsm_max_buckets` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_monitor_pgsm_max_buckets` setting.
     * 
     * ## pg_stat_statements_track
     * 
     * The following arguments are supported in the `pg_stat_statements_track` specification block:
     * 
     * * `description` - The description of the `pg_stat_statements_track` setting.
     * 
     * * `enum` - A list of valid values for the `pg_stat_statements_track` setting.
     * 
     * * `requires_restart` - Whether changing the value of `pg_stat_statements_track` requires the DB to restart.
     * 
     * * `type` - The type of the `pg_stat_statements_track` setting.
     * 
     * ## temp_file_limit
     * 
     * The following arguments are supported in the `temp_file_limit` specification block:
     * 
     * * `description` - The description of the `temp_file_limit` setting.
     * 
     * * `example` - An example value for the `temp_file_limit` setting.
     * 
     * * `maximum` - The maximum allowed value for the `temp_file_limit` setting.
     * 
     * * `minimum` - The minimum allowed value for the `temp_file_limit` setting.
     * 
     * * `requires_restart` - Whether changing the value of `temp_file_limit` requires the DB to restart.
     * 
     * * `type` - The type of the `temp_file_limit` setting.
     * 
     * ## timezone
     * 
     * The following arguments are supported in the `timezone` specification block:
     * 
     * * `description` - The description of the `timezone` setting.
     * 
     * * `example` - An example value for the `timezone` setting.
     * 
     * * `maxLength` - The maximum length for the `timezone` setting.
     * 
     * * `pattern` - The regular expression pattern for validating the `timezone` setting.
     * 
     * * `requires_restart` - Whether changing the value of `timezone` requires the DB to restart.
     * 
     * * `type` - The type of the `timezone` setting.
     * 
     * ## track_activity_query_size
     * 
     * The following arguments are supported in the `track_activity_query_size` specification block:
     * 
     * * `description` - The description of the `track_activity_query_size` setting.
     * 
     * * `example` - An example value for the `track_activity_query_size` setting.
     * 
     * * `maximum` - The maximum allowed value for the `track_activity_query_size` setting.
     * 
     * * `minimum` - The minimum allowed value for the `track_activity_query_size` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_activity_query_size` requires the DB to restart.
     * 
     * * `type` - The type of the `track_activity_query_size` setting.
     * 
     * ## track_commit_timestamp
     * 
     * The following arguments are supported in the `track_commit_timestamp` specification block:
     * 
     * * `description` - The description of the `track_commit_timestamp` setting.
     * 
     * * `enum` - A list of valid values for the `track_commit_timestamp` setting.
     * 
     * * `example` - An example value for the `track_commit_timestamp` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_commit_timestamp` requires the DB to restart.
     * 
     * * `type` - The type of the `track_commit_timestamp` setting.
     * 
     * ## track_functions
     * 
     * The following arguments are supported in the `track_functions` specification block:
     * 
     * * `description` - The description of the `track_functions` setting.
     * 
     * * `enum` - A list of valid values for the `track_functions` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_functions` requires the DB to restart.
     * 
     * * `type` - The type of the `track_functions` setting.
     * 
     * ## track_io_timing
     * 
     * The following arguments are supported in the `track_io_timing` specification block:
     * 
     * * `description` - The description of the `track_io_timing` setting.
     * 
     * * `enum` - A list of valid values for the `track_io_timing` setting.
     * 
     * * `example` - An example value for the `track_io_timing` setting.
     * 
     * * `requires_restart` - Whether changing the value of `track_io_timing` requires the DB to restart.
     * 
     * * `type` - The type of the `track_io_timing` setting.
     * 
     * ## wal_sender_timeout
     * 
     * The following arguments are supported in the `wal_sender_timeout` specification block:
     * 
     * * `description` - The description of the `wal_sender_timeout` setting.
     * 
     * * `example` - An example value for the `wal_sender_timeout` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_sender_timeout` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_sender_timeout` setting.
     * 
     * ## wal_writer_delay
     * 
     * The following arguments are supported in the `wal_writer_delay` specification block:
     * 
     * * `description` - The description of the `wal_writer_delay` setting.
     * 
     * * `example` - An example value for the `wal_writer_delay` setting.
     * 
     * * `maximum` - The maximum allowed value for the `wal_writer_delay` setting.
     * 
     * * `minimum` - The minimum allowed value for the `wal_writer_delay` setting.
     * 
     * * `requires_restart` - Whether changing the value of `wal_writer_delay` requires the DB to restart.
     * 
     * * `type` - The type of the `wal_writer_delay` setting.
     * 
     */
    public static CompletableFuture<GetDatabasePostgresqlConfigResult> getDatabasePostgresqlConfigPlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDatabasePostgresqlConfig:getDatabasePostgresqlConfig", TypeShape.of(GetDatabasePostgresqlConfigResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlV2Args;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresqlV2(GetDatabasePostgresqlV2Args.builder()
     *             .id("12345")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pending_updates
     * 
     * The following arguments are exposed by each entry in the `pending_updates` attribute:
     * 
     * * `deadline` - The time when a mandatory update needs to be applied.
     * 
     * * `description` - A description of the update.
     * 
     * * `planned_for` - The date and time a maintenance update will be applied.
     * 
     * ## updates
     * 
     * The following arguments are supported in the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - The frequency at which maintenance occurs. (`weekly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     */
    public static Output<GetDatabasePostgresqlV2Result> getDatabasePostgresqlV2(GetDatabasePostgresqlV2Args args) {
        return getDatabasePostgresqlV2(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlV2Args;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresqlV2(GetDatabasePostgresqlV2Args.builder()
     *             .id("12345")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pending_updates
     * 
     * The following arguments are exposed by each entry in the `pending_updates` attribute:
     * 
     * * `deadline` - The time when a mandatory update needs to be applied.
     * 
     * * `description` - A description of the update.
     * 
     * * `planned_for` - The date and time a maintenance update will be applied.
     * 
     * ## updates
     * 
     * The following arguments are supported in the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - The frequency at which maintenance occurs. (`weekly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     */
    public static CompletableFuture<GetDatabasePostgresqlV2Result> getDatabasePostgresqlV2Plain(GetDatabasePostgresqlV2PlainArgs args) {
        return getDatabasePostgresqlV2Plain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlV2Args;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresqlV2(GetDatabasePostgresqlV2Args.builder()
     *             .id("12345")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pending_updates
     * 
     * The following arguments are exposed by each entry in the `pending_updates` attribute:
     * 
     * * `deadline` - The time when a mandatory update needs to be applied.
     * 
     * * `description` - A description of the update.
     * 
     * * `planned_for` - The date and time a maintenance update will be applied.
     * 
     * ## updates
     * 
     * The following arguments are supported in the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - The frequency at which maintenance occurs. (`weekly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     */
    public static Output<GetDatabasePostgresqlV2Result> getDatabasePostgresqlV2(GetDatabasePostgresqlV2Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabasePostgresqlV2:getDatabasePostgresqlV2", TypeShape.of(GetDatabasePostgresqlV2Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlV2Args;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresqlV2(GetDatabasePostgresqlV2Args.builder()
     *             .id("12345")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pending_updates
     * 
     * The following arguments are exposed by each entry in the `pending_updates` attribute:
     * 
     * * `deadline` - The time when a mandatory update needs to be applied.
     * 
     * * `description` - A description of the update.
     * 
     * * `planned_for` - The date and time a maintenance update will be applied.
     * 
     * ## updates
     * 
     * The following arguments are supported in the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - The frequency at which maintenance occurs. (`weekly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     */
    public static Output<GetDatabasePostgresqlV2Result> getDatabasePostgresqlV2(GetDatabasePostgresqlV2Args args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabasePostgresqlV2:getDatabasePostgresqlV2", TypeShape.of(GetDatabasePostgresqlV2Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode PostgreSQL Database.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-backups).
     * 
     * ## Example Usage
     * 
     * Get information about a PostgreSQL database:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasePostgresqlV2Args;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-db = LinodeFunctions.getDatabasePostgresqlV2(GetDatabasePostgresqlV2Args.builder()
     *             .id("12345")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## pending_updates
     * 
     * The following arguments are exposed by each entry in the `pending_updates` attribute:
     * 
     * * `deadline` - The time when a mandatory update needs to be applied.
     * 
     * * `description` - A description of the update.
     * 
     * * `planned_for` - The date and time a maintenance update will be applied.
     * 
     * ## updates
     * 
     * The following arguments are supported in the `updates` specification block:
     * 
     * * `day_of_week` - The day to perform maintenance. (`monday`, `tuesday`, ...)
     * 
     * * `duration` - The maximum maintenance window time in hours. (`1`..`3`)
     * 
     * * `frequency` - The frequency at which maintenance occurs. (`weekly`)
     * 
     * * `hour_of_day` - The hour to begin maintenance based in UTC time. (`0`..`23`)
     * 
     */
    public static CompletableFuture<GetDatabasePostgresqlV2Result> getDatabasePostgresqlV2Plain(GetDatabasePostgresqlV2PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDatabasePostgresqlV2:getDatabasePostgresqlV2", TypeShape.of(GetDatabasePostgresqlV2Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Managed Databases that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .build());
     * 
     *         ctx.export("databaseIds", all.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .filters(GetDatabasesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("databaseIds", mysql.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabasesResult> getDatabases() {
        return getDatabases(GetDatabasesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Managed Databases that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .build());
     * 
     *         ctx.export("databaseIds", all.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .filters(GetDatabasesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("databaseIds", mysql.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDatabasesResult> getDatabasesPlain() {
        return getDatabasesPlain(GetDatabasesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Managed Databases that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .build());
     * 
     *         ctx.export("databaseIds", all.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .filters(GetDatabasesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("databaseIds", mysql.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabasesResult> getDatabases(GetDatabasesArgs args) {
        return getDatabases(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Managed Databases that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .build());
     * 
     *         ctx.export("databaseIds", all.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .filters(GetDatabasesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("databaseIds", mysql.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDatabasesResult> getDatabasesPlain(GetDatabasesPlainArgs args) {
        return getDatabasesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Managed Databases that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .build());
     * 
     *         ctx.export("databaseIds", all.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .filters(GetDatabasesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("databaseIds", mysql.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabasesResult> getDatabases(GetDatabasesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabases:getDatabases", TypeShape.of(GetDatabasesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Managed Databases that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .build());
     * 
     *         ctx.export("databaseIds", all.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .filters(GetDatabasesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("databaseIds", mysql.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDatabasesResult> getDatabases(GetDatabasesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDatabases:getDatabases", TypeShape.of(GetDatabasesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Managed Databases that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-databases-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Managed Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .build());
     * 
     *         ctx.export("databaseIds", all.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode MySQL Databases:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDatabasesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var mysql = LinodeFunctions.getDatabases(GetDatabasesArgs.builder()
     *             .filters(GetDatabasesFilterArgs.builder()
     *                 .name("engine")
     *                 .values("mysql")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("databaseIds", mysql.databases().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDatabasesResult> getDatabasesPlain(GetDatabasesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDatabases:getDatabases", TypeShape.of(GetDatabasesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode domain.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode domain.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *         final var bar = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .domain("bar.example.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDomainResult> getDomain() {
        return getDomain(GetDomainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode domain.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode domain.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *         final var bar = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .domain("bar.example.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDomainResult> getDomainPlain() {
        return getDomainPlain(GetDomainPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode domain.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode domain.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *         final var bar = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .domain("bar.example.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDomainResult> getDomain(GetDomainArgs args) {
        return getDomain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode domain.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode domain.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *         final var bar = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .domain("bar.example.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDomainResult> getDomainPlain(GetDomainPlainArgs args) {
        return getDomainPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode domain.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode domain.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *         final var bar = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .domain("bar.example.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDomainResult> getDomain(GetDomainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDomain:getDomain", TypeShape.of(GetDomainResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode domain.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode domain.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *         final var bar = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .domain("bar.example.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDomainResult> getDomain(GetDomainArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDomain:getDomain", TypeShape.of(GetDomainResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode domain.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode domain.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *         final var bar = LinodeFunctions.getDomain(GetDomainArgs.builder()
     *             .domain("bar.example.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDomainResult> getDomainPlain(GetDomainPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDomain:getDomain", TypeShape.of(GetDomainResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Domain Record.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain-record).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Domain Record.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainRecordArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myRecord = LinodeFunctions.getDomainRecord(GetDomainRecordArgs.builder()
     *             .id(14950401)
     *             .domainId(3150401)
     *             .build());
     * 
     *         final var myWwwRecord = LinodeFunctions.getDomainRecord(GetDomainRecordArgs.builder()
     *             .name("www")
     *             .domainId(3150401)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDomainRecordResult> getDomainRecord(GetDomainRecordArgs args) {
        return getDomainRecord(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Domain Record.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain-record).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Domain Record.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainRecordArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myRecord = LinodeFunctions.getDomainRecord(GetDomainRecordArgs.builder()
     *             .id(14950401)
     *             .domainId(3150401)
     *             .build());
     * 
     *         final var myWwwRecord = LinodeFunctions.getDomainRecord(GetDomainRecordArgs.builder()
     *             .name("www")
     *             .domainId(3150401)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDomainRecordResult> getDomainRecordPlain(GetDomainRecordPlainArgs args) {
        return getDomainRecordPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Domain Record.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain-record).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Domain Record.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainRecordArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myRecord = LinodeFunctions.getDomainRecord(GetDomainRecordArgs.builder()
     *             .id(14950401)
     *             .domainId(3150401)
     *             .build());
     * 
     *         final var myWwwRecord = LinodeFunctions.getDomainRecord(GetDomainRecordArgs.builder()
     *             .name("www")
     *             .domainId(3150401)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDomainRecordResult> getDomainRecord(GetDomainRecordArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDomainRecord:getDomainRecord", TypeShape.of(GetDomainRecordResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Domain Record.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain-record).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Domain Record.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainRecordArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myRecord = LinodeFunctions.getDomainRecord(GetDomainRecordArgs.builder()
     *             .id(14950401)
     *             .domainId(3150401)
     *             .build());
     * 
     *         final var myWwwRecord = LinodeFunctions.getDomainRecord(GetDomainRecordArgs.builder()
     *             .name("www")
     *             .domainId(3150401)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDomainRecordResult> getDomainRecord(GetDomainRecordArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDomainRecord:getDomainRecord", TypeShape.of(GetDomainRecordResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Domain Record.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain-record).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Domain Record.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainRecordArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myRecord = LinodeFunctions.getDomainRecord(GetDomainRecordArgs.builder()
     *             .id(14950401)
     *             .domainId(3150401)
     *             .build());
     * 
     *         final var myWwwRecord = LinodeFunctions.getDomainRecord(GetDomainRecordArgs.builder()
     *             .name("www")
     *             .domainId(3150401)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDomainRecordResult> getDomainRecordPlain(GetDomainRecordPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDomainRecord:getDomainRecord", TypeShape.of(GetDomainRecordResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Domain Zonefile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain-zone).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Domain Zonefile.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainZonefileArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myZonefile = LinodeFunctions.getDomainZonefile(GetDomainZonefileArgs.builder()
     *             .domainId(3150401)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDomainZonefileResult> getDomainZonefile(GetDomainZonefileArgs args) {
        return getDomainZonefile(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Domain Zonefile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain-zone).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Domain Zonefile.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainZonefileArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myZonefile = LinodeFunctions.getDomainZonefile(GetDomainZonefileArgs.builder()
     *             .domainId(3150401)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDomainZonefileResult> getDomainZonefilePlain(GetDomainZonefilePlainArgs args) {
        return getDomainZonefilePlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Domain Zonefile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain-zone).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Domain Zonefile.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainZonefileArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myZonefile = LinodeFunctions.getDomainZonefile(GetDomainZonefileArgs.builder()
     *             .domainId(3150401)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDomainZonefileResult> getDomainZonefile(GetDomainZonefileArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDomainZonefile:getDomainZonefile", TypeShape.of(GetDomainZonefileResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Domain Zonefile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain-zone).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Domain Zonefile.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainZonefileArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myZonefile = LinodeFunctions.getDomainZonefile(GetDomainZonefileArgs.builder()
     *             .domainId(3150401)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetDomainZonefileResult> getDomainZonefile(GetDomainZonefileArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDomainZonefile:getDomainZonefile", TypeShape.of(GetDomainZonefileResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Domain Zonefile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domain-zone).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Domain Zonefile.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainZonefileArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myZonefile = LinodeFunctions.getDomainZonefile(GetDomainZonefileArgs.builder()
     *             .domainId(3150401)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetDomainZonefileResult> getDomainZonefilePlain(GetDomainZonefilePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDomainZonefile:getDomainZonefile", TypeShape.of(GetDomainZonefileResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Domains that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domains).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Domains with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getDomains(GetDomainsArgs.builder()
     *             .filters(GetDomainsFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("domain", specific.domains()[0].domain());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `tags`
     * 
     * * `domain`
     * 
     * * `type`
     * 
     * * `status`
     * 
     * * `description`
     * 
     * * `master_ips`
     * 
     * * `axfr_ips`
     * 
     * * `ttl_sec`
     * 
     * * `retry_sec`
     * 
     * * `expire_sec`
     * 
     * * `refresh_sec`
     * 
     * * `soa_email`
     * 
     */
    public static Output<GetDomainsResult> getDomains() {
        return getDomains(GetDomainsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Domains that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domains).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Domains with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getDomains(GetDomainsArgs.builder()
     *             .filters(GetDomainsFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("domain", specific.domains()[0].domain());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `tags`
     * 
     * * `domain`
     * 
     * * `type`
     * 
     * * `status`
     * 
     * * `description`
     * 
     * * `master_ips`
     * 
     * * `axfr_ips`
     * 
     * * `ttl_sec`
     * 
     * * `retry_sec`
     * 
     * * `expire_sec`
     * 
     * * `refresh_sec`
     * 
     * * `soa_email`
     * 
     */
    public static CompletableFuture<GetDomainsResult> getDomainsPlain() {
        return getDomainsPlain(GetDomainsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Domains that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domains).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Domains with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getDomains(GetDomainsArgs.builder()
     *             .filters(GetDomainsFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("domain", specific.domains()[0].domain());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `tags`
     * 
     * * `domain`
     * 
     * * `type`
     * 
     * * `status`
     * 
     * * `description`
     * 
     * * `master_ips`
     * 
     * * `axfr_ips`
     * 
     * * `ttl_sec`
     * 
     * * `retry_sec`
     * 
     * * `expire_sec`
     * 
     * * `refresh_sec`
     * 
     * * `soa_email`
     * 
     */
    public static Output<GetDomainsResult> getDomains(GetDomainsArgs args) {
        return getDomains(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Domains that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domains).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Domains with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getDomains(GetDomainsArgs.builder()
     *             .filters(GetDomainsFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("domain", specific.domains()[0].domain());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `tags`
     * 
     * * `domain`
     * 
     * * `type`
     * 
     * * `status`
     * 
     * * `description`
     * 
     * * `master_ips`
     * 
     * * `axfr_ips`
     * 
     * * `ttl_sec`
     * 
     * * `retry_sec`
     * 
     * * `expire_sec`
     * 
     * * `refresh_sec`
     * 
     * * `soa_email`
     * 
     */
    public static CompletableFuture<GetDomainsResult> getDomainsPlain(GetDomainsPlainArgs args) {
        return getDomainsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Domains that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domains).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Domains with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getDomains(GetDomainsArgs.builder()
     *             .filters(GetDomainsFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("domain", specific.domains()[0].domain());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `tags`
     * 
     * * `domain`
     * 
     * * `type`
     * 
     * * `status`
     * 
     * * `description`
     * 
     * * `master_ips`
     * 
     * * `axfr_ips`
     * 
     * * `ttl_sec`
     * 
     * * `retry_sec`
     * 
     * * `expire_sec`
     * 
     * * `refresh_sec`
     * 
     * * `soa_email`
     * 
     */
    public static Output<GetDomainsResult> getDomains(GetDomainsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDomains:getDomains", TypeShape.of(GetDomainsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Domains that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domains).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Domains with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getDomains(GetDomainsArgs.builder()
     *             .filters(GetDomainsFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("domain", specific.domains()[0].domain());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `tags`
     * 
     * * `domain`
     * 
     * * `type`
     * 
     * * `status`
     * 
     * * `description`
     * 
     * * `master_ips`
     * 
     * * `axfr_ips`
     * 
     * * `ttl_sec`
     * 
     * * `retry_sec`
     * 
     * * `expire_sec`
     * 
     * * `refresh_sec`
     * 
     * * `soa_email`
     * 
     */
    public static Output<GetDomainsResult> getDomains(GetDomainsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getDomains:getDomains", TypeShape.of(GetDomainsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Domains that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-domains).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Domains with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetDomainsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getDomains(GetDomainsArgs.builder()
     *             .filters(GetDomainsFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("domain", specific.domains()[0].domain());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `tags`
     * 
     * * `domain`
     * 
     * * `type`
     * 
     * * `status`
     * 
     * * `description`
     * 
     * * `master_ips`
     * 
     * * `axfr_ips`
     * 
     * * `ttl_sec`
     * 
     * * `retry_sec`
     * 
     * * `expire_sec`
     * 
     * * `refresh_sec`
     * 
     * * `soa_email`
     * 
     */
    public static CompletableFuture<GetDomainsResult> getDomainsPlain(GetDomainsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getDomains:getDomains", TypeShape.of(GetDomainsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode Firewall.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewall).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-firewall = LinodeFunctions.getFirewall(GetFirewallArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetFirewallResult> getFirewall(GetFirewallArgs args) {
        return getFirewall(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a Linode Firewall.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewall).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-firewall = LinodeFunctions.getFirewall(GetFirewallArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetFirewallResult> getFirewallPlain(GetFirewallPlainArgs args) {
        return getFirewallPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a Linode Firewall.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewall).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-firewall = LinodeFunctions.getFirewall(GetFirewallArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetFirewallResult> getFirewall(GetFirewallArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getFirewall:getFirewall", TypeShape.of(GetFirewallResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode Firewall.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewall).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-firewall = LinodeFunctions.getFirewall(GetFirewallArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetFirewallResult> getFirewall(GetFirewallArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getFirewall:getFirewall", TypeShape.of(GetFirewallResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode Firewall.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewall).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-firewall = LinodeFunctions.getFirewall(GetFirewallArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetFirewallResult> getFirewallPlain(GetFirewallPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getFirewall:getFirewall", TypeShape.of(GetFirewallResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Cloud Firewalls that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewalls).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Firewalls with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .filters(            
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-firewalls")
     *                     .build(),
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("firewallId", specific.firewalls()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .build());
     * 
     *         ctx.export("firewallIds", all.firewalls().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Firewall Rule
     * 
     * * `label` - The label of this rule for display purposes only.
     * 
     * * `action` - Controls whether traffic is accepted or dropped by this rule (ACCEPT, DROP).
     * 
     * * `protocol` - The network protocol this rule controls. (TCP, UDP, ICMP)
     * 
     * * `ports` - A string representation of ports and/or port ranges (i.e. &#34;443&#34; or &#34;80-90, 91&#34;).
     * 
     * * `ipv4` - A list of IPv4 addresses or networks in IP/mask format.
     * 
     * * `ipv6` - A list of IPv6 addresses or networks in IP/mask format.
     * 
     * ## Firewall Device
     * 
     * * `id` - The unique ID of this Firewall Device assignment.
     * 
     * * `entity_id` - The ID of the underlying entity this device references.
     * 
     * * `type` - The type of the assigned entity.
     * 
     * * `label` - The label of the assigned entity.
     * 
     * * `url` - The URL of the assigned entity.
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     */
    public static Output<GetFirewallsResult> getFirewalls() {
        return getFirewalls(GetFirewallsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Cloud Firewalls that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewalls).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Firewalls with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .filters(            
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-firewalls")
     *                     .build(),
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("firewallId", specific.firewalls()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .build());
     * 
     *         ctx.export("firewallIds", all.firewalls().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Firewall Rule
     * 
     * * `label` - The label of this rule for display purposes only.
     * 
     * * `action` - Controls whether traffic is accepted or dropped by this rule (ACCEPT, DROP).
     * 
     * * `protocol` - The network protocol this rule controls. (TCP, UDP, ICMP)
     * 
     * * `ports` - A string representation of ports and/or port ranges (i.e. &#34;443&#34; or &#34;80-90, 91&#34;).
     * 
     * * `ipv4` - A list of IPv4 addresses or networks in IP/mask format.
     * 
     * * `ipv6` - A list of IPv6 addresses or networks in IP/mask format.
     * 
     * ## Firewall Device
     * 
     * * `id` - The unique ID of this Firewall Device assignment.
     * 
     * * `entity_id` - The ID of the underlying entity this device references.
     * 
     * * `type` - The type of the assigned entity.
     * 
     * * `label` - The label of the assigned entity.
     * 
     * * `url` - The URL of the assigned entity.
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     */
    public static CompletableFuture<GetFirewallsResult> getFirewallsPlain() {
        return getFirewallsPlain(GetFirewallsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Cloud Firewalls that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewalls).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Firewalls with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .filters(            
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-firewalls")
     *                     .build(),
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("firewallId", specific.firewalls()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .build());
     * 
     *         ctx.export("firewallIds", all.firewalls().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Firewall Rule
     * 
     * * `label` - The label of this rule for display purposes only.
     * 
     * * `action` - Controls whether traffic is accepted or dropped by this rule (ACCEPT, DROP).
     * 
     * * `protocol` - The network protocol this rule controls. (TCP, UDP, ICMP)
     * 
     * * `ports` - A string representation of ports and/or port ranges (i.e. &#34;443&#34; or &#34;80-90, 91&#34;).
     * 
     * * `ipv4` - A list of IPv4 addresses or networks in IP/mask format.
     * 
     * * `ipv6` - A list of IPv6 addresses or networks in IP/mask format.
     * 
     * ## Firewall Device
     * 
     * * `id` - The unique ID of this Firewall Device assignment.
     * 
     * * `entity_id` - The ID of the underlying entity this device references.
     * 
     * * `type` - The type of the assigned entity.
     * 
     * * `label` - The label of the assigned entity.
     * 
     * * `url` - The URL of the assigned entity.
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     */
    public static Output<GetFirewallsResult> getFirewalls(GetFirewallsArgs args) {
        return getFirewalls(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Cloud Firewalls that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewalls).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Firewalls with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .filters(            
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-firewalls")
     *                     .build(),
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("firewallId", specific.firewalls()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .build());
     * 
     *         ctx.export("firewallIds", all.firewalls().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Firewall Rule
     * 
     * * `label` - The label of this rule for display purposes only.
     * 
     * * `action` - Controls whether traffic is accepted or dropped by this rule (ACCEPT, DROP).
     * 
     * * `protocol` - The network protocol this rule controls. (TCP, UDP, ICMP)
     * 
     * * `ports` - A string representation of ports and/or port ranges (i.e. &#34;443&#34; or &#34;80-90, 91&#34;).
     * 
     * * `ipv4` - A list of IPv4 addresses or networks in IP/mask format.
     * 
     * * `ipv6` - A list of IPv6 addresses or networks in IP/mask format.
     * 
     * ## Firewall Device
     * 
     * * `id` - The unique ID of this Firewall Device assignment.
     * 
     * * `entity_id` - The ID of the underlying entity this device references.
     * 
     * * `type` - The type of the assigned entity.
     * 
     * * `label` - The label of the assigned entity.
     * 
     * * `url` - The URL of the assigned entity.
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     */
    public static CompletableFuture<GetFirewallsResult> getFirewallsPlain(GetFirewallsPlainArgs args) {
        return getFirewallsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Cloud Firewalls that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewalls).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Firewalls with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .filters(            
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-firewalls")
     *                     .build(),
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("firewallId", specific.firewalls()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .build());
     * 
     *         ctx.export("firewallIds", all.firewalls().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Firewall Rule
     * 
     * * `label` - The label of this rule for display purposes only.
     * 
     * * `action` - Controls whether traffic is accepted or dropped by this rule (ACCEPT, DROP).
     * 
     * * `protocol` - The network protocol this rule controls. (TCP, UDP, ICMP)
     * 
     * * `ports` - A string representation of ports and/or port ranges (i.e. &#34;443&#34; or &#34;80-90, 91&#34;).
     * 
     * * `ipv4` - A list of IPv4 addresses or networks in IP/mask format.
     * 
     * * `ipv6` - A list of IPv6 addresses or networks in IP/mask format.
     * 
     * ## Firewall Device
     * 
     * * `id` - The unique ID of this Firewall Device assignment.
     * 
     * * `entity_id` - The ID of the underlying entity this device references.
     * 
     * * `type` - The type of the assigned entity.
     * 
     * * `label` - The label of the assigned entity.
     * 
     * * `url` - The URL of the assigned entity.
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     */
    public static Output<GetFirewallsResult> getFirewalls(GetFirewallsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getFirewalls:getFirewalls", TypeShape.of(GetFirewallsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Cloud Firewalls that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewalls).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Firewalls with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .filters(            
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-firewalls")
     *                     .build(),
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("firewallId", specific.firewalls()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .build());
     * 
     *         ctx.export("firewallIds", all.firewalls().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Firewall Rule
     * 
     * * `label` - The label of this rule for display purposes only.
     * 
     * * `action` - Controls whether traffic is accepted or dropped by this rule (ACCEPT, DROP).
     * 
     * * `protocol` - The network protocol this rule controls. (TCP, UDP, ICMP)
     * 
     * * `ports` - A string representation of ports and/or port ranges (i.e. &#34;443&#34; or &#34;80-90, 91&#34;).
     * 
     * * `ipv4` - A list of IPv4 addresses or networks in IP/mask format.
     * 
     * * `ipv6` - A list of IPv6 addresses or networks in IP/mask format.
     * 
     * ## Firewall Device
     * 
     * * `id` - The unique ID of this Firewall Device assignment.
     * 
     * * `entity_id` - The ID of the underlying entity this device references.
     * 
     * * `type` - The type of the assigned entity.
     * 
     * * `label` - The label of the assigned entity.
     * 
     * * `url` - The URL of the assigned entity.
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     */
    public static Output<GetFirewallsResult> getFirewalls(GetFirewallsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getFirewalls:getFirewalls", TypeShape.of(GetFirewallsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Cloud Firewalls that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-firewalls).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Cloud Firewalls with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .filters(            
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-firewalls")
     *                     .build(),
     *                 GetFirewallsFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("firewallId", specific.firewalls()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetFirewallsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getFirewalls(GetFirewallsArgs.builder()
     *             .build());
     * 
     *         ctx.export("firewallIds", all.firewalls().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Firewall Rule
     * 
     * * `label` - The label of this rule for display purposes only.
     * 
     * * `action` - Controls whether traffic is accepted or dropped by this rule (ACCEPT, DROP).
     * 
     * * `protocol` - The network protocol this rule controls. (TCP, UDP, ICMP)
     * 
     * * `ports` - A string representation of ports and/or port ranges (i.e. &#34;443&#34; or &#34;80-90, 91&#34;).
     * 
     * * `ipv4` - A list of IPv4 addresses or networks in IP/mask format.
     * 
     * * `ipv6` - A list of IPv6 addresses or networks in IP/mask format.
     * 
     * ## Firewall Device
     * 
     * * `id` - The unique ID of this Firewall Device assignment.
     * 
     * * `entity_id` - The ID of the underlying entity this device references.
     * 
     * * `type` - The type of the assigned entity.
     * 
     * * `label` - The label of the assigned entity.
     * 
     * * `url` - The URL of the assigned entity.
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     */
    public static CompletableFuture<GetFirewallsResult> getFirewallsPlain(GetFirewallsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getFirewalls:getFirewalls", TypeShape.of(GetFirewallsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode image
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-image).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode image.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImageArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var k8Master = LinodeFunctions.getImage(GetImageArgs.builder()
     *             .id("linode/debian12")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetImageResult> getImage(GetImageArgs args) {
        return getImage(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode image
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-image).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode image.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImageArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var k8Master = LinodeFunctions.getImage(GetImageArgs.builder()
     *             .id("linode/debian12")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetImageResult> getImagePlain(GetImagePlainArgs args) {
        return getImagePlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode image
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-image).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode image.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImageArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var k8Master = LinodeFunctions.getImage(GetImageArgs.builder()
     *             .id("linode/debian12")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetImageResult> getImage(GetImageArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getImage:getImage", TypeShape.of(GetImageResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode image
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-image).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode image.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImageArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var k8Master = LinodeFunctions.getImage(GetImageArgs.builder()
     *             .id("linode/debian12")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetImageResult> getImage(GetImageArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getImage:getImage", TypeShape.of(GetImageResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode image
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-image).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode image.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImageArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var k8Master = LinodeFunctions.getImage(GetImageArgs.builder()
     *             .id("linode/debian12")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetImageResult> getImagePlain(GetImagePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getImage:getImage", TypeShape.of(GetImageResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode images that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-images).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode images with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .filters(            
     *                 GetImagesFilterArgs.builder()
     *                     .name("label")
     *                     .values("Debian 12")
     *                     .build(),
     *                 GetImagesFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("true")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("imageId", specific_images.images()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .build());
     * 
     *         ctx.export("imageIds", all_images.images().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `created_by`
     * 
     * * `deprecated`
     * 
     * * `description`
     * 
     * * `id`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `size`
     * 
     * * `status`
     * 
     * * `vendor`
     * 
     * * `tags`
     * 
     */
    public static Output<GetImagesResult> getImages() {
        return getImages(GetImagesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode images that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-images).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode images with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .filters(            
     *                 GetImagesFilterArgs.builder()
     *                     .name("label")
     *                     .values("Debian 12")
     *                     .build(),
     *                 GetImagesFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("true")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("imageId", specific_images.images()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .build());
     * 
     *         ctx.export("imageIds", all_images.images().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `created_by`
     * 
     * * `deprecated`
     * 
     * * `description`
     * 
     * * `id`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `size`
     * 
     * * `status`
     * 
     * * `vendor`
     * 
     * * `tags`
     * 
     */
    public static CompletableFuture<GetImagesResult> getImagesPlain() {
        return getImagesPlain(GetImagesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode images that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-images).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode images with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .filters(            
     *                 GetImagesFilterArgs.builder()
     *                     .name("label")
     *                     .values("Debian 12")
     *                     .build(),
     *                 GetImagesFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("true")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("imageId", specific_images.images()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .build());
     * 
     *         ctx.export("imageIds", all_images.images().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `created_by`
     * 
     * * `deprecated`
     * 
     * * `description`
     * 
     * * `id`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `size`
     * 
     * * `status`
     * 
     * * `vendor`
     * 
     * * `tags`
     * 
     */
    public static Output<GetImagesResult> getImages(GetImagesArgs args) {
        return getImages(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode images that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-images).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode images with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .filters(            
     *                 GetImagesFilterArgs.builder()
     *                     .name("label")
     *                     .values("Debian 12")
     *                     .build(),
     *                 GetImagesFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("true")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("imageId", specific_images.images()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .build());
     * 
     *         ctx.export("imageIds", all_images.images().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `created_by`
     * 
     * * `deprecated`
     * 
     * * `description`
     * 
     * * `id`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `size`
     * 
     * * `status`
     * 
     * * `vendor`
     * 
     * * `tags`
     * 
     */
    public static CompletableFuture<GetImagesResult> getImagesPlain(GetImagesPlainArgs args) {
        return getImagesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode images that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-images).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode images with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .filters(            
     *                 GetImagesFilterArgs.builder()
     *                     .name("label")
     *                     .values("Debian 12")
     *                     .build(),
     *                 GetImagesFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("true")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("imageId", specific_images.images()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .build());
     * 
     *         ctx.export("imageIds", all_images.images().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `created_by`
     * 
     * * `deprecated`
     * 
     * * `description`
     * 
     * * `id`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `size`
     * 
     * * `status`
     * 
     * * `vendor`
     * 
     * * `tags`
     * 
     */
    public static Output<GetImagesResult> getImages(GetImagesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getImages:getImages", TypeShape.of(GetImagesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode images that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-images).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode images with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .filters(            
     *                 GetImagesFilterArgs.builder()
     *                     .name("label")
     *                     .values("Debian 12")
     *                     .build(),
     *                 GetImagesFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("true")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("imageId", specific_images.images()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .build());
     * 
     *         ctx.export("imageIds", all_images.images().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `created_by`
     * 
     * * `deprecated`
     * 
     * * `description`
     * 
     * * `id`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `size`
     * 
     * * `status`
     * 
     * * `vendor`
     * 
     * * `tags`
     * 
     */
    public static Output<GetImagesResult> getImages(GetImagesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getImages:getImages", TypeShape.of(GetImagesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode images that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-images).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode images with a certain label and visibility:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .filters(            
     *                 GetImagesFilterArgs.builder()
     *                     .name("label")
     *                     .values("Debian 12")
     *                     .build(),
     *                 GetImagesFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("true")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("imageId", specific_images.images()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode images associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetImagesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-images = LinodeFunctions.getImages(GetImagesArgs.builder()
     *             .build());
     * 
     *         ctx.export("imageIds", all_images.images().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `created_by`
     * 
     * * `deprecated`
     * 
     * * `description`
     * 
     * * `id`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `size`
     * 
     * * `status`
     * 
     * * `vendor`
     * 
     * * `tags`
     * 
     */
    public static CompletableFuture<GetImagesResult> getImagesPlain(GetImagesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getImages:getImages", TypeShape.of(GetImagesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about the backups of an Instance.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-backups).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-backups = LinodeFunctions.getInstanceBackups(GetInstanceBackupsArgs.builder()
     *             .linodeId(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetInstanceBackupsResult> getInstanceBackups(GetInstanceBackupsArgs args) {
        return getInstanceBackups(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about the backups of an Instance.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-backups).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-backups = LinodeFunctions.getInstanceBackups(GetInstanceBackupsArgs.builder()
     *             .linodeId(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetInstanceBackupsResult> getInstanceBackupsPlain(GetInstanceBackupsPlainArgs args) {
        return getInstanceBackupsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about the backups of an Instance.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-backups).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-backups = LinodeFunctions.getInstanceBackups(GetInstanceBackupsArgs.builder()
     *             .linodeId(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetInstanceBackupsResult> getInstanceBackups(GetInstanceBackupsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getInstanceBackups:getInstanceBackups", TypeShape.of(GetInstanceBackupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about the backups of an Instance.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-backups).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-backups = LinodeFunctions.getInstanceBackups(GetInstanceBackupsArgs.builder()
     *             .linodeId(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetInstanceBackupsResult> getInstanceBackups(GetInstanceBackupsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getInstanceBackups:getInstanceBackups", TypeShape.of(GetInstanceBackupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about the backups of an Instance.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-backups).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceBackupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-backups = LinodeFunctions.getInstanceBackups(GetInstanceBackupsArgs.builder()
     *             .linodeId(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetInstanceBackupsResult> getInstanceBackupsPlain(GetInstanceBackupsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getInstanceBackups:getInstanceBackups", TypeShape.of(GetInstanceBackupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about the networking configuration of an Instance.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-config-interfaces).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceNetworkingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getInstanceNetworking(GetInstanceNetworkingArgs.builder()
     *             .linodeId(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetInstanceNetworkingResult> getInstanceNetworking(GetInstanceNetworkingArgs args) {
        return getInstanceNetworking(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about the networking configuration of an Instance.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-config-interfaces).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceNetworkingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getInstanceNetworking(GetInstanceNetworkingArgs.builder()
     *             .linodeId(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetInstanceNetworkingResult> getInstanceNetworkingPlain(GetInstanceNetworkingPlainArgs args) {
        return getInstanceNetworkingPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about the networking configuration of an Instance.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-config-interfaces).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceNetworkingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getInstanceNetworking(GetInstanceNetworkingArgs.builder()
     *             .linodeId(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetInstanceNetworkingResult> getInstanceNetworking(GetInstanceNetworkingArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getInstanceNetworking:getInstanceNetworking", TypeShape.of(GetInstanceNetworkingResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about the networking configuration of an Instance.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-config-interfaces).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceNetworkingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getInstanceNetworking(GetInstanceNetworkingArgs.builder()
     *             .linodeId(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetInstanceNetworkingResult> getInstanceNetworking(GetInstanceNetworkingArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getInstanceNetworking:getInstanceNetworking", TypeShape.of(GetInstanceNetworkingResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about the networking configuration of an Instance.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-config-interfaces).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceNetworkingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getInstanceNetworking(GetInstanceNetworkingArgs.builder()
     *             .linodeId(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetInstanceNetworkingResult> getInstanceNetworkingPlain(GetInstanceNetworkingPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getInstanceNetworking:getInstanceNetworking", TypeShape.of(GetInstanceNetworkingResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode instance type
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-type).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Instance type.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var default = LinodeFunctions.getInstanceType(GetInstanceTypeArgs.builder()
     *             .id("g6-standard-2")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetInstanceTypeResult> getInstanceType(GetInstanceTypeArgs args) {
        return getInstanceType(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode instance type
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-type).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Instance type.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var default = LinodeFunctions.getInstanceType(GetInstanceTypeArgs.builder()
     *             .id("g6-standard-2")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetInstanceTypeResult> getInstanceTypePlain(GetInstanceTypePlainArgs args) {
        return getInstanceTypePlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode instance type
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-type).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Instance type.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var default = LinodeFunctions.getInstanceType(GetInstanceTypeArgs.builder()
     *             .id("g6-standard-2")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetInstanceTypeResult> getInstanceType(GetInstanceTypeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getInstanceType:getInstanceType", TypeShape.of(GetInstanceTypeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode instance type
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-type).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Instance type.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var default = LinodeFunctions.getInstanceType(GetInstanceTypeArgs.builder()
     *             .id("g6-standard-2")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetInstanceTypeResult> getInstanceType(GetInstanceTypeArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getInstanceType:getInstanceType", TypeShape.of(GetInstanceTypeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode instance type
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-type).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Instance type.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var default = LinodeFunctions.getInstanceType(GetInstanceTypeArgs.builder()
     *             .id("g6-standard-2")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetInstanceTypeResult> getInstanceTypePlain(GetInstanceTypePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getInstanceType:getInstanceType", TypeShape.of(GetInstanceTypeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Instance types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-types).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Instance types with a certain number of VCPUs:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .filters(GetInstanceTypesFilterArgs.builder()
     *                 .name("vcpus")
     *                 .values("2")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("typeIds", specific_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode Instance types:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .build());
     * 
     *         ctx.export("typeIds", all_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `class`
     * 
     * * `disk`
     * 
     * * `gpus`
     * 
     * * `label`
     * 
     * * `memory`
     * 
     * * `network_out`
     * 
     * * `transfer`
     * 
     * * `vcpus`
     * 
     */
    public static Output<GetInstanceTypesResult> getInstanceTypes() {
        return getInstanceTypes(GetInstanceTypesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Instance types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-types).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Instance types with a certain number of VCPUs:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .filters(GetInstanceTypesFilterArgs.builder()
     *                 .name("vcpus")
     *                 .values("2")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("typeIds", specific_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode Instance types:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .build());
     * 
     *         ctx.export("typeIds", all_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `class`
     * 
     * * `disk`
     * 
     * * `gpus`
     * 
     * * `label`
     * 
     * * `memory`
     * 
     * * `network_out`
     * 
     * * `transfer`
     * 
     * * `vcpus`
     * 
     */
    public static CompletableFuture<GetInstanceTypesResult> getInstanceTypesPlain() {
        return getInstanceTypesPlain(GetInstanceTypesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Instance types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-types).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Instance types with a certain number of VCPUs:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .filters(GetInstanceTypesFilterArgs.builder()
     *                 .name("vcpus")
     *                 .values("2")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("typeIds", specific_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode Instance types:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .build());
     * 
     *         ctx.export("typeIds", all_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `class`
     * 
     * * `disk`
     * 
     * * `gpus`
     * 
     * * `label`
     * 
     * * `memory`
     * 
     * * `network_out`
     * 
     * * `transfer`
     * 
     * * `vcpus`
     * 
     */
    public static Output<GetInstanceTypesResult> getInstanceTypes(GetInstanceTypesArgs args) {
        return getInstanceTypes(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Instance types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-types).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Instance types with a certain number of VCPUs:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .filters(GetInstanceTypesFilterArgs.builder()
     *                 .name("vcpus")
     *                 .values("2")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("typeIds", specific_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode Instance types:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .build());
     * 
     *         ctx.export("typeIds", all_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `class`
     * 
     * * `disk`
     * 
     * * `gpus`
     * 
     * * `label`
     * 
     * * `memory`
     * 
     * * `network_out`
     * 
     * * `transfer`
     * 
     * * `vcpus`
     * 
     */
    public static CompletableFuture<GetInstanceTypesResult> getInstanceTypesPlain(GetInstanceTypesPlainArgs args) {
        return getInstanceTypesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Instance types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-types).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Instance types with a certain number of VCPUs:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .filters(GetInstanceTypesFilterArgs.builder()
     *                 .name("vcpus")
     *                 .values("2")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("typeIds", specific_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode Instance types:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .build());
     * 
     *         ctx.export("typeIds", all_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `class`
     * 
     * * `disk`
     * 
     * * `gpus`
     * 
     * * `label`
     * 
     * * `memory`
     * 
     * * `network_out`
     * 
     * * `transfer`
     * 
     * * `vcpus`
     * 
     */
    public static Output<GetInstanceTypesResult> getInstanceTypes(GetInstanceTypesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getInstanceTypes:getInstanceTypes", TypeShape.of(GetInstanceTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Instance types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-types).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Instance types with a certain number of VCPUs:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .filters(GetInstanceTypesFilterArgs.builder()
     *                 .name("vcpus")
     *                 .values("2")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("typeIds", specific_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode Instance types:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .build());
     * 
     *         ctx.export("typeIds", all_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `class`
     * 
     * * `disk`
     * 
     * * `gpus`
     * 
     * * `label`
     * 
     * * `memory`
     * 
     * * `network_out`
     * 
     * * `transfer`
     * 
     * * `vcpus`
     * 
     */
    public static Output<GetInstanceTypesResult> getInstanceTypes(GetInstanceTypesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getInstanceTypes:getInstanceTypes", TypeShape.of(GetInstanceTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Instance types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-types).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode Instance types with a certain number of VCPUs:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .filters(GetInstanceTypesFilterArgs.builder()
     *                 .name("vcpus")
     *                 .values("2")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("typeIds", specific_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode Instance types:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstanceTypesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-types = LinodeFunctions.getInstanceTypes(GetInstanceTypesArgs.builder()
     *             .build());
     * 
     *         ctx.export("typeIds", all_types.types().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `class`
     * 
     * * `disk`
     * 
     * * `gpus`
     * 
     * * `label`
     * 
     * * `memory`
     * 
     * * `network_out`
     * 
     * * `transfer`
     * 
     * * `vcpus`
     * 
     */
    public static CompletableFuture<GetInstanceTypesResult> getInstanceTypesPlain(GetInstanceTypesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getInstanceTypes:getInstanceTypes", TypeShape.of(GetInstanceTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode instances that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode instances with a certain label and tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .filters(            
     *                 GetInstancesFilterArgs.builder()
     *                     .name("label")
     *                     .values(                    
     *                         "my-label",
     *                         "my-other-label")
     *                     .build(),
     *                 GetInstancesFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("instanceId", my_instances.instances()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode instances associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .build());
     * 
     *         ctx.export("instanceIds", all_instances.instances().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `id`
     * 
     * * `image`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     * * `type`
     * 
     * * `watchdog_enabled`
     * 
     */
    public static Output<GetInstancesResult> getInstances() {
        return getInstances(GetInstancesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode instances that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode instances with a certain label and tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .filters(            
     *                 GetInstancesFilterArgs.builder()
     *                     .name("label")
     *                     .values(                    
     *                         "my-label",
     *                         "my-other-label")
     *                     .build(),
     *                 GetInstancesFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("instanceId", my_instances.instances()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode instances associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .build());
     * 
     *         ctx.export("instanceIds", all_instances.instances().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `id`
     * 
     * * `image`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     * * `type`
     * 
     * * `watchdog_enabled`
     * 
     */
    public static CompletableFuture<GetInstancesResult> getInstancesPlain() {
        return getInstancesPlain(GetInstancesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode instances that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode instances with a certain label and tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .filters(            
     *                 GetInstancesFilterArgs.builder()
     *                     .name("label")
     *                     .values(                    
     *                         "my-label",
     *                         "my-other-label")
     *                     .build(),
     *                 GetInstancesFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("instanceId", my_instances.instances()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode instances associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .build());
     * 
     *         ctx.export("instanceIds", all_instances.instances().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `id`
     * 
     * * `image`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     * * `type`
     * 
     * * `watchdog_enabled`
     * 
     */
    public static Output<GetInstancesResult> getInstances(GetInstancesArgs args) {
        return getInstances(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode instances that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode instances with a certain label and tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .filters(            
     *                 GetInstancesFilterArgs.builder()
     *                     .name("label")
     *                     .values(                    
     *                         "my-label",
     *                         "my-other-label")
     *                     .build(),
     *                 GetInstancesFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("instanceId", my_instances.instances()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode instances associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .build());
     * 
     *         ctx.export("instanceIds", all_instances.instances().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `id`
     * 
     * * `image`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     * * `type`
     * 
     * * `watchdog_enabled`
     * 
     */
    public static CompletableFuture<GetInstancesResult> getInstancesPlain(GetInstancesPlainArgs args) {
        return getInstancesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode instances that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode instances with a certain label and tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .filters(            
     *                 GetInstancesFilterArgs.builder()
     *                     .name("label")
     *                     .values(                    
     *                         "my-label",
     *                         "my-other-label")
     *                     .build(),
     *                 GetInstancesFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("instanceId", my_instances.instances()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode instances associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .build());
     * 
     *         ctx.export("instanceIds", all_instances.instances().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `id`
     * 
     * * `image`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     * * `type`
     * 
     * * `watchdog_enabled`
     * 
     */
    public static Output<GetInstancesResult> getInstances(GetInstancesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getInstances:getInstances", TypeShape.of(GetInstancesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode instances that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode instances with a certain label and tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .filters(            
     *                 GetInstancesFilterArgs.builder()
     *                     .name("label")
     *                     .values(                    
     *                         "my-label",
     *                         "my-other-label")
     *                     .build(),
     *                 GetInstancesFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("instanceId", my_instances.instances()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode instances associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .build());
     * 
     *         ctx.export("instanceIds", all_instances.instances().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `id`
     * 
     * * `image`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     * * `type`
     * 
     * * `watchdog_enabled`
     * 
     */
    public static Output<GetInstancesResult> getInstances(GetInstancesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getInstances:getInstances", TypeShape.of(GetInstancesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode instances that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-linode-instances).
     * 
     * ## Example Usage
     * 
     * Get information about all Linode instances with a certain label and tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .filters(            
     *                 GetInstancesFilterArgs.builder()
     *                     .name("label")
     *                     .values(                    
     *                         "my-label",
     *                         "my-other-label")
     *                     .build(),
     *                 GetInstancesFilterArgs.builder()
     *                     .name("tags")
     *                     .values("my-tag")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("instanceId", my_instances.instances()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get information about all Linode instances associated with the current token:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetInstancesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all-instances = LinodeFunctions.getInstances(GetInstancesArgs.builder()
     *             .build());
     * 
     *         ctx.export("instanceIds", all_instances.instances().stream().map(element -> element.id()).collect(toList()));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `group`
     * 
     * * `id`
     * 
     * * `image`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `status`
     * 
     * * `tags`
     * 
     * * `type`
     * 
     * * `watchdog_enabled`
     * 
     */
    public static CompletableFuture<GetInstancesResult> getInstancesPlain(GetInstancesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getInstances:getInstances", TypeShape.of(GetInstancesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode IPv6 Range.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-range).
     * 
     * ## Example Usage
     * 
     * Get information about an IPv6 range assigned to a Linode:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var range-info = LinodeFunctions.getIpv6Range(GetIpv6RangeArgs.builder()
     *             .range("2001:0db8::")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetIpv6RangeResult> getIpv6Range(GetIpv6RangeArgs args) {
        return getIpv6Range(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode IPv6 Range.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-range).
     * 
     * ## Example Usage
     * 
     * Get information about an IPv6 range assigned to a Linode:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var range-info = LinodeFunctions.getIpv6Range(GetIpv6RangeArgs.builder()
     *             .range("2001:0db8::")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetIpv6RangeResult> getIpv6RangePlain(GetIpv6RangePlainArgs args) {
        return getIpv6RangePlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode IPv6 Range.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-range).
     * 
     * ## Example Usage
     * 
     * Get information about an IPv6 range assigned to a Linode:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var range-info = LinodeFunctions.getIpv6Range(GetIpv6RangeArgs.builder()
     *             .range("2001:0db8::")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetIpv6RangeResult> getIpv6Range(GetIpv6RangeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getIpv6Range:getIpv6Range", TypeShape.of(GetIpv6RangeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode IPv6 Range.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-range).
     * 
     * ## Example Usage
     * 
     * Get information about an IPv6 range assigned to a Linode:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var range-info = LinodeFunctions.getIpv6Range(GetIpv6RangeArgs.builder()
     *             .range("2001:0db8::")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetIpv6RangeResult> getIpv6Range(GetIpv6RangeArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getIpv6Range:getIpv6Range", TypeShape.of(GetIpv6RangeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode IPv6 Range.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-range).
     * 
     * ## Example Usage
     * 
     * Get information about an IPv6 range assigned to a Linode:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var range-info = LinodeFunctions.getIpv6Range(GetIpv6RangeArgs.builder()
     *             .range("2001:0db8::")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetIpv6RangeResult> getIpv6RangePlain(GetIpv6RangePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getIpv6Range:getIpv6Range", TypeShape.of(GetIpv6RangeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode IPv6 ranges that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-ranges).
     * 
     * &gt; Some fields may not be accessible directly the results of this data source.
     * For additional information about a specific IPv6 range consider using the linode.Ipv6Range
     * data source.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ranges = LinodeFunctions.getIpv6Ranges(GetIpv6RangesArgs.builder()
     *             .filters(GetIpv6RangesFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("ranges", filtered_ranges);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `range`
     * 
     * * `route_target`
     * 
     * * `prefix`
     * 
     * * `region`
     * 
     */
    public static Output<GetIpv6RangesResult> getIpv6Ranges() {
        return getIpv6Ranges(GetIpv6RangesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode IPv6 ranges that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-ranges).
     * 
     * &gt; Some fields may not be accessible directly the results of this data source.
     * For additional information about a specific IPv6 range consider using the linode.Ipv6Range
     * data source.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ranges = LinodeFunctions.getIpv6Ranges(GetIpv6RangesArgs.builder()
     *             .filters(GetIpv6RangesFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("ranges", filtered_ranges);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `range`
     * 
     * * `route_target`
     * 
     * * `prefix`
     * 
     * * `region`
     * 
     */
    public static CompletableFuture<GetIpv6RangesResult> getIpv6RangesPlain() {
        return getIpv6RangesPlain(GetIpv6RangesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode IPv6 ranges that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-ranges).
     * 
     * &gt; Some fields may not be accessible directly the results of this data source.
     * For additional information about a specific IPv6 range consider using the linode.Ipv6Range
     * data source.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ranges = LinodeFunctions.getIpv6Ranges(GetIpv6RangesArgs.builder()
     *             .filters(GetIpv6RangesFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("ranges", filtered_ranges);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `range`
     * 
     * * `route_target`
     * 
     * * `prefix`
     * 
     * * `region`
     * 
     */
    public static Output<GetIpv6RangesResult> getIpv6Ranges(GetIpv6RangesArgs args) {
        return getIpv6Ranges(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode IPv6 ranges that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-ranges).
     * 
     * &gt; Some fields may not be accessible directly the results of this data source.
     * For additional information about a specific IPv6 range consider using the linode.Ipv6Range
     * data source.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ranges = LinodeFunctions.getIpv6Ranges(GetIpv6RangesArgs.builder()
     *             .filters(GetIpv6RangesFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("ranges", filtered_ranges);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `range`
     * 
     * * `route_target`
     * 
     * * `prefix`
     * 
     * * `region`
     * 
     */
    public static CompletableFuture<GetIpv6RangesResult> getIpv6RangesPlain(GetIpv6RangesPlainArgs args) {
        return getIpv6RangesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode IPv6 ranges that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-ranges).
     * 
     * &gt; Some fields may not be accessible directly the results of this data source.
     * For additional information about a specific IPv6 range consider using the linode.Ipv6Range
     * data source.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ranges = LinodeFunctions.getIpv6Ranges(GetIpv6RangesArgs.builder()
     *             .filters(GetIpv6RangesFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("ranges", filtered_ranges);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `range`
     * 
     * * `route_target`
     * 
     * * `prefix`
     * 
     * * `region`
     * 
     */
    public static Output<GetIpv6RangesResult> getIpv6Ranges(GetIpv6RangesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getIpv6Ranges:getIpv6Ranges", TypeShape.of(GetIpv6RangesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode IPv6 ranges that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-ranges).
     * 
     * &gt; Some fields may not be accessible directly the results of this data source.
     * For additional information about a specific IPv6 range consider using the linode.Ipv6Range
     * data source.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ranges = LinodeFunctions.getIpv6Ranges(GetIpv6RangesArgs.builder()
     *             .filters(GetIpv6RangesFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("ranges", filtered_ranges);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `range`
     * 
     * * `route_target`
     * 
     * * `prefix`
     * 
     * * `region`
     * 
     */
    public static Output<GetIpv6RangesResult> getIpv6Ranges(GetIpv6RangesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getIpv6Ranges:getIpv6Ranges", TypeShape.of(GetIpv6RangesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode IPv6 ranges that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ipv6-ranges).
     * 
     * &gt; Some fields may not be accessible directly the results of this data source.
     * For additional information about a specific IPv6 range consider using the linode.Ipv6Range
     * data source.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetIpv6RangesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ranges = LinodeFunctions.getIpv6Ranges(GetIpv6RangesArgs.builder()
     *             .filters(GetIpv6RangesFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("ranges", filtered_ranges);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `range`
     * 
     * * `route_target`
     * 
     * * `prefix`
     * 
     * * `region`
     * 
     */
    public static CompletableFuture<GetIpv6RangesResult> getIpv6RangesPlain(GetIpv6RangesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getIpv6Ranges:getIpv6Ranges", TypeShape.of(GetIpv6RangesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode kernel
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernel).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var latest = LinodeFunctions.getKernel(GetKernelArgs.builder()
     *             .id("linode/latest-64bit")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetKernelResult> getKernel(GetKernelArgs args) {
        return getKernel(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode kernel
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernel).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var latest = LinodeFunctions.getKernel(GetKernelArgs.builder()
     *             .id("linode/latest-64bit")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetKernelResult> getKernelPlain(GetKernelPlainArgs args) {
        return getKernelPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode kernel
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernel).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var latest = LinodeFunctions.getKernel(GetKernelArgs.builder()
     *             .id("linode/latest-64bit")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetKernelResult> getKernel(GetKernelArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getKernel:getKernel", TypeShape.of(GetKernelResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode kernel
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernel).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var latest = LinodeFunctions.getKernel(GetKernelArgs.builder()
     *             .id("linode/latest-64bit")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetKernelResult> getKernel(GetKernelArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getKernel:getKernel", TypeShape.of(GetKernelResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode kernel
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernel).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var latest = LinodeFunctions.getKernel(GetKernelArgs.builder()
     *             .id("linode/latest-64bit")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetKernelResult> getKernelPlain(GetKernelPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getKernel:getKernel", TypeShape.of(GetKernelResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Kernels that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernels).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredKernels = LinodeFunctions.getKernels(GetKernelsArgs.builder()
     *             .filters(            
     *                 GetKernelsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-kernel")
     *                     .build(),
     *                 GetKernelsFilterArgs.builder()
     *                     .name("architecture")
     *                     .values("x86_64")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `architecture`
     * 
     * * `deprecated`
     * 
     * * `kvm`
     * 
     * * `label`
     * 
     * * `pvops`
     * 
     * * `version`
     * 
     * * `xen`
     * 
     */
    public static Output<GetKernelsResult> getKernels() {
        return getKernels(GetKernelsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Kernels that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernels).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredKernels = LinodeFunctions.getKernels(GetKernelsArgs.builder()
     *             .filters(            
     *                 GetKernelsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-kernel")
     *                     .build(),
     *                 GetKernelsFilterArgs.builder()
     *                     .name("architecture")
     *                     .values("x86_64")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `architecture`
     * 
     * * `deprecated`
     * 
     * * `kvm`
     * 
     * * `label`
     * 
     * * `pvops`
     * 
     * * `version`
     * 
     * * `xen`
     * 
     */
    public static CompletableFuture<GetKernelsResult> getKernelsPlain() {
        return getKernelsPlain(GetKernelsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Kernels that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernels).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredKernels = LinodeFunctions.getKernels(GetKernelsArgs.builder()
     *             .filters(            
     *                 GetKernelsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-kernel")
     *                     .build(),
     *                 GetKernelsFilterArgs.builder()
     *                     .name("architecture")
     *                     .values("x86_64")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `architecture`
     * 
     * * `deprecated`
     * 
     * * `kvm`
     * 
     * * `label`
     * 
     * * `pvops`
     * 
     * * `version`
     * 
     * * `xen`
     * 
     */
    public static Output<GetKernelsResult> getKernels(GetKernelsArgs args) {
        return getKernels(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Kernels that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernels).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredKernels = LinodeFunctions.getKernels(GetKernelsArgs.builder()
     *             .filters(            
     *                 GetKernelsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-kernel")
     *                     .build(),
     *                 GetKernelsFilterArgs.builder()
     *                     .name("architecture")
     *                     .values("x86_64")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `architecture`
     * 
     * * `deprecated`
     * 
     * * `kvm`
     * 
     * * `label`
     * 
     * * `pvops`
     * 
     * * `version`
     * 
     * * `xen`
     * 
     */
    public static CompletableFuture<GetKernelsResult> getKernelsPlain(GetKernelsPlainArgs args) {
        return getKernelsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Kernels that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernels).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredKernels = LinodeFunctions.getKernels(GetKernelsArgs.builder()
     *             .filters(            
     *                 GetKernelsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-kernel")
     *                     .build(),
     *                 GetKernelsFilterArgs.builder()
     *                     .name("architecture")
     *                     .values("x86_64")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `architecture`
     * 
     * * `deprecated`
     * 
     * * `kvm`
     * 
     * * `label`
     * 
     * * `pvops`
     * 
     * * `version`
     * 
     * * `xen`
     * 
     */
    public static Output<GetKernelsResult> getKernels(GetKernelsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getKernels:getKernels", TypeShape.of(GetKernelsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Kernels that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernels).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredKernels = LinodeFunctions.getKernels(GetKernelsArgs.builder()
     *             .filters(            
     *                 GetKernelsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-kernel")
     *                     .build(),
     *                 GetKernelsFilterArgs.builder()
     *                     .name("architecture")
     *                     .values("x86_64")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `architecture`
     * 
     * * `deprecated`
     * 
     * * `kvm`
     * 
     * * `label`
     * 
     * * `pvops`
     * 
     * * `version`
     * 
     * * `xen`
     * 
     */
    public static Output<GetKernelsResult> getKernels(GetKernelsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getKernels:getKernels", TypeShape.of(GetKernelsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Kernels that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-kernels).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetKernelsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredKernels = LinodeFunctions.getKernels(GetKernelsArgs.builder()
     *             .filters(            
     *                 GetKernelsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-kernel")
     *                     .build(),
     *                 GetKernelsFilterArgs.builder()
     *                     .name("architecture")
     *                     .values("x86_64")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `architecture`
     * 
     * * `deprecated`
     * 
     * * `kvm`
     * 
     * * `label`
     * 
     * * `pvops`
     * 
     * * `version`
     * 
     * * `xen`
     * 
     */
    public static CompletableFuture<GetKernelsResult> getKernelsPlain(GetKernelsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getKernels:getKernels", TypeShape.of(GetKernelsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Object Storage Bucket
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-bucket).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Object Storage Bucket.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLinodeObjectStorageBucketArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-bucket = LinodeFunctions.getLinodeObjectStorageBucket(GetLinodeObjectStorageBucketArgs.builder()
     *             .label("my-bucket")
     *             .region("us-mia")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLinodeObjectStorageBucketResult> getLinodeObjectStorageBucket(GetLinodeObjectStorageBucketArgs args) {
        return getLinodeObjectStorageBucket(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Object Storage Bucket
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-bucket).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Object Storage Bucket.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLinodeObjectStorageBucketArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-bucket = LinodeFunctions.getLinodeObjectStorageBucket(GetLinodeObjectStorageBucketArgs.builder()
     *             .label("my-bucket")
     *             .region("us-mia")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetLinodeObjectStorageBucketResult> getLinodeObjectStorageBucketPlain(GetLinodeObjectStorageBucketPlainArgs args) {
        return getLinodeObjectStorageBucketPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Object Storage Bucket
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-bucket).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Object Storage Bucket.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLinodeObjectStorageBucketArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-bucket = LinodeFunctions.getLinodeObjectStorageBucket(GetLinodeObjectStorageBucketArgs.builder()
     *             .label("my-bucket")
     *             .region("us-mia")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLinodeObjectStorageBucketResult> getLinodeObjectStorageBucket(GetLinodeObjectStorageBucketArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLinodeObjectStorageBucket:getLinodeObjectStorageBucket", TypeShape.of(GetLinodeObjectStorageBucketResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Object Storage Bucket
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-bucket).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Object Storage Bucket.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLinodeObjectStorageBucketArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-bucket = LinodeFunctions.getLinodeObjectStorageBucket(GetLinodeObjectStorageBucketArgs.builder()
     *             .label("my-bucket")
     *             .region("us-mia")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLinodeObjectStorageBucketResult> getLinodeObjectStorageBucket(GetLinodeObjectStorageBucketArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLinodeObjectStorageBucket:getLinodeObjectStorageBucket", TypeShape.of(GetLinodeObjectStorageBucketResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Object Storage Bucket
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-bucket).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Object Storage Bucket.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLinodeObjectStorageBucketArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-bucket = LinodeFunctions.getLinodeObjectStorageBucket(GetLinodeObjectStorageBucketArgs.builder()
     *             .label("my-bucket")
     *             .region("us-mia")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetLinodeObjectStorageBucketResult> getLinodeObjectStorageBucketPlain(GetLinodeObjectStorageBucketPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getLinodeObjectStorageBucket:getLinodeObjectStorageBucket", TypeShape.of(GetLinodeObjectStorageBucketResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about an LKE Cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-cluster).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-cluster = LinodeFunctions.getLkeCluster(GetLkeClusterArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLkeClusterResult> getLkeCluster(GetLkeClusterArgs args) {
        return getLkeCluster(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about an LKE Cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-cluster).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-cluster = LinodeFunctions.getLkeCluster(GetLkeClusterArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetLkeClusterResult> getLkeClusterPlain(GetLkeClusterPlainArgs args) {
        return getLkeClusterPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about an LKE Cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-cluster).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-cluster = LinodeFunctions.getLkeCluster(GetLkeClusterArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLkeClusterResult> getLkeCluster(GetLkeClusterArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLkeCluster:getLkeCluster", TypeShape.of(GetLkeClusterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about an LKE Cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-cluster).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-cluster = LinodeFunctions.getLkeCluster(GetLkeClusterArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLkeClusterResult> getLkeCluster(GetLkeClusterArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLkeCluster:getLkeCluster", TypeShape.of(GetLkeClusterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about an LKE Cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-cluster).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-cluster = LinodeFunctions.getLkeCluster(GetLkeClusterArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetLkeClusterResult> getLkeClusterPlain(GetLkeClusterPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getLkeCluster:getLkeCluster", TypeShape.of(GetLkeClusterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of current Linode Kubernetes (LKE) clusters on your account that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-clusters).
     * 
     * ## Example Usage
     * 
     * Get information about all LKE clusters with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClustersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getLkeClusters(GetLkeClustersArgs.builder()
     *             .filters(GetLkeClustersFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("lkeCluster", specific.lkeClusters()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `k8s_version`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `tags`
     * 
     * * `status`
     * 
     * * `created`
     * 
     * * `updated`
     * 
     */
    public static Output<GetLkeClustersResult> getLkeClusters() {
        return getLkeClusters(GetLkeClustersArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of current Linode Kubernetes (LKE) clusters on your account that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-clusters).
     * 
     * ## Example Usage
     * 
     * Get information about all LKE clusters with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClustersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getLkeClusters(GetLkeClustersArgs.builder()
     *             .filters(GetLkeClustersFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("lkeCluster", specific.lkeClusters()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `k8s_version`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `tags`
     * 
     * * `status`
     * 
     * * `created`
     * 
     * * `updated`
     * 
     */
    public static CompletableFuture<GetLkeClustersResult> getLkeClustersPlain() {
        return getLkeClustersPlain(GetLkeClustersPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of current Linode Kubernetes (LKE) clusters on your account that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-clusters).
     * 
     * ## Example Usage
     * 
     * Get information about all LKE clusters with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClustersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getLkeClusters(GetLkeClustersArgs.builder()
     *             .filters(GetLkeClustersFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("lkeCluster", specific.lkeClusters()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `k8s_version`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `tags`
     * 
     * * `status`
     * 
     * * `created`
     * 
     * * `updated`
     * 
     */
    public static Output<GetLkeClustersResult> getLkeClusters(GetLkeClustersArgs args) {
        return getLkeClusters(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of current Linode Kubernetes (LKE) clusters on your account that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-clusters).
     * 
     * ## Example Usage
     * 
     * Get information about all LKE clusters with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClustersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getLkeClusters(GetLkeClustersArgs.builder()
     *             .filters(GetLkeClustersFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("lkeCluster", specific.lkeClusters()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `k8s_version`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `tags`
     * 
     * * `status`
     * 
     * * `created`
     * 
     * * `updated`
     * 
     */
    public static CompletableFuture<GetLkeClustersResult> getLkeClustersPlain(GetLkeClustersPlainArgs args) {
        return getLkeClustersPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of current Linode Kubernetes (LKE) clusters on your account that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-clusters).
     * 
     * ## Example Usage
     * 
     * Get information about all LKE clusters with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClustersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getLkeClusters(GetLkeClustersArgs.builder()
     *             .filters(GetLkeClustersFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("lkeCluster", specific.lkeClusters()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `k8s_version`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `tags`
     * 
     * * `status`
     * 
     * * `created`
     * 
     * * `updated`
     * 
     */
    public static Output<GetLkeClustersResult> getLkeClusters(GetLkeClustersArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLkeClusters:getLkeClusters", TypeShape.of(GetLkeClustersResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of current Linode Kubernetes (LKE) clusters on your account that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-clusters).
     * 
     * ## Example Usage
     * 
     * Get information about all LKE clusters with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClustersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getLkeClusters(GetLkeClustersArgs.builder()
     *             .filters(GetLkeClustersFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("lkeCluster", specific.lkeClusters()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `k8s_version`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `tags`
     * 
     * * `status`
     * 
     * * `created`
     * 
     * * `updated`
     * 
     */
    public static Output<GetLkeClustersResult> getLkeClusters(GetLkeClustersArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLkeClusters:getLkeClusters", TypeShape.of(GetLkeClustersResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of current Linode Kubernetes (LKE) clusters on your account that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-clusters).
     * 
     * ## Example Usage
     * 
     * Get information about all LKE clusters with a specific tag:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeClustersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific = LinodeFunctions.getLkeClusters(GetLkeClustersArgs.builder()
     *             .filters(GetLkeClustersFilterArgs.builder()
     *                 .name("tags")
     *                 .values("test-tag")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("lkeCluster", specific.lkeClusters()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `k8s_version`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `tags`
     * 
     * * `status`
     * 
     * * `created`
     * 
     * * `updated`
     * 
     */
    public static CompletableFuture<GetLkeClustersResult> getLkeClustersPlain(GetLkeClustersPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getLkeClusters:getLkeClusters", TypeShape.of(GetLkeClustersResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode LKE types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-types).
     * 
     */
    public static Output<GetLkeTypesResult> getLkeTypes() {
        return getLkeTypes(GetLkeTypesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode LKE types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-types).
     * 
     */
    public static CompletableFuture<GetLkeTypesResult> getLkeTypesPlain() {
        return getLkeTypesPlain(GetLkeTypesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode LKE types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-types).
     * 
     */
    public static Output<GetLkeTypesResult> getLkeTypes(GetLkeTypesArgs args) {
        return getLkeTypes(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode LKE types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-types).
     * 
     */
    public static CompletableFuture<GetLkeTypesResult> getLkeTypesPlain(GetLkeTypesPlainArgs args) {
        return getLkeTypesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode LKE types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-types).
     * 
     */
    public static Output<GetLkeTypesResult> getLkeTypes(GetLkeTypesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLkeTypes:getLkeTypes", TypeShape.of(GetLkeTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode LKE types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-types).
     * 
     */
    public static Output<GetLkeTypesResult> getLkeTypes(GetLkeTypesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLkeTypes:getLkeTypes", TypeShape.of(GetLkeTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode LKE types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-types).
     * 
     */
    public static CompletableFuture<GetLkeTypesResult> getLkeTypesPlain(GetLkeTypesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getLkeTypes:getLkeTypes", TypeShape.of(GetLkeTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a specific Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-version).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersion(GetLkeVersionArgs.builder()
     *             .id("1.31")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersion(GetLkeVersionArgs.builder()
     *             .id("1.31")
     *             .tier("standard")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLkeVersionResult> getLkeVersion(GetLkeVersionArgs args) {
        return getLkeVersion(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a specific Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-version).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersion(GetLkeVersionArgs.builder()
     *             .id("1.31")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersion(GetLkeVersionArgs.builder()
     *             .id("1.31")
     *             .tier("standard")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetLkeVersionResult> getLkeVersionPlain(GetLkeVersionPlainArgs args) {
        return getLkeVersionPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a specific Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-version).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersion(GetLkeVersionArgs.builder()
     *             .id("1.31")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersion(GetLkeVersionArgs.builder()
     *             .id("1.31")
     *             .tier("standard")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLkeVersionResult> getLkeVersion(GetLkeVersionArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLkeVersion:getLkeVersion", TypeShape.of(GetLkeVersionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a specific Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-version).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersion(GetLkeVersionArgs.builder()
     *             .id("1.31")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersion(GetLkeVersionArgs.builder()
     *             .id("1.31")
     *             .tier("standard")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLkeVersionResult> getLkeVersion(GetLkeVersionArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLkeVersion:getLkeVersion", TypeShape.of(GetLkeVersionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a specific Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-version).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersion(GetLkeVersionArgs.builder()
     *             .id("1.31")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersion(GetLkeVersionArgs.builder()
     *             .id("1.31")
     *             .tier("standard")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetLkeVersionResult> getLkeVersionPlain(GetLkeVersionPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getLkeVersion:getLkeVersion", TypeShape.of(GetLkeVersionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about the Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-versions).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .build());
     * 
     *         ctx.export("exampleOutput", example);
     *         ctx.export("exampleOutputFirstVersion", example.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var exampleEnterprise = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .tier("enterprise")
     *             .build());
     * 
     *         ctx.export("exampleEnterpriseOutput", exampleEnterprise);
     *         ctx.export("exampleEnterpriseOutputFirstVersion", exampleEnterprise.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLkeVersionsResult> getLkeVersions() {
        return getLkeVersions(GetLkeVersionsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides details about the Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-versions).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .build());
     * 
     *         ctx.export("exampleOutput", example);
     *         ctx.export("exampleOutputFirstVersion", example.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var exampleEnterprise = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .tier("enterprise")
     *             .build());
     * 
     *         ctx.export("exampleEnterpriseOutput", exampleEnterprise);
     *         ctx.export("exampleEnterpriseOutputFirstVersion", exampleEnterprise.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetLkeVersionsResult> getLkeVersionsPlain() {
        return getLkeVersionsPlain(GetLkeVersionsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides details about the Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-versions).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .build());
     * 
     *         ctx.export("exampleOutput", example);
     *         ctx.export("exampleOutputFirstVersion", example.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var exampleEnterprise = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .tier("enterprise")
     *             .build());
     * 
     *         ctx.export("exampleEnterpriseOutput", exampleEnterprise);
     *         ctx.export("exampleEnterpriseOutputFirstVersion", exampleEnterprise.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLkeVersionsResult> getLkeVersions(GetLkeVersionsArgs args) {
        return getLkeVersions(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about the Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-versions).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .build());
     * 
     *         ctx.export("exampleOutput", example);
     *         ctx.export("exampleOutputFirstVersion", example.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var exampleEnterprise = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .tier("enterprise")
     *             .build());
     * 
     *         ctx.export("exampleEnterpriseOutput", exampleEnterprise);
     *         ctx.export("exampleEnterpriseOutputFirstVersion", exampleEnterprise.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetLkeVersionsResult> getLkeVersionsPlain(GetLkeVersionsPlainArgs args) {
        return getLkeVersionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about the Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-versions).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .build());
     * 
     *         ctx.export("exampleOutput", example);
     *         ctx.export("exampleOutputFirstVersion", example.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var exampleEnterprise = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .tier("enterprise")
     *             .build());
     * 
     *         ctx.export("exampleEnterpriseOutput", exampleEnterprise);
     *         ctx.export("exampleEnterpriseOutputFirstVersion", exampleEnterprise.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLkeVersionsResult> getLkeVersions(GetLkeVersionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLkeVersions:getLkeVersions", TypeShape.of(GetLkeVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about the Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-versions).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .build());
     * 
     *         ctx.export("exampleOutput", example);
     *         ctx.export("exampleOutputFirstVersion", example.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var exampleEnterprise = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .tier("enterprise")
     *             .build());
     * 
     *         ctx.export("exampleEnterpriseOutput", exampleEnterprise);
     *         ctx.export("exampleEnterpriseOutputFirstVersion", exampleEnterprise.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetLkeVersionsResult> getLkeVersions(GetLkeVersionsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getLkeVersions:getLkeVersions", TypeShape.of(GetLkeVersionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about the Kubernetes versions available for deployment to a Kubernetes cluster.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-lke-versions).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .build());
     * 
     *         ctx.export("exampleOutput", example);
     *         ctx.export("exampleOutputFirstVersion", example.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows how one might use this data source to access information about a Linode LKE Version
     * with additional information about the Linode LKE Version&#39;s tier (`enterprise` or `standard`).
     * 
     * &gt; **_NOTE:_**  This functionality may not be currently available to all users and can only be used with v4beta.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetLkeVersionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var exampleEnterprise = LinodeFunctions.getLkeVersions(GetLkeVersionsArgs.builder()
     *             .tier("enterprise")
     *             .build());
     * 
     *         ctx.export("exampleEnterpriseOutput", exampleEnterprise);
     *         ctx.export("exampleEnterpriseOutputFirstVersion", exampleEnterprise.versions()[0]);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetLkeVersionsResult> getLkeVersionsPlain(GetLkeVersionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getLkeVersions:getLkeVersions", TypeShape.of(GetLkeVersionsResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetNbTypesResult> getNbTypes() {
        return getNbTypes(GetNbTypesArgs.Empty, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetNbTypesResult> getNbTypesPlain() {
        return getNbTypesPlain(GetNbTypesPlainArgs.Empty, InvokeOptions.Empty);
    }
    public static Output<GetNbTypesResult> getNbTypes(GetNbTypesArgs args) {
        return getNbTypes(args, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetNbTypesResult> getNbTypesPlain(GetNbTypesPlainArgs args) {
        return getNbTypesPlain(args, InvokeOptions.Empty);
    }
    public static Output<GetNbTypesResult> getNbTypes(GetNbTypesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNbTypes:getNbTypes", TypeShape.of(GetNbTypesResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetNbTypesResult> getNbTypes(GetNbTypesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNbTypes:getNbTypes", TypeShape.of(GetNbTypesResult.class), args, Utilities.withVersion(options));
    }
    public static CompletableFuture<GetNbTypesResult> getNbTypesPlain(GetNbTypesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getNbTypes:getNbTypes", TypeShape.of(GetNbTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Network Transfer Prices that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-network-transfer-prices).
     * 
     */
    public static Output<GetNetworkTransferPricesResult> getNetworkTransferPrices() {
        return getNetworkTransferPrices(GetNetworkTransferPricesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Network Transfer Prices that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-network-transfer-prices).
     * 
     */
    public static CompletableFuture<GetNetworkTransferPricesResult> getNetworkTransferPricesPlain() {
        return getNetworkTransferPricesPlain(GetNetworkTransferPricesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Network Transfer Prices that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-network-transfer-prices).
     * 
     */
    public static Output<GetNetworkTransferPricesResult> getNetworkTransferPrices(GetNetworkTransferPricesArgs args) {
        return getNetworkTransferPrices(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Network Transfer Prices that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-network-transfer-prices).
     * 
     */
    public static CompletableFuture<GetNetworkTransferPricesResult> getNetworkTransferPricesPlain(GetNetworkTransferPricesPlainArgs args) {
        return getNetworkTransferPricesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Network Transfer Prices that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-network-transfer-prices).
     * 
     */
    public static Output<GetNetworkTransferPricesResult> getNetworkTransferPrices(GetNetworkTransferPricesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNetworkTransferPrices:getNetworkTransferPrices", TypeShape.of(GetNetworkTransferPricesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Network Transfer Prices that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-network-transfer-prices).
     * 
     */
    public static Output<GetNetworkTransferPricesResult> getNetworkTransferPrices(GetNetworkTransferPricesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNetworkTransferPrices:getNetworkTransferPrices", TypeShape.of(GetNetworkTransferPricesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Network Transfer Prices that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-network-transfer-prices).
     * 
     */
    public static CompletableFuture<GetNetworkTransferPricesResult> getNetworkTransferPricesPlain(GetNetworkTransferPricesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getNetworkTransferPrices:getNetworkTransferPrices", TypeShape.of(GetNetworkTransferPricesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Networking IP Address
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ip).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Networking IP Address.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var ns1LinodeCom = LinodeFunctions.getNetworkingIp(GetNetworkingIpArgs.builder()
     *             .address("162.159.27.72")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNetworkingIpResult> getNetworkingIp(GetNetworkingIpArgs args) {
        return getNetworkingIp(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Networking IP Address
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ip).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Networking IP Address.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var ns1LinodeCom = LinodeFunctions.getNetworkingIp(GetNetworkingIpArgs.builder()
     *             .address("162.159.27.72")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetNetworkingIpResult> getNetworkingIpPlain(GetNetworkingIpPlainArgs args) {
        return getNetworkingIpPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Networking IP Address
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ip).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Networking IP Address.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var ns1LinodeCom = LinodeFunctions.getNetworkingIp(GetNetworkingIpArgs.builder()
     *             .address("162.159.27.72")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNetworkingIpResult> getNetworkingIp(GetNetworkingIpArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNetworkingIp:getNetworkingIp", TypeShape.of(GetNetworkingIpResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Networking IP Address
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ip).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Networking IP Address.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var ns1LinodeCom = LinodeFunctions.getNetworkingIp(GetNetworkingIpArgs.builder()
     *             .address("162.159.27.72")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNetworkingIpResult> getNetworkingIp(GetNetworkingIpArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNetworkingIp:getNetworkingIp", TypeShape.of(GetNetworkingIpResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Networking IP Address
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ip).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Networking IP Address.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var ns1LinodeCom = LinodeFunctions.getNetworkingIp(GetNetworkingIpArgs.builder()
     *             .address("162.159.27.72")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetNetworkingIpResult> getNetworkingIpPlain(GetNetworkingIpPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getNetworkingIp:getNetworkingIp", TypeShape.of(GetNetworkingIpResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about all IP addresses associated with the current Linode account, including both assigned and unassigned reserved IP addresses.
     * 
     * ## Example Usage
     * 
     * Retrieve all IPs under the current account:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Retrieve all IPs under the current account in a specific region:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .filters(GetNetworkingIpsFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `address`
     * 
     * * `gateway`
     * 
     * * `subnet_mask`
     * 
     * * `prefix`
     * 
     * * `type`
     * 
     * * `public`
     * 
     * * `rdns`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `reserved`
     * 
     */
    public static Output<GetNetworkingIpsResult> getNetworkingIps() {
        return getNetworkingIps(GetNetworkingIpsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about all IP addresses associated with the current Linode account, including both assigned and unassigned reserved IP addresses.
     * 
     * ## Example Usage
     * 
     * Retrieve all IPs under the current account:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Retrieve all IPs under the current account in a specific region:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .filters(GetNetworkingIpsFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `address`
     * 
     * * `gateway`
     * 
     * * `subnet_mask`
     * 
     * * `prefix`
     * 
     * * `type`
     * 
     * * `public`
     * 
     * * `rdns`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `reserved`
     * 
     */
    public static CompletableFuture<GetNetworkingIpsResult> getNetworkingIpsPlain() {
        return getNetworkingIpsPlain(GetNetworkingIpsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about all IP addresses associated with the current Linode account, including both assigned and unassigned reserved IP addresses.
     * 
     * ## Example Usage
     * 
     * Retrieve all IPs under the current account:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Retrieve all IPs under the current account in a specific region:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .filters(GetNetworkingIpsFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `address`
     * 
     * * `gateway`
     * 
     * * `subnet_mask`
     * 
     * * `prefix`
     * 
     * * `type`
     * 
     * * `public`
     * 
     * * `rdns`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `reserved`
     * 
     */
    public static Output<GetNetworkingIpsResult> getNetworkingIps(GetNetworkingIpsArgs args) {
        return getNetworkingIps(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about all IP addresses associated with the current Linode account, including both assigned and unassigned reserved IP addresses.
     * 
     * ## Example Usage
     * 
     * Retrieve all IPs under the current account:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Retrieve all IPs under the current account in a specific region:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .filters(GetNetworkingIpsFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `address`
     * 
     * * `gateway`
     * 
     * * `subnet_mask`
     * 
     * * `prefix`
     * 
     * * `type`
     * 
     * * `public`
     * 
     * * `rdns`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `reserved`
     * 
     */
    public static CompletableFuture<GetNetworkingIpsResult> getNetworkingIpsPlain(GetNetworkingIpsPlainArgs args) {
        return getNetworkingIpsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about all IP addresses associated with the current Linode account, including both assigned and unassigned reserved IP addresses.
     * 
     * ## Example Usage
     * 
     * Retrieve all IPs under the current account:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Retrieve all IPs under the current account in a specific region:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .filters(GetNetworkingIpsFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `address`
     * 
     * * `gateway`
     * 
     * * `subnet_mask`
     * 
     * * `prefix`
     * 
     * * `type`
     * 
     * * `public`
     * 
     * * `rdns`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `reserved`
     * 
     */
    public static Output<GetNetworkingIpsResult> getNetworkingIps(GetNetworkingIpsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNetworkingIps:getNetworkingIps", TypeShape.of(GetNetworkingIpsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about all IP addresses associated with the current Linode account, including both assigned and unassigned reserved IP addresses.
     * 
     * ## Example Usage
     * 
     * Retrieve all IPs under the current account:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Retrieve all IPs under the current account in a specific region:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .filters(GetNetworkingIpsFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `address`
     * 
     * * `gateway`
     * 
     * * `subnet_mask`
     * 
     * * `prefix`
     * 
     * * `type`
     * 
     * * `public`
     * 
     * * `rdns`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `reserved`
     * 
     */
    public static Output<GetNetworkingIpsResult> getNetworkingIps(GetNetworkingIpsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNetworkingIps:getNetworkingIps", TypeShape.of(GetNetworkingIpsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about all IP addresses associated with the current Linode account, including both assigned and unassigned reserved IP addresses.
     * 
     * ## Example Usage
     * 
     * Retrieve all IPs under the current account:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Retrieve all IPs under the current account in a specific region:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNetworkingIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered = LinodeFunctions.getNetworkingIps(GetNetworkingIpsArgs.builder()
     *             .filters(GetNetworkingIpsFilterArgs.builder()
     *                 .name("region")
     *                 .values("us-mia")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `address`
     * 
     * * `gateway`
     * 
     * * `subnet_mask`
     * 
     * * `prefix`
     * 
     * * `type`
     * 
     * * `public`
     * 
     * * `rdns`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `reserved`
     * 
     */
    public static CompletableFuture<GetNetworkingIpsResult> getNetworkingIpsPlain(GetNetworkingIpsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getNetworkingIps:getNetworkingIps", TypeShape.of(GetNetworkingIpsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode NodeBalancer.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-nodebalancer = LinodeFunctions.getNodeBalancer(GetNodeBalancerArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNodeBalancerResult> getNodeBalancer(GetNodeBalancerArgs args) {
        return getNodeBalancer(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a Linode NodeBalancer.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-nodebalancer = LinodeFunctions.getNodeBalancer(GetNodeBalancerArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetNodeBalancerResult> getNodeBalancerPlain(GetNodeBalancerPlainArgs args) {
        return getNodeBalancerPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a Linode NodeBalancer.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-nodebalancer = LinodeFunctions.getNodeBalancer(GetNodeBalancerArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNodeBalancerResult> getNodeBalancer(GetNodeBalancerArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNodeBalancer:getNodeBalancer", TypeShape.of(GetNodeBalancerResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode NodeBalancer.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-nodebalancer = LinodeFunctions.getNodeBalancer(GetNodeBalancerArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNodeBalancerResult> getNodeBalancer(GetNodeBalancerArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNodeBalancer:getNodeBalancer", TypeShape.of(GetNodeBalancerResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode NodeBalancer.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-nodebalancer = LinodeFunctions.getNodeBalancer(GetNodeBalancerArgs.builder()
     *             .id(123)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetNodeBalancerResult> getNodeBalancerPlain(GetNodeBalancerPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getNodeBalancer:getNodeBalancer", TypeShape.of(GetNodeBalancerResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode NodeBalancer Config.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-config).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerConfigArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-config = LinodeFunctions.getNodeBalancerConfig(GetNodeBalancerConfigArgs.builder()
     *             .id(123)
     *             .nodebalancerId(456)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNodeBalancerConfigResult> getNodeBalancerConfig(GetNodeBalancerConfigArgs args) {
        return getNodeBalancerConfig(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a Linode NodeBalancer Config.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-config).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerConfigArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-config = LinodeFunctions.getNodeBalancerConfig(GetNodeBalancerConfigArgs.builder()
     *             .id(123)
     *             .nodebalancerId(456)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetNodeBalancerConfigResult> getNodeBalancerConfigPlain(GetNodeBalancerConfigPlainArgs args) {
        return getNodeBalancerConfigPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a Linode NodeBalancer Config.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-config).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerConfigArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-config = LinodeFunctions.getNodeBalancerConfig(GetNodeBalancerConfigArgs.builder()
     *             .id(123)
     *             .nodebalancerId(456)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNodeBalancerConfigResult> getNodeBalancerConfig(GetNodeBalancerConfigArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNodeBalancerConfig:getNodeBalancerConfig", TypeShape.of(GetNodeBalancerConfigResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode NodeBalancer Config.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-config).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerConfigArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-config = LinodeFunctions.getNodeBalancerConfig(GetNodeBalancerConfigArgs.builder()
     *             .id(123)
     *             .nodebalancerId(456)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNodeBalancerConfigResult> getNodeBalancerConfig(GetNodeBalancerConfigArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNodeBalancerConfig:getNodeBalancerConfig", TypeShape.of(GetNodeBalancerConfigResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode NodeBalancer Config.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-config).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerConfigArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-config = LinodeFunctions.getNodeBalancerConfig(GetNodeBalancerConfigArgs.builder()
     *             .id(123)
     *             .nodebalancerId(456)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetNodeBalancerConfigResult> getNodeBalancerConfigPlain(GetNodeBalancerConfigPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getNodeBalancerConfig:getNodeBalancerConfig", TypeShape.of(GetNodeBalancerConfigResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode NodeBalancer node.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-node).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerNodeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-node = LinodeFunctions.getNodeBalancerNode(GetNodeBalancerNodeArgs.builder()
     *             .id(123)
     *             .nodebalancerId(456)
     *             .configId(789)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNodeBalancerNodeResult> getNodeBalancerNode(GetNodeBalancerNodeArgs args) {
        return getNodeBalancerNode(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a Linode NodeBalancer node.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-node).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerNodeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-node = LinodeFunctions.getNodeBalancerNode(GetNodeBalancerNodeArgs.builder()
     *             .id(123)
     *             .nodebalancerId(456)
     *             .configId(789)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetNodeBalancerNodeResult> getNodeBalancerNodePlain(GetNodeBalancerNodePlainArgs args) {
        return getNodeBalancerNodePlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a Linode NodeBalancer node.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-node).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerNodeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-node = LinodeFunctions.getNodeBalancerNode(GetNodeBalancerNodeArgs.builder()
     *             .id(123)
     *             .nodebalancerId(456)
     *             .configId(789)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNodeBalancerNodeResult> getNodeBalancerNode(GetNodeBalancerNodeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNodeBalancerNode:getNodeBalancerNode", TypeShape.of(GetNodeBalancerNodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode NodeBalancer node.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-node).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerNodeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-node = LinodeFunctions.getNodeBalancerNode(GetNodeBalancerNodeArgs.builder()
     *             .id(123)
     *             .nodebalancerId(456)
     *             .configId(789)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetNodeBalancerNodeResult> getNodeBalancerNode(GetNodeBalancerNodeArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNodeBalancerNode:getNodeBalancerNode", TypeShape.of(GetNodeBalancerNodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a Linode NodeBalancer node.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-node).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodeBalancerNodeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var my-node = LinodeFunctions.getNodeBalancerNode(GetNodeBalancerNodeArgs.builder()
     *             .id(123)
     *             .nodebalancerId(456)
     *             .configId(789)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetNodeBalancerNodeResult> getNodeBalancerNodePlain(GetNodeBalancerNodePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getNodeBalancerNode:getNodeBalancerNode", TypeShape.of(GetNodeBalancerNodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode NodeBalancer Configs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-configs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a list of NodeBalancer Configs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancerConfigsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filterNbConfigs = LinodeFunctions.getNodebalancerConfigs(GetNodebalancerConfigsArgs.builder()
     *             .nodebalancerId(12345)
     *             .filters(GetNodebalancerConfigsFilterArgs.builder()
     *                 .name("port")
     *                 .values("80")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerConfigId", filterNbConfigs.nodebalancerConfigs()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `algorithm`
     * 
     * * `check`
     * 
     * * `nodebalancer_id`
     * 
     * * `port`
     * 
     * * `protocol`
     * 
     * * `proxy_protocol`
     * 
     * * `stickiness`
     * 
     * * `check_path`
     * 
     * * `check_body`
     * 
     * * `check_passive`
     * 
     * * `cipher_suite`
     * 
     * * `ssl_commonname`
     * 
     */
    public static Output<GetNodebalancerConfigsResult> getNodebalancerConfigs(GetNodebalancerConfigsArgs args) {
        return getNodebalancerConfigs(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode NodeBalancer Configs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-configs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a list of NodeBalancer Configs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancerConfigsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filterNbConfigs = LinodeFunctions.getNodebalancerConfigs(GetNodebalancerConfigsArgs.builder()
     *             .nodebalancerId(12345)
     *             .filters(GetNodebalancerConfigsFilterArgs.builder()
     *                 .name("port")
     *                 .values("80")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerConfigId", filterNbConfigs.nodebalancerConfigs()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `algorithm`
     * 
     * * `check`
     * 
     * * `nodebalancer_id`
     * 
     * * `port`
     * 
     * * `protocol`
     * 
     * * `proxy_protocol`
     * 
     * * `stickiness`
     * 
     * * `check_path`
     * 
     * * `check_body`
     * 
     * * `check_passive`
     * 
     * * `cipher_suite`
     * 
     * * `ssl_commonname`
     * 
     */
    public static CompletableFuture<GetNodebalancerConfigsResult> getNodebalancerConfigsPlain(GetNodebalancerConfigsPlainArgs args) {
        return getNodebalancerConfigsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode NodeBalancer Configs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-configs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a list of NodeBalancer Configs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancerConfigsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filterNbConfigs = LinodeFunctions.getNodebalancerConfigs(GetNodebalancerConfigsArgs.builder()
     *             .nodebalancerId(12345)
     *             .filters(GetNodebalancerConfigsFilterArgs.builder()
     *                 .name("port")
     *                 .values("80")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerConfigId", filterNbConfigs.nodebalancerConfigs()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `algorithm`
     * 
     * * `check`
     * 
     * * `nodebalancer_id`
     * 
     * * `port`
     * 
     * * `protocol`
     * 
     * * `proxy_protocol`
     * 
     * * `stickiness`
     * 
     * * `check_path`
     * 
     * * `check_body`
     * 
     * * `check_passive`
     * 
     * * `cipher_suite`
     * 
     * * `ssl_commonname`
     * 
     */
    public static Output<GetNodebalancerConfigsResult> getNodebalancerConfigs(GetNodebalancerConfigsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNodebalancerConfigs:getNodebalancerConfigs", TypeShape.of(GetNodebalancerConfigsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode NodeBalancer Configs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-configs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a list of NodeBalancer Configs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancerConfigsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filterNbConfigs = LinodeFunctions.getNodebalancerConfigs(GetNodebalancerConfigsArgs.builder()
     *             .nodebalancerId(12345)
     *             .filters(GetNodebalancerConfigsFilterArgs.builder()
     *                 .name("port")
     *                 .values("80")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerConfigId", filterNbConfigs.nodebalancerConfigs()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `algorithm`
     * 
     * * `check`
     * 
     * * `nodebalancer_id`
     * 
     * * `port`
     * 
     * * `protocol`
     * 
     * * `proxy_protocol`
     * 
     * * `stickiness`
     * 
     * * `check_path`
     * 
     * * `check_body`
     * 
     * * `check_passive`
     * 
     * * `cipher_suite`
     * 
     * * `ssl_commonname`
     * 
     */
    public static Output<GetNodebalancerConfigsResult> getNodebalancerConfigs(GetNodebalancerConfigsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNodebalancerConfigs:getNodebalancerConfigs", TypeShape.of(GetNodebalancerConfigsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode NodeBalancer Configs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-configs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a list of NodeBalancer Configs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancerConfigsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filterNbConfigs = LinodeFunctions.getNodebalancerConfigs(GetNodebalancerConfigsArgs.builder()
     *             .nodebalancerId(12345)
     *             .filters(GetNodebalancerConfigsFilterArgs.builder()
     *                 .name("port")
     *                 .values("80")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerConfigId", filterNbConfigs.nodebalancerConfigs()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `algorithm`
     * 
     * * `check`
     * 
     * * `nodebalancer_id`
     * 
     * * `port`
     * 
     * * `protocol`
     * 
     * * `proxy_protocol`
     * 
     * * `stickiness`
     * 
     * * `check_path`
     * 
     * * `check_body`
     * 
     * * `check_passive`
     * 
     * * `cipher_suite`
     * 
     * * `ssl_commonname`
     * 
     */
    public static CompletableFuture<GetNodebalancerConfigsResult> getNodebalancerConfigsPlain(GetNodebalancerConfigsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getNodebalancerConfigs:getNodebalancerConfigs", TypeShape.of(GetNodebalancerConfigsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode NodeBalancers that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancers).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode NodeBalancer.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-nodebalancers = LinodeFunctions.getNodebalancers(GetNodebalancersArgs.builder()
     *             .filters(            
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-nodebalancer")
     *                     .build(),
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("region")
     *                     .values("us-iad")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerId", specific_nodebalancers.nodebalancers()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     * * `ipv4`
     * 
     * * `ipv6`
     * 
     * * `hostname`
     * 
     * * `region`
     * 
     * * `client_conn_throttle`
     * 
     */
    public static Output<GetNodebalancersResult> getNodebalancers() {
        return getNodebalancers(GetNodebalancersArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode NodeBalancers that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancers).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode NodeBalancer.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-nodebalancers = LinodeFunctions.getNodebalancers(GetNodebalancersArgs.builder()
     *             .filters(            
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-nodebalancer")
     *                     .build(),
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("region")
     *                     .values("us-iad")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerId", specific_nodebalancers.nodebalancers()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     * * `ipv4`
     * 
     * * `ipv6`
     * 
     * * `hostname`
     * 
     * * `region`
     * 
     * * `client_conn_throttle`
     * 
     */
    public static CompletableFuture<GetNodebalancersResult> getNodebalancersPlain() {
        return getNodebalancersPlain(GetNodebalancersPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode NodeBalancers that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancers).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode NodeBalancer.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-nodebalancers = LinodeFunctions.getNodebalancers(GetNodebalancersArgs.builder()
     *             .filters(            
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-nodebalancer")
     *                     .build(),
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("region")
     *                     .values("us-iad")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerId", specific_nodebalancers.nodebalancers()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     * * `ipv4`
     * 
     * * `ipv6`
     * 
     * * `hostname`
     * 
     * * `region`
     * 
     * * `client_conn_throttle`
     * 
     */
    public static Output<GetNodebalancersResult> getNodebalancers(GetNodebalancersArgs args) {
        return getNodebalancers(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode NodeBalancers that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancers).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode NodeBalancer.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-nodebalancers = LinodeFunctions.getNodebalancers(GetNodebalancersArgs.builder()
     *             .filters(            
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-nodebalancer")
     *                     .build(),
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("region")
     *                     .values("us-iad")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerId", specific_nodebalancers.nodebalancers()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     * * `ipv4`
     * 
     * * `ipv6`
     * 
     * * `hostname`
     * 
     * * `region`
     * 
     * * `client_conn_throttle`
     * 
     */
    public static CompletableFuture<GetNodebalancersResult> getNodebalancersPlain(GetNodebalancersPlainArgs args) {
        return getNodebalancersPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode NodeBalancers that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancers).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode NodeBalancer.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-nodebalancers = LinodeFunctions.getNodebalancers(GetNodebalancersArgs.builder()
     *             .filters(            
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-nodebalancer")
     *                     .build(),
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("region")
     *                     .values("us-iad")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerId", specific_nodebalancers.nodebalancers()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     * * `ipv4`
     * 
     * * `ipv6`
     * 
     * * `hostname`
     * 
     * * `region`
     * 
     * * `client_conn_throttle`
     * 
     */
    public static Output<GetNodebalancersResult> getNodebalancers(GetNodebalancersArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNodebalancers:getNodebalancers", TypeShape.of(GetNodebalancersResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode NodeBalancers that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancers).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode NodeBalancer.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-nodebalancers = LinodeFunctions.getNodebalancers(GetNodebalancersArgs.builder()
     *             .filters(            
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-nodebalancer")
     *                     .build(),
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("region")
     *                     .values("us-iad")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerId", specific_nodebalancers.nodebalancers()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     * * `ipv4`
     * 
     * * `ipv6`
     * 
     * * `hostname`
     * 
     * * `region`
     * 
     * * `client_conn_throttle`
     * 
     */
    public static Output<GetNodebalancersResult> getNodebalancers(GetNodebalancersArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getNodebalancers:getNodebalancers", TypeShape.of(GetNodebalancersResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode NodeBalancers that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-node-balancers).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode NodeBalancer.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetNodebalancersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-nodebalancers = LinodeFunctions.getNodebalancers(GetNodebalancersArgs.builder()
     *             .filters(            
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-nodebalancer")
     *                     .build(),
     *                 GetNodebalancersFilterArgs.builder()
     *                     .name("region")
     *                     .values("us-iad")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("nodebalancerId", specific_nodebalancers.nodebalancers()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     * * `ipv4`
     * 
     * * `ipv6`
     * 
     * * `hostname`
     * 
     * * `region`
     * 
     * * `client_conn_throttle`
     * 
     */
    public static CompletableFuture<GetNodebalancersResult> getNodebalancersPlain(GetNodebalancersPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getNodebalancers:getNodebalancers", TypeShape.of(GetNodebalancersResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Object Storage Cluster
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-cluster).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Object Storage Cluster.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var primary = LinodeFunctions.getObjectStorageCluster(GetObjectStorageClusterArgs.builder()
     *             .id("us-east-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetObjectStorageClusterResult> getObjectStorageCluster(GetObjectStorageClusterArgs args) {
        return getObjectStorageCluster(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Object Storage Cluster
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-cluster).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Object Storage Cluster.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var primary = LinodeFunctions.getObjectStorageCluster(GetObjectStorageClusterArgs.builder()
     *             .id("us-east-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetObjectStorageClusterResult> getObjectStorageClusterPlain(GetObjectStorageClusterPlainArgs args) {
        return getObjectStorageClusterPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Object Storage Cluster
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-cluster).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Object Storage Cluster.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var primary = LinodeFunctions.getObjectStorageCluster(GetObjectStorageClusterArgs.builder()
     *             .id("us-east-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetObjectStorageClusterResult> getObjectStorageCluster(GetObjectStorageClusterArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getObjectStorageCluster:getObjectStorageCluster", TypeShape.of(GetObjectStorageClusterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Object Storage Cluster
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-cluster).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Object Storage Cluster.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var primary = LinodeFunctions.getObjectStorageCluster(GetObjectStorageClusterArgs.builder()
     *             .id("us-east-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetObjectStorageClusterResult> getObjectStorageCluster(GetObjectStorageClusterArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getObjectStorageCluster:getObjectStorageCluster", TypeShape.of(GetObjectStorageClusterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Object Storage Cluster
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-cluster).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Object Storage Cluster.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var primary = LinodeFunctions.getObjectStorageCluster(GetObjectStorageClusterArgs.builder()
     *             .id("us-east-1")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetObjectStorageClusterResult> getObjectStorageClusterPlain(GetObjectStorageClusterPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getObjectStorageCluster:getObjectStorageCluster", TypeShape.of(GetObjectStorageClusterResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Object Storage endpoints available to the user.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-endpoints).
     * 
     * ## Example Usage
     * 
     * Get an endpoint of E3 type (highest performance and capacity) of Linode Object Storage services:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .filters(GetObjectStorageEndpointsFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E3")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("high-performance-obj-endpoint", test.endpoints()[0].s3Endpoint());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get a list of all available endpoints of Linode Object Storage services.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .build());
     * 
     *         ctx.export("available-endpoints", test.endpoints());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `endpoint_type`
     * 
     * * `region`
     * 
     * * `s3_endpoint`
     * 
     */
    public static Output<GetObjectStorageEndpointsResult> getObjectStorageEndpoints() {
        return getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Object Storage endpoints available to the user.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-endpoints).
     * 
     * ## Example Usage
     * 
     * Get an endpoint of E3 type (highest performance and capacity) of Linode Object Storage services:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .filters(GetObjectStorageEndpointsFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E3")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("high-performance-obj-endpoint", test.endpoints()[0].s3Endpoint());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get a list of all available endpoints of Linode Object Storage services.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .build());
     * 
     *         ctx.export("available-endpoints", test.endpoints());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `endpoint_type`
     * 
     * * `region`
     * 
     * * `s3_endpoint`
     * 
     */
    public static CompletableFuture<GetObjectStorageEndpointsResult> getObjectStorageEndpointsPlain() {
        return getObjectStorageEndpointsPlain(GetObjectStorageEndpointsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Object Storage endpoints available to the user.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-endpoints).
     * 
     * ## Example Usage
     * 
     * Get an endpoint of E3 type (highest performance and capacity) of Linode Object Storage services:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .filters(GetObjectStorageEndpointsFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E3")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("high-performance-obj-endpoint", test.endpoints()[0].s3Endpoint());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get a list of all available endpoints of Linode Object Storage services.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .build());
     * 
     *         ctx.export("available-endpoints", test.endpoints());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `endpoint_type`
     * 
     * * `region`
     * 
     * * `s3_endpoint`
     * 
     */
    public static Output<GetObjectStorageEndpointsResult> getObjectStorageEndpoints(GetObjectStorageEndpointsArgs args) {
        return getObjectStorageEndpoints(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Object Storage endpoints available to the user.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-endpoints).
     * 
     * ## Example Usage
     * 
     * Get an endpoint of E3 type (highest performance and capacity) of Linode Object Storage services:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .filters(GetObjectStorageEndpointsFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E3")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("high-performance-obj-endpoint", test.endpoints()[0].s3Endpoint());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get a list of all available endpoints of Linode Object Storage services.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .build());
     * 
     *         ctx.export("available-endpoints", test.endpoints());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `endpoint_type`
     * 
     * * `region`
     * 
     * * `s3_endpoint`
     * 
     */
    public static CompletableFuture<GetObjectStorageEndpointsResult> getObjectStorageEndpointsPlain(GetObjectStorageEndpointsPlainArgs args) {
        return getObjectStorageEndpointsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Object Storage endpoints available to the user.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-endpoints).
     * 
     * ## Example Usage
     * 
     * Get an endpoint of E3 type (highest performance and capacity) of Linode Object Storage services:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .filters(GetObjectStorageEndpointsFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E3")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("high-performance-obj-endpoint", test.endpoints()[0].s3Endpoint());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get a list of all available endpoints of Linode Object Storage services.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .build());
     * 
     *         ctx.export("available-endpoints", test.endpoints());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `endpoint_type`
     * 
     * * `region`
     * 
     * * `s3_endpoint`
     * 
     */
    public static Output<GetObjectStorageEndpointsResult> getObjectStorageEndpoints(GetObjectStorageEndpointsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getObjectStorageEndpoints:getObjectStorageEndpoints", TypeShape.of(GetObjectStorageEndpointsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Object Storage endpoints available to the user.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-endpoints).
     * 
     * ## Example Usage
     * 
     * Get an endpoint of E3 type (highest performance and capacity) of Linode Object Storage services:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .filters(GetObjectStorageEndpointsFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E3")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("high-performance-obj-endpoint", test.endpoints()[0].s3Endpoint());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get a list of all available endpoints of Linode Object Storage services.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .build());
     * 
     *         ctx.export("available-endpoints", test.endpoints());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `endpoint_type`
     * 
     * * `region`
     * 
     * * `s3_endpoint`
     * 
     */
    public static Output<GetObjectStorageEndpointsResult> getObjectStorageEndpoints(GetObjectStorageEndpointsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getObjectStorageEndpoints:getObjectStorageEndpoints", TypeShape.of(GetObjectStorageEndpointsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Object Storage endpoints available to the user.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-endpoints).
     * 
     * ## Example Usage
     * 
     * Get an endpoint of E3 type (highest performance and capacity) of Linode Object Storage services:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .filters(GetObjectStorageEndpointsFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E3")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("high-performance-obj-endpoint", test.endpoints()[0].s3Endpoint());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Get a list of all available endpoints of Linode Object Storage services.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageEndpointsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var test = LinodeFunctions.getObjectStorageEndpoints(GetObjectStorageEndpointsArgs.builder()
     *             .build());
     * 
     *         ctx.export("available-endpoints", test.endpoints());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `endpoint_type`
     * 
     * * `region`
     * 
     * * `s3_endpoint`
     * 
     */
    public static CompletableFuture<GetObjectStorageEndpointsResult> getObjectStorageEndpointsPlain(GetObjectStorageEndpointsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getObjectStorageEndpoints:getObjectStorageEndpoints", TypeShape.of(GetObjectStorageEndpointsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about Object Storage quota information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quota).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about an Object Storage quota.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotaArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myQuota = LinodeFunctions.getObjectStorageQuota(GetObjectStorageQuotaArgs.builder()
     *             .quotaId("obj-buckets-br-gru-1.linodeobjects.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetObjectStorageQuotaResult> getObjectStorageQuota(GetObjectStorageQuotaArgs args) {
        return getObjectStorageQuota(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about Object Storage quota information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quota).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about an Object Storage quota.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotaArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myQuota = LinodeFunctions.getObjectStorageQuota(GetObjectStorageQuotaArgs.builder()
     *             .quotaId("obj-buckets-br-gru-1.linodeobjects.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetObjectStorageQuotaResult> getObjectStorageQuotaPlain(GetObjectStorageQuotaPlainArgs args) {
        return getObjectStorageQuotaPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about Object Storage quota information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quota).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about an Object Storage quota.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotaArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myQuota = LinodeFunctions.getObjectStorageQuota(GetObjectStorageQuotaArgs.builder()
     *             .quotaId("obj-buckets-br-gru-1.linodeobjects.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetObjectStorageQuotaResult> getObjectStorageQuota(GetObjectStorageQuotaArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getObjectStorageQuota:getObjectStorageQuota", TypeShape.of(GetObjectStorageQuotaResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about Object Storage quota information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quota).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about an Object Storage quota.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotaArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myQuota = LinodeFunctions.getObjectStorageQuota(GetObjectStorageQuotaArgs.builder()
     *             .quotaId("obj-buckets-br-gru-1.linodeobjects.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetObjectStorageQuotaResult> getObjectStorageQuota(GetObjectStorageQuotaArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getObjectStorageQuota:getObjectStorageQuota", TypeShape.of(GetObjectStorageQuotaResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about Object Storage quota information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quota).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about an Object Storage quota.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotaArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myQuota = LinodeFunctions.getObjectStorageQuota(GetObjectStorageQuotaArgs.builder()
     *             .quotaId("obj-buckets-br-gru-1.linodeobjects.com")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetObjectStorageQuotaResult> getObjectStorageQuotaPlain(GetObjectStorageQuotaPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getObjectStorageQuota:getObjectStorageQuota", TypeShape.of(GetObjectStorageQuotaResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a list of Object Storage quotas information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quotas).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list and filter information about Object Storage quotas.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotasArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var maxBucketsQuotas = LinodeFunctions.getObjectStorageQuotas(GetObjectStorageQuotasArgs.builder()
     *             .filters(GetObjectStorageQuotasFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E0")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `quota_id`
     * 
     * * `quota_name`
     * 
     * * `endpoint_type`
     * 
     * * `s3_endpoint`
     * 
     * * `description`
     * 
     * * `quota_limit`
     * 
     * * `resource_metric`
     * 
     */
    public static Output<GetObjectStorageQuotasResult> getObjectStorageQuotas() {
        return getObjectStorageQuotas(GetObjectStorageQuotasArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides details about a list of Object Storage quotas information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quotas).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list and filter information about Object Storage quotas.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotasArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var maxBucketsQuotas = LinodeFunctions.getObjectStorageQuotas(GetObjectStorageQuotasArgs.builder()
     *             .filters(GetObjectStorageQuotasFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E0")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `quota_id`
     * 
     * * `quota_name`
     * 
     * * `endpoint_type`
     * 
     * * `s3_endpoint`
     * 
     * * `description`
     * 
     * * `quota_limit`
     * 
     * * `resource_metric`
     * 
     */
    public static CompletableFuture<GetObjectStorageQuotasResult> getObjectStorageQuotasPlain() {
        return getObjectStorageQuotasPlain(GetObjectStorageQuotasPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides details about a list of Object Storage quotas information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quotas).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list and filter information about Object Storage quotas.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotasArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var maxBucketsQuotas = LinodeFunctions.getObjectStorageQuotas(GetObjectStorageQuotasArgs.builder()
     *             .filters(GetObjectStorageQuotasFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E0")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `quota_id`
     * 
     * * `quota_name`
     * 
     * * `endpoint_type`
     * 
     * * `s3_endpoint`
     * 
     * * `description`
     * 
     * * `quota_limit`
     * 
     * * `resource_metric`
     * 
     */
    public static Output<GetObjectStorageQuotasResult> getObjectStorageQuotas(GetObjectStorageQuotasArgs args) {
        return getObjectStorageQuotas(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a list of Object Storage quotas information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quotas).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list and filter information about Object Storage quotas.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotasArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var maxBucketsQuotas = LinodeFunctions.getObjectStorageQuotas(GetObjectStorageQuotasArgs.builder()
     *             .filters(GetObjectStorageQuotasFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E0")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `quota_id`
     * 
     * * `quota_name`
     * 
     * * `endpoint_type`
     * 
     * * `s3_endpoint`
     * 
     * * `description`
     * 
     * * `quota_limit`
     * 
     * * `resource_metric`
     * 
     */
    public static CompletableFuture<GetObjectStorageQuotasResult> getObjectStorageQuotasPlain(GetObjectStorageQuotasPlainArgs args) {
        return getObjectStorageQuotasPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a list of Object Storage quotas information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quotas).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list and filter information about Object Storage quotas.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotasArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var maxBucketsQuotas = LinodeFunctions.getObjectStorageQuotas(GetObjectStorageQuotasArgs.builder()
     *             .filters(GetObjectStorageQuotasFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E0")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `quota_id`
     * 
     * * `quota_name`
     * 
     * * `endpoint_type`
     * 
     * * `s3_endpoint`
     * 
     * * `description`
     * 
     * * `quota_limit`
     * 
     * * `resource_metric`
     * 
     */
    public static Output<GetObjectStorageQuotasResult> getObjectStorageQuotas(GetObjectStorageQuotasArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getObjectStorageQuotas:getObjectStorageQuotas", TypeShape.of(GetObjectStorageQuotasResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a list of Object Storage quotas information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quotas).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list and filter information about Object Storage quotas.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotasArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var maxBucketsQuotas = LinodeFunctions.getObjectStorageQuotas(GetObjectStorageQuotasArgs.builder()
     *             .filters(GetObjectStorageQuotasFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E0")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `quota_id`
     * 
     * * `quota_name`
     * 
     * * `endpoint_type`
     * 
     * * `s3_endpoint`
     * 
     * * `description`
     * 
     * * `quota_limit`
     * 
     * * `resource_metric`
     * 
     */
    public static Output<GetObjectStorageQuotasResult> getObjectStorageQuotas(GetObjectStorageQuotasArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getObjectStorageQuotas:getObjectStorageQuotas", TypeShape.of(GetObjectStorageQuotasResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a list of Object Storage quotas information on your account.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-object-storage-quotas).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list and filter information about Object Storage quotas.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetObjectStorageQuotasArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var maxBucketsQuotas = LinodeFunctions.getObjectStorageQuotas(GetObjectStorageQuotasArgs.builder()
     *             .filters(GetObjectStorageQuotasFilterArgs.builder()
     *                 .name("endpoint_type")
     *                 .values("E0")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `quota_id`
     * 
     * * `quota_name`
     * 
     * * `endpoint_type`
     * 
     * * `s3_endpoint`
     * 
     * * `description`
     * 
     * * `quota_limit`
     * 
     * * `resource_metric`
     * 
     */
    public static CompletableFuture<GetObjectStorageQuotasResult> getObjectStorageQuotasPlain(GetObjectStorageQuotasPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getObjectStorageQuotas:getObjectStorageQuotas", TypeShape.of(GetObjectStorageQuotasResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.PlacementGroup` provides details about a Linode placement group.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-group).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain additional information about a Linode placement group.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var pg = LinodeFunctions.getPlacementGroup(GetPlacementGroupArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetPlacementGroupResult> getPlacementGroup(GetPlacementGroupArgs args) {
        return getPlacementGroup(args, InvokeOptions.Empty);
    }
    /**
     * `linode.PlacementGroup` provides details about a Linode placement group.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-group).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain additional information about a Linode placement group.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var pg = LinodeFunctions.getPlacementGroup(GetPlacementGroupArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetPlacementGroupResult> getPlacementGroupPlain(GetPlacementGroupPlainArgs args) {
        return getPlacementGroupPlain(args, InvokeOptions.Empty);
    }
    /**
     * `linode.PlacementGroup` provides details about a Linode placement group.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-group).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain additional information about a Linode placement group.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var pg = LinodeFunctions.getPlacementGroup(GetPlacementGroupArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetPlacementGroupResult> getPlacementGroup(GetPlacementGroupArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getPlacementGroup:getPlacementGroup", TypeShape.of(GetPlacementGroupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.PlacementGroup` provides details about a Linode placement group.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-group).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain additional information about a Linode placement group.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var pg = LinodeFunctions.getPlacementGroup(GetPlacementGroupArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetPlacementGroupResult> getPlacementGroup(GetPlacementGroupArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getPlacementGroup:getPlacementGroup", TypeShape.of(GetPlacementGroupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.PlacementGroup` provides details about a Linode placement group.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-group).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain additional information about a Linode placement group.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var pg = LinodeFunctions.getPlacementGroup(GetPlacementGroupArgs.builder()
     *             .id(12345)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetPlacementGroupResult> getPlacementGroupPlain(GetPlacementGroupPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getPlacementGroup:getPlacementGroup", TypeShape.of(GetPlacementGroupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode Placement Groups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-groups).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list Placement Groups.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .filters(GetPlacementGroupsFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-label")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("all-pgs", all.placementGroups());
     *         ctx.export("filtered-pgs", filtered.placementGroups());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `placement_group_type`
     * 
     * * `placement_group_policy`
     * 
     * * `is_compliant`
     * 
     */
    public static Output<GetPlacementGroupsResult> getPlacementGroups() {
        return getPlacementGroups(GetPlacementGroupsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode Placement Groups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-groups).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list Placement Groups.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .filters(GetPlacementGroupsFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-label")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("all-pgs", all.placementGroups());
     *         ctx.export("filtered-pgs", filtered.placementGroups());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `placement_group_type`
     * 
     * * `placement_group_policy`
     * 
     * * `is_compliant`
     * 
     */
    public static CompletableFuture<GetPlacementGroupsResult> getPlacementGroupsPlain() {
        return getPlacementGroupsPlain(GetPlacementGroupsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode Placement Groups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-groups).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list Placement Groups.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .filters(GetPlacementGroupsFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-label")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("all-pgs", all.placementGroups());
     *         ctx.export("filtered-pgs", filtered.placementGroups());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `placement_group_type`
     * 
     * * `placement_group_policy`
     * 
     * * `is_compliant`
     * 
     */
    public static Output<GetPlacementGroupsResult> getPlacementGroups(GetPlacementGroupsArgs args) {
        return getPlacementGroups(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode Placement Groups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-groups).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list Placement Groups.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .filters(GetPlacementGroupsFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-label")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("all-pgs", all.placementGroups());
     *         ctx.export("filtered-pgs", filtered.placementGroups());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `placement_group_type`
     * 
     * * `placement_group_policy`
     * 
     * * `is_compliant`
     * 
     */
    public static CompletableFuture<GetPlacementGroupsResult> getPlacementGroupsPlain(GetPlacementGroupsPlainArgs args) {
        return getPlacementGroupsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode Placement Groups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-groups).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list Placement Groups.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .filters(GetPlacementGroupsFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-label")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("all-pgs", all.placementGroups());
     *         ctx.export("filtered-pgs", filtered.placementGroups());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `placement_group_type`
     * 
     * * `placement_group_policy`
     * 
     * * `is_compliant`
     * 
     */
    public static Output<GetPlacementGroupsResult> getPlacementGroups(GetPlacementGroupsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getPlacementGroups:getPlacementGroups", TypeShape.of(GetPlacementGroupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode Placement Groups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-groups).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list Placement Groups.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .filters(GetPlacementGroupsFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-label")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("all-pgs", all.placementGroups());
     *         ctx.export("filtered-pgs", filtered.placementGroups());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `placement_group_type`
     * 
     * * `placement_group_policy`
     * 
     * * `is_compliant`
     * 
     */
    public static Output<GetPlacementGroupsResult> getPlacementGroups(GetPlacementGroupsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getPlacementGroups:getPlacementGroups", TypeShape.of(GetPlacementGroupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode Placement Groups that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-placement-groups).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list Placement Groups.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetPlacementGroupsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var all = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .build());
     * 
     *         final var filtered = LinodeFunctions.getPlacementGroups(GetPlacementGroupsArgs.builder()
     *             .filters(GetPlacementGroupsFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-label")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("all-pgs", all.placementGroups());
     *         ctx.export("filtered-pgs", filtered.placementGroups());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `region`
     * 
     * * `placement_group_type`
     * 
     * * `placement_group_policy`
     * 
     * * `is_compliant`
     * 
     */
    public static CompletableFuture<GetPlacementGroupsResult> getPlacementGroupsPlain(GetPlacementGroupsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getPlacementGroups:getPlacementGroups", TypeShape.of(GetPlacementGroupsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode profile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-profile).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access profile details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var profile = LinodeFunctions.getProfile(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetProfileResult> getProfile() {
        return getProfile(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode profile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-profile).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access profile details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var profile = LinodeFunctions.getProfile(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetProfileResult> getProfilePlain() {
        return getProfilePlain(InvokeArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode profile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-profile).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access profile details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var profile = LinodeFunctions.getProfile(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetProfileResult> getProfile(InvokeArgs args) {
        return getProfile(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode profile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-profile).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access profile details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var profile = LinodeFunctions.getProfile(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetProfileResult> getProfilePlain(InvokeArgs args) {
        return getProfilePlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode profile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-profile).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access profile details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var profile = LinodeFunctions.getProfile(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetProfileResult> getProfile(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getProfile:getProfile", TypeShape.of(GetProfileResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode profile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-profile).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access profile details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var profile = LinodeFunctions.getProfile(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetProfileResult> getProfile(InvokeArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getProfile:getProfile", TypeShape.of(GetProfileResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode profile.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-profile).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access profile details.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var profile = LinodeFunctions.getProfile(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetProfileResult> getProfilePlain(InvokeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getProfile:getProfile", TypeShape.of(GetProfileResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.getRegion` provides details about a specific Linode region. See all regions [here](https://api.linode.com/v4/regions).
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-region).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain additional information about a Linode region.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var region = LinodeFunctions.getRegion(GetRegionArgs.builder()
     *             .id("us-east")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetRegionResult> getRegion(GetRegionArgs args) {
        return getRegion(args, InvokeOptions.Empty);
    }
    /**
     * `linode.getRegion` provides details about a specific Linode region. See all regions [here](https://api.linode.com/v4/regions).
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-region).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain additional information about a Linode region.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var region = LinodeFunctions.getRegion(GetRegionArgs.builder()
     *             .id("us-east")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetRegionResult> getRegionPlain(GetRegionPlainArgs args) {
        return getRegionPlain(args, InvokeOptions.Empty);
    }
    /**
     * `linode.getRegion` provides details about a specific Linode region. See all regions [here](https://api.linode.com/v4/regions).
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-region).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain additional information about a Linode region.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var region = LinodeFunctions.getRegion(GetRegionArgs.builder()
     *             .id("us-east")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetRegionResult> getRegion(GetRegionArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getRegion:getRegion", TypeShape.of(GetRegionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.getRegion` provides details about a specific Linode region. See all regions [here](https://api.linode.com/v4/regions).
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-region).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain additional information about a Linode region.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var region = LinodeFunctions.getRegion(GetRegionArgs.builder()
     *             .id("us-east")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetRegionResult> getRegion(GetRegionArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getRegion:getRegion", TypeShape.of(GetRegionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.getRegion` provides details about a specific Linode region. See all regions [here](https://api.linode.com/v4/regions).
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-region).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain additional information about a Linode region.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var region = LinodeFunctions.getRegion(GetRegionArgs.builder()
     *             .id("us-east")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetRegionResult> getRegionPlain(GetRegionPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getRegion:getRegion", TypeShape.of(GetRegionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode regions that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-regions).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-regions = LinodeFunctions.getRegions(GetRegionsArgs.builder()
     *             .filters(            
     *                 GetRegionsFilterArgs.builder()
     *                     .name("status")
     *                     .values("ok")
     *                     .build(),
     *                 GetRegionsFilterArgs.builder()
     *                     .name("capabilities")
     *                     .values("NodeBalancers")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("regions", filtered_regions.regions());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `status`
     * 
     * * `country`
     * 
     * * `capabilities`
     * 
     * * `site_type`
     * 
     */
    public static Output<GetRegionsResult> getRegions() {
        return getRegions(GetRegionsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode regions that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-regions).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-regions = LinodeFunctions.getRegions(GetRegionsArgs.builder()
     *             .filters(            
     *                 GetRegionsFilterArgs.builder()
     *                     .name("status")
     *                     .values("ok")
     *                     .build(),
     *                 GetRegionsFilterArgs.builder()
     *                     .name("capabilities")
     *                     .values("NodeBalancers")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("regions", filtered_regions.regions());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `status`
     * 
     * * `country`
     * 
     * * `capabilities`
     * 
     * * `site_type`
     * 
     */
    public static CompletableFuture<GetRegionsResult> getRegionsPlain() {
        return getRegionsPlain(GetRegionsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode regions that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-regions).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-regions = LinodeFunctions.getRegions(GetRegionsArgs.builder()
     *             .filters(            
     *                 GetRegionsFilterArgs.builder()
     *                     .name("status")
     *                     .values("ok")
     *                     .build(),
     *                 GetRegionsFilterArgs.builder()
     *                     .name("capabilities")
     *                     .values("NodeBalancers")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("regions", filtered_regions.regions());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `status`
     * 
     * * `country`
     * 
     * * `capabilities`
     * 
     * * `site_type`
     * 
     */
    public static Output<GetRegionsResult> getRegions(GetRegionsArgs args) {
        return getRegions(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode regions that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-regions).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-regions = LinodeFunctions.getRegions(GetRegionsArgs.builder()
     *             .filters(            
     *                 GetRegionsFilterArgs.builder()
     *                     .name("status")
     *                     .values("ok")
     *                     .build(),
     *                 GetRegionsFilterArgs.builder()
     *                     .name("capabilities")
     *                     .values("NodeBalancers")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("regions", filtered_regions.regions());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `status`
     * 
     * * `country`
     * 
     * * `capabilities`
     * 
     * * `site_type`
     * 
     */
    public static CompletableFuture<GetRegionsResult> getRegionsPlain(GetRegionsPlainArgs args) {
        return getRegionsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode regions that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-regions).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-regions = LinodeFunctions.getRegions(GetRegionsArgs.builder()
     *             .filters(            
     *                 GetRegionsFilterArgs.builder()
     *                     .name("status")
     *                     .values("ok")
     *                     .build(),
     *                 GetRegionsFilterArgs.builder()
     *                     .name("capabilities")
     *                     .values("NodeBalancers")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("regions", filtered_regions.regions());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `status`
     * 
     * * `country`
     * 
     * * `capabilities`
     * 
     * * `site_type`
     * 
     */
    public static Output<GetRegionsResult> getRegions(GetRegionsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getRegions:getRegions", TypeShape.of(GetRegionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode regions that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-regions).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-regions = LinodeFunctions.getRegions(GetRegionsArgs.builder()
     *             .filters(            
     *                 GetRegionsFilterArgs.builder()
     *                     .name("status")
     *                     .values("ok")
     *                     .build(),
     *                 GetRegionsFilterArgs.builder()
     *                     .name("capabilities")
     *                     .values("NodeBalancers")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("regions", filtered_regions.regions());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `status`
     * 
     * * `country`
     * 
     * * `capabilities`
     * 
     * * `site_type`
     * 
     */
    public static Output<GetRegionsResult> getRegions(GetRegionsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getRegions:getRegions", TypeShape.of(GetRegionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode regions that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-regions).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetRegionsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-regions = LinodeFunctions.getRegions(GetRegionsArgs.builder()
     *             .filters(            
     *                 GetRegionsFilterArgs.builder()
     *                     .name("status")
     *                     .values("ok")
     *                     .build(),
     *                 GetRegionsFilterArgs.builder()
     *                     .name("capabilities")
     *                     .values("NodeBalancers")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("regions", filtered_regions.regions());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `status`
     * 
     * * `country`
     * 
     * * `capabilities`
     * 
     * * `site_type`
     * 
     */
    public static CompletableFuture<GetRegionsResult> getRegionsPlain(GetRegionsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getRegions:getRegions", TypeShape.of(GetRegionsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.SshKey` provides access to a specifically labeled SSH Key in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-key).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the name of the SSH Key configured on the Linode user profile.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshKeyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getSshKey(GetSshKeyArgs.builder()
     *             .label("foo")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetSshKeyResult> getSshKey(GetSshKeyArgs args) {
        return getSshKey(args, InvokeOptions.Empty);
    }
    /**
     * `linode.SshKey` provides access to a specifically labeled SSH Key in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-key).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the name of the SSH Key configured on the Linode user profile.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshKeyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getSshKey(GetSshKeyArgs.builder()
     *             .label("foo")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetSshKeyResult> getSshKeyPlain(GetSshKeyPlainArgs args) {
        return getSshKeyPlain(args, InvokeOptions.Empty);
    }
    /**
     * `linode.SshKey` provides access to a specifically labeled SSH Key in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-key).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the name of the SSH Key configured on the Linode user profile.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshKeyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getSshKey(GetSshKeyArgs.builder()
     *             .label("foo")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetSshKeyResult> getSshKey(GetSshKeyArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getSshKey:getSshKey", TypeShape.of(GetSshKeyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.SshKey` provides access to a specifically labeled SSH Key in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-key).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the name of the SSH Key configured on the Linode user profile.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshKeyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getSshKey(GetSshKeyArgs.builder()
     *             .label("foo")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetSshKeyResult> getSshKey(GetSshKeyArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getSshKey:getSshKey", TypeShape.of(GetSshKeyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.SshKey` provides access to a specifically labeled SSH Key in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-key).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the name of the SSH Key configured on the Linode user profile.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshKeyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getSshKey(GetSshKeyArgs.builder()
     *             .label("foo")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetSshKeyResult> getSshKeyPlain(GetSshKeyPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getSshKey:getSshKey", TypeShape.of(GetSshKeyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.SshKey` provides access to a filtered list of SSH Keys in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-keys).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the names of the SSH Keys configured on the Linode user profile.
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshkeysArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredSsh = LinodeFunctions.getSshkeys(GetSshkeysArgs.builder()
     *             .filters(            
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-ssh")
     *                     .build(),
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("ssh_key")
     *                     .values("RSA-6522525")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ssh_key`
     * 
     */
    public static Output<GetSshkeysResult> getSshkeys() {
        return getSshkeys(GetSshkeysArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * `linode.SshKey` provides access to a filtered list of SSH Keys in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-keys).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the names of the SSH Keys configured on the Linode user profile.
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshkeysArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredSsh = LinodeFunctions.getSshkeys(GetSshkeysArgs.builder()
     *             .filters(            
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-ssh")
     *                     .build(),
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("ssh_key")
     *                     .values("RSA-6522525")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ssh_key`
     * 
     */
    public static CompletableFuture<GetSshkeysResult> getSshkeysPlain() {
        return getSshkeysPlain(GetSshkeysPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * `linode.SshKey` provides access to a filtered list of SSH Keys in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-keys).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the names of the SSH Keys configured on the Linode user profile.
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshkeysArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredSsh = LinodeFunctions.getSshkeys(GetSshkeysArgs.builder()
     *             .filters(            
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-ssh")
     *                     .build(),
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("ssh_key")
     *                     .values("RSA-6522525")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ssh_key`
     * 
     */
    public static Output<GetSshkeysResult> getSshkeys(GetSshkeysArgs args) {
        return getSshkeys(args, InvokeOptions.Empty);
    }
    /**
     * `linode.SshKey` provides access to a filtered list of SSH Keys in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-keys).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the names of the SSH Keys configured on the Linode user profile.
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshkeysArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredSsh = LinodeFunctions.getSshkeys(GetSshkeysArgs.builder()
     *             .filters(            
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-ssh")
     *                     .build(),
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("ssh_key")
     *                     .values("RSA-6522525")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ssh_key`
     * 
     */
    public static CompletableFuture<GetSshkeysResult> getSshkeysPlain(GetSshkeysPlainArgs args) {
        return getSshkeysPlain(args, InvokeOptions.Empty);
    }
    /**
     * `linode.SshKey` provides access to a filtered list of SSH Keys in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-keys).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the names of the SSH Keys configured on the Linode user profile.
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshkeysArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredSsh = LinodeFunctions.getSshkeys(GetSshkeysArgs.builder()
     *             .filters(            
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-ssh")
     *                     .build(),
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("ssh_key")
     *                     .values("RSA-6522525")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ssh_key`
     * 
     */
    public static Output<GetSshkeysResult> getSshkeys(GetSshkeysArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getSshkeys:getSshkeys", TypeShape.of(GetSshkeysResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.SshKey` provides access to a filtered list of SSH Keys in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-keys).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the names of the SSH Keys configured on the Linode user profile.
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshkeysArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredSsh = LinodeFunctions.getSshkeys(GetSshkeysArgs.builder()
     *             .filters(            
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-ssh")
     *                     .build(),
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("ssh_key")
     *                     .values("RSA-6522525")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ssh_key`
     * 
     */
    public static Output<GetSshkeysResult> getSshkeys(GetSshkeysArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getSshkeys:getSshkeys", TypeShape.of(GetSshkeysResult.class), args, Utilities.withVersion(options));
    }
    /**
     * `linode.SshKey` provides access to a filtered list of SSH Keys in the Profile of the User identified by the access token.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-ssh-keys).
     * 
     * ## Example Usage
     * 
     * The following example shows how the resource might be used to obtain the names of the SSH Keys configured on the Linode user profile.
     * 
     * The following example shows how one might use this data source to access information about a Linode Kernel.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetSshkeysArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filteredSsh = LinodeFunctions.getSshkeys(GetSshkeysArgs.builder()
     *             .filters(            
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-ssh")
     *                     .build(),
     *                 GetSshkeysFilterArgs.builder()
     *                     .name("ssh_key")
     *                     .values("RSA-6522525")
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ssh_key`
     * 
     */
    public static CompletableFuture<GetSshkeysResult> getSshkeysPlain(GetSshkeysPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getSshkeys:getSshkeys", TypeShape.of(GetSshkeysResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a specific Linode StackScript.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-script).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myStackscript = LinodeFunctions.getStackScript(GetStackScriptArgs.builder()
     *             .id("355872")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetStackScriptResult> getStackScript(GetStackScriptArgs args) {
        return getStackScript(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a specific Linode StackScript.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-script).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myStackscript = LinodeFunctions.getStackScript(GetStackScriptArgs.builder()
     *             .id("355872")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetStackScriptResult> getStackScriptPlain(GetStackScriptPlainArgs args) {
        return getStackScriptPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides details about a specific Linode StackScript.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-script).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myStackscript = LinodeFunctions.getStackScript(GetStackScriptArgs.builder()
     *             .id("355872")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetStackScriptResult> getStackScript(GetStackScriptArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getStackScript:getStackScript", TypeShape.of(GetStackScriptResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a specific Linode StackScript.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-script).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myStackscript = LinodeFunctions.getStackScript(GetStackScriptArgs.builder()
     *             .id("355872")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetStackScriptResult> getStackScript(GetStackScriptArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getStackScript:getStackScript", TypeShape.of(GetStackScriptResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides details about a specific Linode StackScript.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-script).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var myStackscript = LinodeFunctions.getStackScript(GetStackScriptArgs.builder()
     *             .id("355872")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetStackScriptResult> getStackScriptPlain(GetStackScriptPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getStackScript:getStackScript", TypeShape.of(GetStackScriptResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode StackScripts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-scripts).
     * 
     * **NOTICE:** Due to the large number of public StackScripts, this data source may time out if `is_public` is not filtered on.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-stackscripts = LinodeFunctions.getStackScripts(GetStackScriptsArgs.builder()
     *             .filters(            
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-cool-stackscript")
     *                     .build(),
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("false")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("stackscriptId", specific_stackscripts.stackscripts()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `deployments_active`
     * 
     * * `deployments_total`
     * 
     * * `description`
     * 
     * * `images`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `mine`
     * 
     * * `rev_note`
     * 
     * * `username`
     * 
     */
    public static Output<GetStackScriptsResult> getStackScripts() {
        return getStackScripts(GetStackScriptsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode StackScripts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-scripts).
     * 
     * **NOTICE:** Due to the large number of public StackScripts, this data source may time out if `is_public` is not filtered on.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-stackscripts = LinodeFunctions.getStackScripts(GetStackScriptsArgs.builder()
     *             .filters(            
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-cool-stackscript")
     *                     .build(),
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("false")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("stackscriptId", specific_stackscripts.stackscripts()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `deployments_active`
     * 
     * * `deployments_total`
     * 
     * * `description`
     * 
     * * `images`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `mine`
     * 
     * * `rev_note`
     * 
     * * `username`
     * 
     */
    public static CompletableFuture<GetStackScriptsResult> getStackScriptsPlain() {
        return getStackScriptsPlain(GetStackScriptsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode StackScripts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-scripts).
     * 
     * **NOTICE:** Due to the large number of public StackScripts, this data source may time out if `is_public` is not filtered on.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-stackscripts = LinodeFunctions.getStackScripts(GetStackScriptsArgs.builder()
     *             .filters(            
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-cool-stackscript")
     *                     .build(),
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("false")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("stackscriptId", specific_stackscripts.stackscripts()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `deployments_active`
     * 
     * * `deployments_total`
     * 
     * * `description`
     * 
     * * `images`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `mine`
     * 
     * * `rev_note`
     * 
     * * `username`
     * 
     */
    public static Output<GetStackScriptsResult> getStackScripts(GetStackScriptsArgs args) {
        return getStackScripts(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode StackScripts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-scripts).
     * 
     * **NOTICE:** Due to the large number of public StackScripts, this data source may time out if `is_public` is not filtered on.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-stackscripts = LinodeFunctions.getStackScripts(GetStackScriptsArgs.builder()
     *             .filters(            
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-cool-stackscript")
     *                     .build(),
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("false")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("stackscriptId", specific_stackscripts.stackscripts()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `deployments_active`
     * 
     * * `deployments_total`
     * 
     * * `description`
     * 
     * * `images`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `mine`
     * 
     * * `rev_note`
     * 
     * * `username`
     * 
     */
    public static CompletableFuture<GetStackScriptsResult> getStackScriptsPlain(GetStackScriptsPlainArgs args) {
        return getStackScriptsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode StackScripts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-scripts).
     * 
     * **NOTICE:** Due to the large number of public StackScripts, this data source may time out if `is_public` is not filtered on.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-stackscripts = LinodeFunctions.getStackScripts(GetStackScriptsArgs.builder()
     *             .filters(            
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-cool-stackscript")
     *                     .build(),
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("false")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("stackscriptId", specific_stackscripts.stackscripts()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `deployments_active`
     * 
     * * `deployments_total`
     * 
     * * `description`
     * 
     * * `images`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `mine`
     * 
     * * `rev_note`
     * 
     * * `username`
     * 
     */
    public static Output<GetStackScriptsResult> getStackScripts(GetStackScriptsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getStackScripts:getStackScripts", TypeShape.of(GetStackScriptsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode StackScripts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-scripts).
     * 
     * **NOTICE:** Due to the large number of public StackScripts, this data source may time out if `is_public` is not filtered on.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-stackscripts = LinodeFunctions.getStackScripts(GetStackScriptsArgs.builder()
     *             .filters(            
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-cool-stackscript")
     *                     .build(),
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("false")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("stackscriptId", specific_stackscripts.stackscripts()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `deployments_active`
     * 
     * * `deployments_total`
     * 
     * * `description`
     * 
     * * `images`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `mine`
     * 
     * * `rev_note`
     * 
     * * `username`
     * 
     */
    public static Output<GetStackScriptsResult> getStackScripts(GetStackScriptsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getStackScripts:getStackScripts", TypeShape.of(GetStackScriptsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode StackScripts that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-stack-scripts).
     * 
     * **NOTICE:** Due to the large number of public StackScripts, this data source may time out if `is_public` is not filtered on.
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode StackScript.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetStackScriptsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-stackscripts = LinodeFunctions.getStackScripts(GetStackScriptsArgs.builder()
     *             .filters(            
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("label")
     *                     .values("my-cool-stackscript")
     *                     .build(),
     *                 GetStackScriptsFilterArgs.builder()
     *                     .name("is_public")
     *                     .values("false")
     *                     .build())
     *             .build());
     * 
     *         ctx.export("stackscriptId", specific_stackscripts.stackscripts()[0].id());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `deployments_active`
     * 
     * * `deployments_total`
     * 
     * * `description`
     * 
     * * `images`
     * 
     * * `is_public`
     * 
     * * `label`
     * 
     * * `mine`
     * 
     * * `rev_note`
     * 
     * * `username`
     * 
     */
    public static CompletableFuture<GetStackScriptsResult> getStackScriptsPlain(GetStackScriptsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getStackScripts:getStackScripts", TypeShape.of(GetStackScriptsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode user
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-user).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode user.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getUser(GetUserArgs.builder()
     *             .username("foo")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows a sample grant.
     * 
     */
    public static Output<GetUserResult> getUser(GetUserArgs args) {
        return getUser(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode user
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-user).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode user.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getUser(GetUserArgs.builder()
     *             .username("foo")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows a sample grant.
     * 
     */
    public static CompletableFuture<GetUserResult> getUserPlain(GetUserPlainArgs args) {
        return getUserPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode user
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-user).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode user.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getUser(GetUserArgs.builder()
     *             .username("foo")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows a sample grant.
     * 
     */
    public static Output<GetUserResult> getUser(GetUserArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getUser:getUser", TypeShape.of(GetUserResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode user
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-user).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode user.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getUser(GetUserArgs.builder()
     *             .username("foo")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows a sample grant.
     * 
     */
    public static Output<GetUserResult> getUser(GetUserArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getUser:getUser", TypeShape.of(GetUserResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode user
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-user).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode user.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getUser(GetUserArgs.builder()
     *             .username("foo")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * The following example shows a sample grant.
     * 
     */
    public static CompletableFuture<GetUserResult> getUserPlain(GetUserPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getUser:getUser", TypeShape.of(GetUserResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode users that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-users).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUsersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-users = LinodeFunctions.getUsers(GetUsersArgs.builder()
     *             .filters(GetUsersFilterArgs.builder()
     *                 .name("username")
     *                 .values("test-user")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("users", filtered_users.users());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `username`
     * 
     * * `email`
     * 
     * * `restricted`
     * 
     * * `user_type`
     * 
     * * `password_created`
     * 
     * * `tfa_enabled`
     * 
     * * `verfied_phone_number`
     * 
     */
    public static Output<GetUsersResult> getUsers() {
        return getUsers(GetUsersArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode users that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-users).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUsersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-users = LinodeFunctions.getUsers(GetUsersArgs.builder()
     *             .filters(GetUsersFilterArgs.builder()
     *                 .name("username")
     *                 .values("test-user")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("users", filtered_users.users());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `username`
     * 
     * * `email`
     * 
     * * `restricted`
     * 
     * * `user_type`
     * 
     * * `password_created`
     * 
     * * `tfa_enabled`
     * 
     * * `verfied_phone_number`
     * 
     */
    public static CompletableFuture<GetUsersResult> getUsersPlain() {
        return getUsersPlain(GetUsersPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode users that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-users).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUsersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-users = LinodeFunctions.getUsers(GetUsersArgs.builder()
     *             .filters(GetUsersFilterArgs.builder()
     *                 .name("username")
     *                 .values("test-user")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("users", filtered_users.users());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `username`
     * 
     * * `email`
     * 
     * * `restricted`
     * 
     * * `user_type`
     * 
     * * `password_created`
     * 
     * * `tfa_enabled`
     * 
     * * `verfied_phone_number`
     * 
     */
    public static Output<GetUsersResult> getUsers(GetUsersArgs args) {
        return getUsers(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode users that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-users).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUsersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-users = LinodeFunctions.getUsers(GetUsersArgs.builder()
     *             .filters(GetUsersFilterArgs.builder()
     *                 .name("username")
     *                 .values("test-user")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("users", filtered_users.users());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `username`
     * 
     * * `email`
     * 
     * * `restricted`
     * 
     * * `user_type`
     * 
     * * `password_created`
     * 
     * * `tfa_enabled`
     * 
     * * `verfied_phone_number`
     * 
     */
    public static CompletableFuture<GetUsersResult> getUsersPlain(GetUsersPlainArgs args) {
        return getUsersPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode users that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-users).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUsersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-users = LinodeFunctions.getUsers(GetUsersArgs.builder()
     *             .filters(GetUsersFilterArgs.builder()
     *                 .name("username")
     *                 .values("test-user")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("users", filtered_users.users());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `username`
     * 
     * * `email`
     * 
     * * `restricted`
     * 
     * * `user_type`
     * 
     * * `password_created`
     * 
     * * `tfa_enabled`
     * 
     * * `verfied_phone_number`
     * 
     */
    public static Output<GetUsersResult> getUsers(GetUsersArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getUsers:getUsers", TypeShape.of(GetUsersResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode users that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-users).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUsersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-users = LinodeFunctions.getUsers(GetUsersArgs.builder()
     *             .filters(GetUsersFilterArgs.builder()
     *                 .name("username")
     *                 .values("test-user")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("users", filtered_users.users());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `username`
     * 
     * * `email`
     * 
     * * `restricted`
     * 
     * * `user_type`
     * 
     * * `password_created`
     * 
     * * `tfa_enabled`
     * 
     * * `verfied_phone_number`
     * 
     */
    public static Output<GetUsersResult> getUsers(GetUsersArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getUsers:getUsers", TypeShape.of(GetUsersResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode users that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-users).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetUsersArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-users = LinodeFunctions.getUsers(GetUsersArgs.builder()
     *             .filters(GetUsersFilterArgs.builder()
     *                 .name("username")
     *                 .values("test-user")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("users", filtered_users.users());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `username`
     * 
     * * `email`
     * 
     * * `restricted`
     * 
     * * `user_type`
     * 
     * * `password_created`
     * 
     * * `tfa_enabled`
     * 
     * * `verfied_phone_number`
     * 
     */
    public static CompletableFuture<GetUsersResult> getUsersPlain(GetUsersPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getUsers:getUsers", TypeShape.of(GetUsersResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **Beta Notice** VLANs are currently available through early access.
     * To use early access resources, the `api_version` provider argument must be set to `v4beta`.
     * To learn more, see the early access documentation.
     * 
     * Provides details about Linode VLANs.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vlans).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.Instance;
     * import com.pulumi.linode.InstanceArgs;
     * import com.pulumi.linode.inputs.InstanceInterfaceArgs;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVlansArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var myInstance = new Instance("myInstance", InstanceArgs.builder()
     *             .label("my_instance")
     *             .image("linode/ubuntu22.04")
     *             .region("us-southeast")
     *             .type("g6-standard-1")
     *             .rootPass("bogusPassword$")
     *             .interfaces(InstanceInterfaceArgs.builder()
     *                 .purpose("vlan")
     *                 .label("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         final var my-vlans = LinodeFunctions.getVlans(GetVlansArgs.builder()
     *             .filters(GetVlansFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vlanLinodes", my_vlans.vlans()[0].linodes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `region`
     * 
     */
    public static Output<GetVlansResult> getVlans() {
        return getVlans(GetVlansArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * &gt; **Beta Notice** VLANs are currently available through early access.
     * To use early access resources, the `api_version` provider argument must be set to `v4beta`.
     * To learn more, see the early access documentation.
     * 
     * Provides details about Linode VLANs.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vlans).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.Instance;
     * import com.pulumi.linode.InstanceArgs;
     * import com.pulumi.linode.inputs.InstanceInterfaceArgs;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVlansArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var myInstance = new Instance("myInstance", InstanceArgs.builder()
     *             .label("my_instance")
     *             .image("linode/ubuntu22.04")
     *             .region("us-southeast")
     *             .type("g6-standard-1")
     *             .rootPass("bogusPassword$")
     *             .interfaces(InstanceInterfaceArgs.builder()
     *                 .purpose("vlan")
     *                 .label("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         final var my-vlans = LinodeFunctions.getVlans(GetVlansArgs.builder()
     *             .filters(GetVlansFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vlanLinodes", my_vlans.vlans()[0].linodes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `region`
     * 
     */
    public static CompletableFuture<GetVlansResult> getVlansPlain() {
        return getVlansPlain(GetVlansPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * &gt; **Beta Notice** VLANs are currently available through early access.
     * To use early access resources, the `api_version` provider argument must be set to `v4beta`.
     * To learn more, see the early access documentation.
     * 
     * Provides details about Linode VLANs.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vlans).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.Instance;
     * import com.pulumi.linode.InstanceArgs;
     * import com.pulumi.linode.inputs.InstanceInterfaceArgs;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVlansArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var myInstance = new Instance("myInstance", InstanceArgs.builder()
     *             .label("my_instance")
     *             .image("linode/ubuntu22.04")
     *             .region("us-southeast")
     *             .type("g6-standard-1")
     *             .rootPass("bogusPassword$")
     *             .interfaces(InstanceInterfaceArgs.builder()
     *                 .purpose("vlan")
     *                 .label("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         final var my-vlans = LinodeFunctions.getVlans(GetVlansArgs.builder()
     *             .filters(GetVlansFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vlanLinodes", my_vlans.vlans()[0].linodes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `region`
     * 
     */
    public static Output<GetVlansResult> getVlans(GetVlansArgs args) {
        return getVlans(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **Beta Notice** VLANs are currently available through early access.
     * To use early access resources, the `api_version` provider argument must be set to `v4beta`.
     * To learn more, see the early access documentation.
     * 
     * Provides details about Linode VLANs.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vlans).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.Instance;
     * import com.pulumi.linode.InstanceArgs;
     * import com.pulumi.linode.inputs.InstanceInterfaceArgs;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVlansArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var myInstance = new Instance("myInstance", InstanceArgs.builder()
     *             .label("my_instance")
     *             .image("linode/ubuntu22.04")
     *             .region("us-southeast")
     *             .type("g6-standard-1")
     *             .rootPass("bogusPassword$")
     *             .interfaces(InstanceInterfaceArgs.builder()
     *                 .purpose("vlan")
     *                 .label("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         final var my-vlans = LinodeFunctions.getVlans(GetVlansArgs.builder()
     *             .filters(GetVlansFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vlanLinodes", my_vlans.vlans()[0].linodes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `region`
     * 
     */
    public static CompletableFuture<GetVlansResult> getVlansPlain(GetVlansPlainArgs args) {
        return getVlansPlain(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **Beta Notice** VLANs are currently available through early access.
     * To use early access resources, the `api_version` provider argument must be set to `v4beta`.
     * To learn more, see the early access documentation.
     * 
     * Provides details about Linode VLANs.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vlans).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.Instance;
     * import com.pulumi.linode.InstanceArgs;
     * import com.pulumi.linode.inputs.InstanceInterfaceArgs;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVlansArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var myInstance = new Instance("myInstance", InstanceArgs.builder()
     *             .label("my_instance")
     *             .image("linode/ubuntu22.04")
     *             .region("us-southeast")
     *             .type("g6-standard-1")
     *             .rootPass("bogusPassword$")
     *             .interfaces(InstanceInterfaceArgs.builder()
     *                 .purpose("vlan")
     *                 .label("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         final var my-vlans = LinodeFunctions.getVlans(GetVlansArgs.builder()
     *             .filters(GetVlansFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vlanLinodes", my_vlans.vlans()[0].linodes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `region`
     * 
     */
    public static Output<GetVlansResult> getVlans(GetVlansArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVlans:getVlans", TypeShape.of(GetVlansResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **Beta Notice** VLANs are currently available through early access.
     * To use early access resources, the `api_version` provider argument must be set to `v4beta`.
     * To learn more, see the early access documentation.
     * 
     * Provides details about Linode VLANs.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vlans).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.Instance;
     * import com.pulumi.linode.InstanceArgs;
     * import com.pulumi.linode.inputs.InstanceInterfaceArgs;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVlansArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var myInstance = new Instance("myInstance", InstanceArgs.builder()
     *             .label("my_instance")
     *             .image("linode/ubuntu22.04")
     *             .region("us-southeast")
     *             .type("g6-standard-1")
     *             .rootPass("bogusPassword$")
     *             .interfaces(InstanceInterfaceArgs.builder()
     *                 .purpose("vlan")
     *                 .label("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         final var my-vlans = LinodeFunctions.getVlans(GetVlansArgs.builder()
     *             .filters(GetVlansFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vlanLinodes", my_vlans.vlans()[0].linodes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `region`
     * 
     */
    public static Output<GetVlansResult> getVlans(GetVlansArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVlans:getVlans", TypeShape.of(GetVlansResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **Beta Notice** VLANs are currently available through early access.
     * To use early access resources, the `api_version` provider argument must be set to `v4beta`.
     * To learn more, see the early access documentation.
     * 
     * Provides details about Linode VLANs.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vlans).
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.Instance;
     * import com.pulumi.linode.InstanceArgs;
     * import com.pulumi.linode.inputs.InstanceInterfaceArgs;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVlansArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var myInstance = new Instance("myInstance", InstanceArgs.builder()
     *             .label("my_instance")
     *             .image("linode/ubuntu22.04")
     *             .region("us-southeast")
     *             .type("g6-standard-1")
     *             .rootPass("bogusPassword$")
     *             .interfaces(InstanceInterfaceArgs.builder()
     *                 .purpose("vlan")
     *                 .label("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         final var my-vlans = LinodeFunctions.getVlans(GetVlansArgs.builder()
     *             .filters(GetVlansFilterArgs.builder()
     *                 .name("label")
     *                 .values("my-vlan")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vlanLinodes", my_vlans.vlans()[0].linodes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `region`
     * 
     */
    public static CompletableFuture<GetVlansResult> getVlansPlain(GetVlansPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getVlans:getVlans", TypeShape.of(GetVlansResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Volume.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Volume.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVolume(GetVolumeArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVolumeResult> getVolume(GetVolumeArgs args) {
        return getVolume(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Volume.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Volume.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVolume(GetVolumeArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetVolumeResult> getVolumePlain(GetVolumePlainArgs args) {
        return getVolumePlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode Volume.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Volume.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVolume(GetVolumeArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVolumeResult> getVolume(GetVolumeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVolume:getVolume", TypeShape.of(GetVolumeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Volume.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Volume.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVolume(GetVolumeArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVolumeResult> getVolume(GetVolumeArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVolume:getVolume", TypeShape.of(GetVolumeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode Volume.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode Volume.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVolume(GetVolumeArgs.builder()
     *             .id(1234567)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetVolumeResult> getVolumePlain(GetVolumePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getVolume:getVolume", TypeShape.of(GetVolumeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Volume types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume-types).
     * 
     */
    public static Output<GetVolumeTypesResult> getVolumeTypes() {
        return getVolumeTypes(GetVolumeTypesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Volume types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume-types).
     * 
     */
    public static CompletableFuture<GetVolumeTypesResult> getVolumeTypesPlain() {
        return getVolumeTypesPlain(GetVolumeTypesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Volume types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume-types).
     * 
     */
    public static Output<GetVolumeTypesResult> getVolumeTypes(GetVolumeTypesArgs args) {
        return getVolumeTypes(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Volume types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume-types).
     * 
     */
    public static CompletableFuture<GetVolumeTypesResult> getVolumeTypesPlain(GetVolumeTypesPlainArgs args) {
        return getVolumeTypesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode Volume types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume-types).
     * 
     */
    public static Output<GetVolumeTypesResult> getVolumeTypes(GetVolumeTypesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVolumeTypes:getVolumeTypes", TypeShape.of(GetVolumeTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Volume types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume-types).
     * 
     */
    public static Output<GetVolumeTypesResult> getVolumeTypes(GetVolumeTypesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVolumeTypes:getVolumeTypes", TypeShape.of(GetVolumeTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode Volume types that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volume-types).
     * 
     */
    public static CompletableFuture<GetVolumeTypesResult> getVolumeTypesPlain(GetVolumeTypesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getVolumeTypes:getVolumeTypes", TypeShape.of(GetVolumeTypesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode volumes that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volumes).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-volumes = LinodeFunctions.getVolumes(GetVolumesArgs.builder()
     *             .filters(GetVolumesFilterArgs.builder()
     *                 .name("label")
     *                 .values("test-volume")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("volumes", filtered_volumes.volumes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     */
    public static Output<GetVolumesResult> getVolumes() {
        return getVolumes(GetVolumesArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode volumes that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volumes).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-volumes = LinodeFunctions.getVolumes(GetVolumesArgs.builder()
     *             .filters(GetVolumesFilterArgs.builder()
     *                 .name("label")
     *                 .values("test-volume")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("volumes", filtered_volumes.volumes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     */
    public static CompletableFuture<GetVolumesResult> getVolumesPlain() {
        return getVolumesPlain(GetVolumesPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode volumes that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volumes).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-volumes = LinodeFunctions.getVolumes(GetVolumesArgs.builder()
     *             .filters(GetVolumesFilterArgs.builder()
     *                 .name("label")
     *                 .values("test-volume")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("volumes", filtered_volumes.volumes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     */
    public static Output<GetVolumesResult> getVolumes(GetVolumesArgs args) {
        return getVolumes(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode volumes that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volumes).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-volumes = LinodeFunctions.getVolumes(GetVolumesArgs.builder()
     *             .filters(GetVolumesFilterArgs.builder()
     *                 .name("label")
     *                 .values("test-volume")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("volumes", filtered_volumes.volumes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     */
    public static CompletableFuture<GetVolumesResult> getVolumesPlain(GetVolumesPlainArgs args) {
        return getVolumesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about Linode volumes that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volumes).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-volumes = LinodeFunctions.getVolumes(GetVolumesArgs.builder()
     *             .filters(GetVolumesFilterArgs.builder()
     *                 .name("label")
     *                 .values("test-volume")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("volumes", filtered_volumes.volumes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     */
    public static Output<GetVolumesResult> getVolumes(GetVolumesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVolumes:getVolumes", TypeShape.of(GetVolumesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode volumes that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volumes).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-volumes = LinodeFunctions.getVolumes(GetVolumesArgs.builder()
     *             .filters(GetVolumesFilterArgs.builder()
     *                 .name("label")
     *                 .values("test-volume")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("volumes", filtered_volumes.volumes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     */
    public static Output<GetVolumesResult> getVolumes(GetVolumesArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVolumes:getVolumes", TypeShape.of(GetVolumesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about Linode volumes that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-volumes).
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVolumesArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-volumes = LinodeFunctions.getVolumes(GetVolumesArgs.builder()
     *             .filters(GetVolumesFilterArgs.builder()
     *                 .name("label")
     *                 .values("test-volume")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("volumes", filtered_volumes.volumes());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `label`
     * 
     * * `tags`
     * 
     */
    public static CompletableFuture<GetVolumesResult> getVolumesPlain(GetVolumesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getVolumes:getVolumes", TypeShape.of(GetVolumesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode VPC.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode VPC.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVpc(GetVpcArgs.builder()
     *             .id("123")
     *             .build());
     * 
     *         ctx.export("vpc", foo);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVpcResult> getVpc(GetVpcArgs args) {
        return getVpc(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode VPC.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode VPC.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVpc(GetVpcArgs.builder()
     *             .id("123")
     *             .build());
     * 
     *         ctx.export("vpc", foo);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetVpcResult> getVpcPlain(GetVpcPlainArgs args) {
        return getVpcPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode VPC.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode VPC.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVpc(GetVpcArgs.builder()
     *             .id("123")
     *             .build());
     * 
     *         ctx.export("vpc", foo);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVpcResult> getVpc(GetVpcArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVpc:getVpc", TypeShape.of(GetVpcResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode VPC.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode VPC.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVpc(GetVpcArgs.builder()
     *             .id("123")
     *             .build());
     * 
     *         ctx.export("vpc", foo);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVpcResult> getVpc(GetVpcArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVpc:getVpc", TypeShape.of(GetVpcResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode VPC.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode VPC.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVpc(GetVpcArgs.builder()
     *             .id("123")
     *             .build());
     * 
     *         ctx.export("vpc", foo);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetVpcResult> getVpcPlain(GetVpcPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getVpc:getVpc", TypeShape.of(GetVpcResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode VPC IPs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs-ips).
     * 
     * Provides information about a list of Linode VPC IPs in a specific VPC that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-ips).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC IPs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .filters(GetVpcIpsFilterArgs.builder()
     *                 .name("address")
     *                 .values("10.0.0.0")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcIps", filtered_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * One might also use this data source to list all VPC IPs in a specific VPC. The following example shows how to do this.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-vpc-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .vpcId(123)
     *             .build());
     * 
     *         ctx.export("vpcIps", specific_vpc_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `active`
     * 
     * * `config_id`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `vpc_id`
     * 
     */
    public static Output<GetVpcIpsResult> getVpcIps() {
        return getVpcIps(GetVpcIpsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode VPC IPs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs-ips).
     * 
     * Provides information about a list of Linode VPC IPs in a specific VPC that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-ips).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC IPs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .filters(GetVpcIpsFilterArgs.builder()
     *                 .name("address")
     *                 .values("10.0.0.0")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcIps", filtered_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * One might also use this data source to list all VPC IPs in a specific VPC. The following example shows how to do this.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-vpc-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .vpcId(123)
     *             .build());
     * 
     *         ctx.export("vpcIps", specific_vpc_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `active`
     * 
     * * `config_id`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `vpc_id`
     * 
     */
    public static CompletableFuture<GetVpcIpsResult> getVpcIpsPlain() {
        return getVpcIpsPlain(GetVpcIpsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode VPC IPs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs-ips).
     * 
     * Provides information about a list of Linode VPC IPs in a specific VPC that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-ips).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC IPs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .filters(GetVpcIpsFilterArgs.builder()
     *                 .name("address")
     *                 .values("10.0.0.0")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcIps", filtered_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * One might also use this data source to list all VPC IPs in a specific VPC. The following example shows how to do this.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-vpc-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .vpcId(123)
     *             .build());
     * 
     *         ctx.export("vpcIps", specific_vpc_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `active`
     * 
     * * `config_id`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `vpc_id`
     * 
     */
    public static Output<GetVpcIpsResult> getVpcIps(GetVpcIpsArgs args) {
        return getVpcIps(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode VPC IPs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs-ips).
     * 
     * Provides information about a list of Linode VPC IPs in a specific VPC that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-ips).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC IPs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .filters(GetVpcIpsFilterArgs.builder()
     *                 .name("address")
     *                 .values("10.0.0.0")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcIps", filtered_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * One might also use this data source to list all VPC IPs in a specific VPC. The following example shows how to do this.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-vpc-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .vpcId(123)
     *             .build());
     * 
     *         ctx.export("vpcIps", specific_vpc_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `active`
     * 
     * * `config_id`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `vpc_id`
     * 
     */
    public static CompletableFuture<GetVpcIpsResult> getVpcIpsPlain(GetVpcIpsPlainArgs args) {
        return getVpcIpsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode VPC IPs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs-ips).
     * 
     * Provides information about a list of Linode VPC IPs in a specific VPC that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-ips).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC IPs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .filters(GetVpcIpsFilterArgs.builder()
     *                 .name("address")
     *                 .values("10.0.0.0")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcIps", filtered_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * One might also use this data source to list all VPC IPs in a specific VPC. The following example shows how to do this.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-vpc-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .vpcId(123)
     *             .build());
     * 
     *         ctx.export("vpcIps", specific_vpc_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `active`
     * 
     * * `config_id`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `vpc_id`
     * 
     */
    public static Output<GetVpcIpsResult> getVpcIps(GetVpcIpsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVpcIps:getVpcIps", TypeShape.of(GetVpcIpsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode VPC IPs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs-ips).
     * 
     * Provides information about a list of Linode VPC IPs in a specific VPC that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-ips).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC IPs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .filters(GetVpcIpsFilterArgs.builder()
     *                 .name("address")
     *                 .values("10.0.0.0")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcIps", filtered_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * One might also use this data source to list all VPC IPs in a specific VPC. The following example shows how to do this.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-vpc-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .vpcId(123)
     *             .build());
     * 
     *         ctx.export("vpcIps", specific_vpc_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `active`
     * 
     * * `config_id`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `vpc_id`
     * 
     */
    public static Output<GetVpcIpsResult> getVpcIps(GetVpcIpsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVpcIps:getVpcIps", TypeShape.of(GetVpcIpsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode VPC IPs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs-ips).
     * 
     * Provides information about a list of Linode VPC IPs in a specific VPC that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-ips).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC IPs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .filters(GetVpcIpsFilterArgs.builder()
     *                 .name("address")
     *                 .values("10.0.0.0")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcIps", filtered_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * One might also use this data source to list all VPC IPs in a specific VPC. The following example shows how to do this.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcIpsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var specific-vpc-ips = LinodeFunctions.getVpcIps(GetVpcIpsArgs.builder()
     *             .vpcId(123)
     *             .build());
     * 
     *         ctx.export("vpcIps", specific_vpc_ips.vpcIps());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `active`
     * 
     * * `config_id`
     * 
     * * `linode_id`
     * 
     * * `region`
     * 
     * * `vpc_id`
     * 
     */
    public static CompletableFuture<GetVpcIpsResult> getVpcIpsPlain(GetVpcIpsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getVpcIps:getVpcIps", TypeShape.of(GetVpcIpsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode VPC subnet.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-subnet).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode VPC subnet.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcSubnetArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVpcSubnet(GetVpcSubnetArgs.builder()
     *             .vpcId(123)
     *             .id("12345")
     *             .build());
     * 
     *         ctx.export("vpcSubnet", foo);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVpcSubnetResult> getVpcSubnet(GetVpcSubnetArgs args) {
        return getVpcSubnet(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode VPC subnet.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-subnet).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode VPC subnet.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcSubnetArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVpcSubnet(GetVpcSubnetArgs.builder()
     *             .vpcId(123)
     *             .id("12345")
     *             .build());
     * 
     *         ctx.export("vpcSubnet", foo);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetVpcSubnetResult> getVpcSubnetPlain(GetVpcSubnetPlainArgs args) {
        return getVpcSubnetPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a Linode VPC subnet.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-subnet).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode VPC subnet.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcSubnetArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVpcSubnet(GetVpcSubnetArgs.builder()
     *             .vpcId(123)
     *             .id("12345")
     *             .build());
     * 
     *         ctx.export("vpcSubnet", foo);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVpcSubnetResult> getVpcSubnet(GetVpcSubnetArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVpcSubnet:getVpcSubnet", TypeShape.of(GetVpcSubnetResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode VPC subnet.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-subnet).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode VPC subnet.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcSubnetArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVpcSubnet(GetVpcSubnetArgs.builder()
     *             .vpcId(123)
     *             .id("12345")
     *             .build());
     * 
     *         ctx.export("vpcSubnet", foo);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVpcSubnetResult> getVpcSubnet(GetVpcSubnetArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVpcSubnet:getVpcSubnet", TypeShape.of(GetVpcSubnetResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a Linode VPC subnet.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-subnet).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to access information about a Linode VPC subnet.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcSubnetArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = LinodeFunctions.getVpcSubnet(GetVpcSubnetArgs.builder()
     *             .vpcId(123)
     *             .id("12345")
     *             .build());
     * 
     *         ctx.export("vpcSubnet", foo);
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetVpcSubnetResult> getVpcSubnetPlain(GetVpcSubnetPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getVpcSubnet:getVpcSubnet", TypeShape.of(GetVpcSubnetResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode VPC subnets that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-subnets).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC subnets.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcSubnetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-subnets = LinodeFunctions.getVpcSubnets(GetVpcSubnetsArgs.builder()
     *             .vpcId(123)
     *             .filters(GetVpcSubnetsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcSubnets", filtered_subnets.vpcSubnets());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ipv4`
     * 
     */
    public static Output<GetVpcSubnetsResult> getVpcSubnets(GetVpcSubnetsArgs args) {
        return getVpcSubnets(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode VPC subnets that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-subnets).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC subnets.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcSubnetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-subnets = LinodeFunctions.getVpcSubnets(GetVpcSubnetsArgs.builder()
     *             .vpcId(123)
     *             .filters(GetVpcSubnetsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcSubnets", filtered_subnets.vpcSubnets());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ipv4`
     * 
     */
    public static CompletableFuture<GetVpcSubnetsResult> getVpcSubnetsPlain(GetVpcSubnetsPlainArgs args) {
        return getVpcSubnetsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode VPC subnets that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-subnets).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC subnets.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcSubnetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-subnets = LinodeFunctions.getVpcSubnets(GetVpcSubnetsArgs.builder()
     *             .vpcId(123)
     *             .filters(GetVpcSubnetsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcSubnets", filtered_subnets.vpcSubnets());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ipv4`
     * 
     */
    public static Output<GetVpcSubnetsResult> getVpcSubnets(GetVpcSubnetsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVpcSubnets:getVpcSubnets", TypeShape.of(GetVpcSubnetsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode VPC subnets that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-subnets).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC subnets.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcSubnetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-subnets = LinodeFunctions.getVpcSubnets(GetVpcSubnetsArgs.builder()
     *             .vpcId(123)
     *             .filters(GetVpcSubnetsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcSubnets", filtered_subnets.vpcSubnets());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ipv4`
     * 
     */
    public static Output<GetVpcSubnetsResult> getVpcSubnets(GetVpcSubnetsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVpcSubnets:getVpcSubnets", TypeShape.of(GetVpcSubnetsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode VPC subnets that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpc-subnets).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPC subnets.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcSubnetsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-subnets = LinodeFunctions.getVpcSubnets(GetVpcSubnetsArgs.builder()
     *             .vpcId(123)
     *             .filters(GetVpcSubnetsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcSubnets", filtered_subnets.vpcSubnets());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `ipv4`
     * 
     */
    public static CompletableFuture<GetVpcSubnetsResult> getVpcSubnetsPlain(GetVpcSubnetsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getVpcSubnets:getVpcSubnets", TypeShape.of(GetVpcSubnetsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode VPCs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPCs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-vpcs = LinodeFunctions.getVpcs(GetVpcsArgs.builder()
     *             .filters(GetVpcsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcs", filtered_vpcs.vpcs());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `description`
     * 
     * * `region`
     * 
     */
    public static Output<GetVpcsResult> getVpcs() {
        return getVpcs(GetVpcsArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode VPCs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPCs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-vpcs = LinodeFunctions.getVpcs(GetVpcsArgs.builder()
     *             .filters(GetVpcsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcs", filtered_vpcs.vpcs());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `description`
     * 
     * * `region`
     * 
     */
    public static CompletableFuture<GetVpcsResult> getVpcsPlain() {
        return getVpcsPlain(GetVpcsPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode VPCs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPCs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-vpcs = LinodeFunctions.getVpcs(GetVpcsArgs.builder()
     *             .filters(GetVpcsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcs", filtered_vpcs.vpcs());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `description`
     * 
     * * `region`
     * 
     */
    public static Output<GetVpcsResult> getVpcs(GetVpcsArgs args) {
        return getVpcs(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode VPCs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPCs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-vpcs = LinodeFunctions.getVpcs(GetVpcsArgs.builder()
     *             .filters(GetVpcsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcs", filtered_vpcs.vpcs());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `description`
     * 
     * * `region`
     * 
     */
    public static CompletableFuture<GetVpcsResult> getVpcsPlain(GetVpcsPlainArgs args) {
        return getVpcsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Provides information about a list of Linode VPCs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPCs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-vpcs = LinodeFunctions.getVpcs(GetVpcsArgs.builder()
     *             .filters(GetVpcsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcs", filtered_vpcs.vpcs());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `description`
     * 
     * * `region`
     * 
     */
    public static Output<GetVpcsResult> getVpcs(GetVpcsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVpcs:getVpcs", TypeShape.of(GetVpcsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode VPCs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPCs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-vpcs = LinodeFunctions.getVpcs(GetVpcsArgs.builder()
     *             .filters(GetVpcsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcs", filtered_vpcs.vpcs());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `description`
     * 
     * * `region`
     * 
     */
    public static Output<GetVpcsResult> getVpcs(GetVpcsArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("linode:index/getVpcs:getVpcs", TypeShape.of(GetVpcsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Provides information about a list of Linode VPCs that match a set of filters.
     * For more information, see the [Linode APIv4 docs](https://techdocs.akamai.com/linode-api/reference/get-vpcs).
     * 
     * ## Example Usage
     * 
     * The following example shows how one might use this data source to list VPCs.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.linode.LinodeFunctions;
     * import com.pulumi.linode.inputs.GetVpcsArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var filtered-vpcs = LinodeFunctions.getVpcs(GetVpcsArgs.builder()
     *             .filters(GetVpcsFilterArgs.builder()
     *                 .name("label")
     *                 .values("test")
     *                 .build())
     *             .build());
     * 
     *         ctx.export("vpcs", filtered_vpcs.vpcs());
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ## Filterable Fields
     * 
     * * `id`
     * 
     * * `label`
     * 
     * * `description`
     * 
     * * `region`
     * 
     */
    public static CompletableFuture<GetVpcsResult> getVpcsPlain(GetVpcsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("linode:index/getVpcs:getVpcs", TypeShape.of(GetVpcsResult.class), args, Utilities.withVersion(options));
    }
}
