// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.linode.inputs;

import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.linode.inputs.GetNodebalancerConfigsNodebalancerConfigNodeStatus;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;


public final class GetNodebalancerConfigsNodebalancerConfig extends com.pulumi.resources.InvokeArgs {

    public static final GetNodebalancerConfigsNodebalancerConfig Empty = new GetNodebalancerConfigsNodebalancerConfig();

    /**
     * What algorithm this NodeBalancer should use for routing traffic to backends (`roundrobin`, `leastconn`, `source`)
     * 
     */
    @Import(name="algorithm", required=true)
    private String algorithm;

    /**
     * @return What algorithm this NodeBalancer should use for routing traffic to backends (`roundrobin`, `leastconn`, `source`)
     * 
     */
    public String algorithm() {
        return this.algorithm;
    }

    /**
     * The type of check to perform against backends to ensure they are serving requests. This is used to determine if backends are up or down. If none no check is performed. connection requires only a connection to the backend to succeed. http and http_body rely on the backend serving HTTP, and that the response returned matches what is expected. (`none`, `connection`, `http`, `http_body`)
     * 
     */
    @Import(name="check", required=true)
    private String check;

    /**
     * @return The type of check to perform against backends to ensure they are serving requests. This is used to determine if backends are up or down. If none no check is performed. connection requires only a connection to the backend to succeed. http and http_body rely on the backend serving HTTP, and that the response returned matches what is expected. (`none`, `connection`, `http`, `http_body`)
     * 
     */
    public String check() {
        return this.check;
    }

    /**
     * How many times to attempt a check before considering a backend to be down. (1-30)
     * 
     */
    @Import(name="checkAttempts", required=true)
    private Integer checkAttempts;

    /**
     * @return How many times to attempt a check before considering a backend to be down. (1-30)
     * 
     */
    public Integer checkAttempts() {
        return this.checkAttempts;
    }

    /**
     * This value must be present in the response body of the check in order for it to pass. If this value is not present in the response body of a check request, the backend is considered to be down
     * 
     */
    @Import(name="checkBody", required=true)
    private String checkBody;

    /**
     * @return This value must be present in the response body of the check in order for it to pass. If this value is not present in the response body of a check request, the backend is considered to be down
     * 
     */
    public String checkBody() {
        return this.checkBody;
    }

    /**
     * How often, in seconds, to check that backends are up and serving requests.
     * 
     */
    @Import(name="checkInterval", required=true)
    private Integer checkInterval;

    /**
     * @return How often, in seconds, to check that backends are up and serving requests.
     * 
     */
    public Integer checkInterval() {
        return this.checkInterval;
    }

    /**
     * If true, any response from this backend with a 5xx status code will be enough for it to be considered unhealthy and taken out of rotation.
     * 
     */
    @Import(name="checkPassive", required=true)
    private Boolean checkPassive;

    /**
     * @return If true, any response from this backend with a 5xx status code will be enough for it to be considered unhealthy and taken out of rotation.
     * 
     */
    public Boolean checkPassive() {
        return this.checkPassive;
    }

    /**
     * The URL path to check on each backend. If the backend does not respond to this request it is considered to be down.
     * 
     */
    @Import(name="checkPath", required=true)
    private String checkPath;

    /**
     * @return The URL path to check on each backend. If the backend does not respond to this request it is considered to be down.
     * 
     */
    public String checkPath() {
        return this.checkPath;
    }

    /**
     * How long, in seconds, to wait for a check attempt before considering it failed. (1-30)
     * 
     */
    @Import(name="checkTimeout", required=true)
    private Integer checkTimeout;

    /**
     * @return How long, in seconds, to wait for a check attempt before considering it failed. (1-30)
     * 
     */
    public Integer checkTimeout() {
        return this.checkTimeout;
    }

    /**
     * What ciphers to use for SSL connections served by this NodeBalancer. `legacy` is considered insecure and should only be used if necessary. (`recommended`, `legacy`)
     * 
     */
    @Import(name="cipherSuite", required=true)
    private String cipherSuite;

    /**
     * @return What ciphers to use for SSL connections served by this NodeBalancer. `legacy` is considered insecure and should only be used if necessary. (`recommended`, `legacy`)
     * 
     */
    public String cipherSuite() {
        return this.cipherSuite;
    }

    /**
     * The config&#39;s ID.
     * 
     */
    @Import(name="id", required=true)
    private Integer id;

    /**
     * @return The config&#39;s ID.
     * 
     */
    public Integer id() {
        return this.id;
    }

    /**
     * A structure containing information about the health of the backends for this port. This information is updated periodically as checks are performed against backends.
     * 
     */
    @Import(name="nodeStatuses", required=true)
    private List<GetNodebalancerConfigsNodebalancerConfigNodeStatus> nodeStatuses;

    /**
     * @return A structure containing information about the health of the backends for this port. This information is updated periodically as checks are performed against backends.
     * 
     */
    public List<GetNodebalancerConfigsNodebalancerConfigNodeStatus> nodeStatuses() {
        return this.nodeStatuses;
    }

    /**
     * The ID of the NodeBalancer to access.
     * 
     * * `filter` - (Optional) A set of filters used to select Linode NodeBalancers that meet certain requirements.
     * 
     */
    @Import(name="nodebalancerId", required=true)
    private Integer nodebalancerId;

    /**
     * @return The ID of the NodeBalancer to access.
     * 
     * * `filter` - (Optional) A set of filters used to select Linode NodeBalancers that meet certain requirements.
     * 
     */
    public Integer nodebalancerId() {
        return this.nodebalancerId;
    }

    /**
     * The TCP port this Config is for.
     * 
     */
    @Import(name="port", required=true)
    private Integer port;

    /**
     * @return The TCP port this Config is for.
     * 
     */
    public Integer port() {
        return this.port;
    }

    /**
     * The protocol this port is configured to serve. If this is set to https you must include an ssl_cert and an ssl_key. (`http`, `https`, `tcp`) (Defaults to `http`)
     * 
     */
    @Import(name="protocol", required=true)
    private String protocol;

    /**
     * @return The protocol this port is configured to serve. If this is set to https you must include an ssl_cert and an ssl_key. (`http`, `https`, `tcp`) (Defaults to `http`)
     * 
     */
    public String protocol() {
        return this.protocol;
    }

    /**
     * The version of ProxyProtocol to use for the underlying NodeBalancer. This requires protocol to be `tcp`. (`none`, `v1`, and `v2`) (Defaults to `none`)
     * 
     */
    @Import(name="proxyProtocol", required=true)
    private String proxyProtocol;

    /**
     * @return The version of ProxyProtocol to use for the underlying NodeBalancer. This requires protocol to be `tcp`. (`none`, `v1`, and `v2`) (Defaults to `none`)
     * 
     */
    public String proxyProtocol() {
        return this.proxyProtocol;
    }

    /**
     * The read-only common name automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
     * 
     */
    @Import(name="sslCommonname", required=true)
    private String sslCommonname;

    /**
     * @return The read-only common name automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
     * 
     */
    public String sslCommonname() {
        return this.sslCommonname;
    }

    /**
     * The read-only fingerprint automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
     * 
     */
    @Import(name="sslFingerprint", required=true)
    private String sslFingerprint;

    /**
     * @return The read-only fingerprint automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
     * 
     */
    public String sslFingerprint() {
        return this.sslFingerprint;
    }

    /**
     * Controls how session stickiness is handled on this port. (`none`, `table`, `http_cookie`)
     * 
     */
    @Import(name="stickiness", required=true)
    private String stickiness;

    /**
     * @return Controls how session stickiness is handled on this port. (`none`, `table`, `http_cookie`)
     * 
     */
    public String stickiness() {
        return this.stickiness;
    }

    /**
     * Specifies the port on the backend node used for active health checks, which may differ from the port serving traffic.
     * 
     */
    @Import(name="udpCheckPort", required=true)
    private Integer udpCheckPort;

    /**
     * @return Specifies the port on the backend node used for active health checks, which may differ from the port serving traffic.
     * 
     */
    public Integer udpCheckPort() {
        return this.udpCheckPort;
    }

    /**
     * The idle time in seconds after which a session that hasn’t received packets is destroyed.
     * 
     */
    @Import(name="udpSessionTimeout", required=true)
    private Integer udpSessionTimeout;

    /**
     * @return The idle time in seconds after which a session that hasn’t received packets is destroyed.
     * 
     */
    public Integer udpSessionTimeout() {
        return this.udpSessionTimeout;
    }

    private GetNodebalancerConfigsNodebalancerConfig() {}

    private GetNodebalancerConfigsNodebalancerConfig(GetNodebalancerConfigsNodebalancerConfig $) {
        this.algorithm = $.algorithm;
        this.check = $.check;
        this.checkAttempts = $.checkAttempts;
        this.checkBody = $.checkBody;
        this.checkInterval = $.checkInterval;
        this.checkPassive = $.checkPassive;
        this.checkPath = $.checkPath;
        this.checkTimeout = $.checkTimeout;
        this.cipherSuite = $.cipherSuite;
        this.id = $.id;
        this.nodeStatuses = $.nodeStatuses;
        this.nodebalancerId = $.nodebalancerId;
        this.port = $.port;
        this.protocol = $.protocol;
        this.proxyProtocol = $.proxyProtocol;
        this.sslCommonname = $.sslCommonname;
        this.sslFingerprint = $.sslFingerprint;
        this.stickiness = $.stickiness;
        this.udpCheckPort = $.udpCheckPort;
        this.udpSessionTimeout = $.udpSessionTimeout;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetNodebalancerConfigsNodebalancerConfig defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetNodebalancerConfigsNodebalancerConfig $;

        public Builder() {
            $ = new GetNodebalancerConfigsNodebalancerConfig();
        }

        public Builder(GetNodebalancerConfigsNodebalancerConfig defaults) {
            $ = new GetNodebalancerConfigsNodebalancerConfig(Objects.requireNonNull(defaults));
        }

        /**
         * @param algorithm What algorithm this NodeBalancer should use for routing traffic to backends (`roundrobin`, `leastconn`, `source`)
         * 
         * @return builder
         * 
         */
        public Builder algorithm(String algorithm) {
            $.algorithm = algorithm;
            return this;
        }

        /**
         * @param check The type of check to perform against backends to ensure they are serving requests. This is used to determine if backends are up or down. If none no check is performed. connection requires only a connection to the backend to succeed. http and http_body rely on the backend serving HTTP, and that the response returned matches what is expected. (`none`, `connection`, `http`, `http_body`)
         * 
         * @return builder
         * 
         */
        public Builder check(String check) {
            $.check = check;
            return this;
        }

        /**
         * @param checkAttempts How many times to attempt a check before considering a backend to be down. (1-30)
         * 
         * @return builder
         * 
         */
        public Builder checkAttempts(Integer checkAttempts) {
            $.checkAttempts = checkAttempts;
            return this;
        }

        /**
         * @param checkBody This value must be present in the response body of the check in order for it to pass. If this value is not present in the response body of a check request, the backend is considered to be down
         * 
         * @return builder
         * 
         */
        public Builder checkBody(String checkBody) {
            $.checkBody = checkBody;
            return this;
        }

        /**
         * @param checkInterval How often, in seconds, to check that backends are up and serving requests.
         * 
         * @return builder
         * 
         */
        public Builder checkInterval(Integer checkInterval) {
            $.checkInterval = checkInterval;
            return this;
        }

        /**
         * @param checkPassive If true, any response from this backend with a 5xx status code will be enough for it to be considered unhealthy and taken out of rotation.
         * 
         * @return builder
         * 
         */
        public Builder checkPassive(Boolean checkPassive) {
            $.checkPassive = checkPassive;
            return this;
        }

        /**
         * @param checkPath The URL path to check on each backend. If the backend does not respond to this request it is considered to be down.
         * 
         * @return builder
         * 
         */
        public Builder checkPath(String checkPath) {
            $.checkPath = checkPath;
            return this;
        }

        /**
         * @param checkTimeout How long, in seconds, to wait for a check attempt before considering it failed. (1-30)
         * 
         * @return builder
         * 
         */
        public Builder checkTimeout(Integer checkTimeout) {
            $.checkTimeout = checkTimeout;
            return this;
        }

        /**
         * @param cipherSuite What ciphers to use for SSL connections served by this NodeBalancer. `legacy` is considered insecure and should only be used if necessary. (`recommended`, `legacy`)
         * 
         * @return builder
         * 
         */
        public Builder cipherSuite(String cipherSuite) {
            $.cipherSuite = cipherSuite;
            return this;
        }

        /**
         * @param id The config&#39;s ID.
         * 
         * @return builder
         * 
         */
        public Builder id(Integer id) {
            $.id = id;
            return this;
        }

        /**
         * @param nodeStatuses A structure containing information about the health of the backends for this port. This information is updated periodically as checks are performed against backends.
         * 
         * @return builder
         * 
         */
        public Builder nodeStatuses(List<GetNodebalancerConfigsNodebalancerConfigNodeStatus> nodeStatuses) {
            $.nodeStatuses = nodeStatuses;
            return this;
        }

        /**
         * @param nodeStatuses A structure containing information about the health of the backends for this port. This information is updated periodically as checks are performed against backends.
         * 
         * @return builder
         * 
         */
        public Builder nodeStatuses(GetNodebalancerConfigsNodebalancerConfigNodeStatus... nodeStatuses) {
            return nodeStatuses(List.of(nodeStatuses));
        }

        /**
         * @param nodebalancerId The ID of the NodeBalancer to access.
         * 
         * * `filter` - (Optional) A set of filters used to select Linode NodeBalancers that meet certain requirements.
         * 
         * @return builder
         * 
         */
        public Builder nodebalancerId(Integer nodebalancerId) {
            $.nodebalancerId = nodebalancerId;
            return this;
        }

        /**
         * @param port The TCP port this Config is for.
         * 
         * @return builder
         * 
         */
        public Builder port(Integer port) {
            $.port = port;
            return this;
        }

        /**
         * @param protocol The protocol this port is configured to serve. If this is set to https you must include an ssl_cert and an ssl_key. (`http`, `https`, `tcp`) (Defaults to `http`)
         * 
         * @return builder
         * 
         */
        public Builder protocol(String protocol) {
            $.protocol = protocol;
            return this;
        }

        /**
         * @param proxyProtocol The version of ProxyProtocol to use for the underlying NodeBalancer. This requires protocol to be `tcp`. (`none`, `v1`, and `v2`) (Defaults to `none`)
         * 
         * @return builder
         * 
         */
        public Builder proxyProtocol(String proxyProtocol) {
            $.proxyProtocol = proxyProtocol;
            return this;
        }

        /**
         * @param sslCommonname The read-only common name automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
         * 
         * @return builder
         * 
         */
        public Builder sslCommonname(String sslCommonname) {
            $.sslCommonname = sslCommonname;
            return this;
        }

        /**
         * @param sslFingerprint The read-only fingerprint automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
         * 
         * @return builder
         * 
         */
        public Builder sslFingerprint(String sslFingerprint) {
            $.sslFingerprint = sslFingerprint;
            return this;
        }

        /**
         * @param stickiness Controls how session stickiness is handled on this port. (`none`, `table`, `http_cookie`)
         * 
         * @return builder
         * 
         */
        public Builder stickiness(String stickiness) {
            $.stickiness = stickiness;
            return this;
        }

        /**
         * @param udpCheckPort Specifies the port on the backend node used for active health checks, which may differ from the port serving traffic.
         * 
         * @return builder
         * 
         */
        public Builder udpCheckPort(Integer udpCheckPort) {
            $.udpCheckPort = udpCheckPort;
            return this;
        }

        /**
         * @param udpSessionTimeout The idle time in seconds after which a session that hasn’t received packets is destroyed.
         * 
         * @return builder
         * 
         */
        public Builder udpSessionTimeout(Integer udpSessionTimeout) {
            $.udpSessionTimeout = udpSessionTimeout;
            return this;
        }

        public GetNodebalancerConfigsNodebalancerConfig build() {
            if ($.algorithm == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "algorithm");
            }
            if ($.check == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "check");
            }
            if ($.checkAttempts == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "checkAttempts");
            }
            if ($.checkBody == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "checkBody");
            }
            if ($.checkInterval == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "checkInterval");
            }
            if ($.checkPassive == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "checkPassive");
            }
            if ($.checkPath == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "checkPath");
            }
            if ($.checkTimeout == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "checkTimeout");
            }
            if ($.cipherSuite == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "cipherSuite");
            }
            if ($.id == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "id");
            }
            if ($.nodeStatuses == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "nodeStatuses");
            }
            if ($.nodebalancerId == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "nodebalancerId");
            }
            if ($.port == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "port");
            }
            if ($.protocol == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "protocol");
            }
            if ($.proxyProtocol == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "proxyProtocol");
            }
            if ($.sslCommonname == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "sslCommonname");
            }
            if ($.sslFingerprint == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "sslFingerprint");
            }
            if ($.stickiness == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "stickiness");
            }
            if ($.udpCheckPort == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "udpCheckPort");
            }
            if ($.udpSessionTimeout == null) {
                throw new MissingRequiredPropertyException("GetNodebalancerConfigsNodebalancerConfig", "udpSessionTimeout");
            }
            return $;
        }
    }

}
