// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DatabaseMongodbUpdates {
    dayOfWeek: string;
    duration: number;
    frequency: string;
    hourOfDay: number;
    weekOfMonth?: number;
}

export interface DatabaseMysqlUpdates {
    dayOfWeek: string;
    duration: number;
    frequency: string;
    hourOfDay: number;
    weekOfMonth?: number;
}

export interface DatabasePostgresqlUpdates {
    dayOfWeek: string;
    duration: number;
    frequency: string;
    hourOfDay: number;
    weekOfMonth?: number;
}

export interface FirewallDevice {
    /**
     * The ID of the underlying entity this device references (i.e. the Linode's ID).
     */
    entityId: number;
    /**
     * The ID of the Firewall Device.
     */
    id: number;
    /**
     * Used to identify this rule. For display purposes only.
     */
    label: string;
    /**
     * The type of Firewall Device.
     */
    type: string;
    url: string;
}

export interface FirewallInbound {
    /**
     * Controls whether traffic is accepted or dropped by this rule (`ACCEPT`, `DROP`). Overrides the Firewall’s inboundPolicy if this is an inbound rule, or the outboundPolicy if this is an outbound rule.
     */
    action: string;
    /**
     * A list of IPv4 addresses or networks. Must be in IP/mask format.
     */
    ipv4s?: string[];
    /**
     * A list of IPv6 addresses or networks. Must be in IP/mask format.
     */
    ipv6s?: string[];
    /**
     * Used to identify this rule. For display purposes only.
     */
    label: string;
    /**
     * A string representation of ports and/or port ranges (i.e. "443" or "80-90, 91").
     */
    ports?: string;
    /**
     * The network protocol this rule controls. (`TCP`, `UDP`, `ICMP`)
     */
    protocol: string;
}

export interface FirewallOutbound {
    /**
     * Controls whether traffic is accepted or dropped by this rule (`ACCEPT`, `DROP`). Overrides the Firewall’s inboundPolicy if this is an inbound rule, or the outboundPolicy if this is an outbound rule.
     */
    action: string;
    /**
     * A list of IPv4 addresses or networks. Must be in IP/mask format.
     */
    ipv4s?: string[];
    /**
     * A list of IPv6 addresses or networks. Must be in IP/mask format.
     */
    ipv6s?: string[];
    /**
     * Used to identify this rule. For display purposes only.
     */
    label: string;
    /**
     * A string representation of ports and/or port ranges (i.e. "443" or "80-90, 91").
     */
    ports?: string;
    /**
     * The network protocol this rule controls. (`TCP`, `UDP`, `ICMP`)
     */
    protocol: string;
}

export interface GetDatabaseBackupsBackup {
    /**
     * A time value given in a combined date and time format that represents when the database backup was created.
     */
    created: string;
    /**
     * The ID of the database backup object.
     */
    id: number;
    /**
     * The database backup’s label, for display purposes only.
     */
    label: string;
    /**
     * The type of database backup, determined by how the backup was created.
     */
    type: string;
}

export interface GetDatabaseBackupsFilter {
    /**
     * The method to match the field by. (`exact`, `regex`, `substring`; default `exact`)
     */
    matchBy?: string;
    /**
     * The name of the field to filter by.
     */
    name: string;
    /**
     * A list of values for the filter to allow. These values should all be in string form.
     */
    values: string[];
}

export interface GetDatabaseEnginesEngine {
    /**
     * The Managed Database engine type.
     */
    engine: string;
    /**
     * The Managed Database engine ID in engine/version format.
     */
    id: string;
    /**
     * The Managed Database engine version.
     */
    version: string;
}

export interface GetDatabaseEnginesFilter {
    /**
     * The method to match the field by. (`exact`, `regex`, `substring`; default `exact`)
     */
    matchBy?: string;
    /**
     * The name of the field to filter by.
     */
    name: string;
    /**
     * A list of values for the filter to allow. These values should all be in string form.
     */
    values: string[];
}

export interface GetDatabaseMongodbUpdate {
    dayOfWeek: string;
    duration: number;
    frequency: string;
    hourOfDay: number;
    weekOfMonth: number;
}

export interface GetDatabaseMysqlBackupsBackup {
    /**
     * A time value given in a combined date and time format that represents when the database backup was created.
     */
    created: string;
    /**
     * The ID of the database backup object.
     */
    id: number;
    /**
     * The database backup’s label, for display purposes only.
     */
    label: string;
    /**
     * The type of database backup, determined by how the backup was created.
     */
    type: string;
}

export interface GetDatabaseMysqlBackupsFilter {
    /**
     * The method to match the field by. (`exact`, `regex`, `substring`; default `exact`)
     */
    matchBy?: string;
    /**
     * The name of the field to filter by.
     */
    name: string;
    /**
     * A list of values for the filter to allow. These values should all be in string form.
     */
    values: string[];
}

export interface GetDatabaseMysqlUpdate {
    dayOfWeek: string;
    duration: number;
    frequency: string;
    hourOfDay: number;
    weekOfMonth: number;
}

export interface GetDatabasePostgresqlUpdate {
    dayOfWeek: string;
    duration: number;
    frequency: string;
    hourOfDay: number;
    weekOfMonth: number;
}

export interface GetDatabasesDatabase {
    /**
     * A list of IP addresses that can access the Managed Database.
     */
    allowLists: string[];
    /**
     * The number of Linode Instance nodes deployed to the Managed Database.
     */
    clusterSize: number;
    /**
     * When this Managed Database was created.
     */
    created: string;
    /**
     * Whether the Managed Databases is encrypted.
     */
    encrypted: boolean;
    /**
     * The Managed Database engine.
     */
    engine: string;
    /**
     * The primary host for the Managed Database.
     */
    hostPrimary: string;
    /**
     * The secondary/private network host for the Managed Database.
     */
    hostSecondary: string;
    /**
     * The ID of the Managed Database.
     */
    id: number;
    instanceUri: string;
    /**
     * A unique, user-defined string referring to the Managed Database.
     */
    label: string;
    /**
     * The region to use for the Managed Database.
     */
    region: string;
    /**
     * The replication method used for the Managed Database.
     */
    replicationType: string;
    /**
     * Whether to require SSL credentials to establish a connection to the Managed Database.
     */
    sslConnection: boolean;
    /**
     * The operating status of the Managed Database.
     */
    status: string;
    /**
     * The Linode Instance type used for the nodes of the  Managed Database instance.
     */
    type: string;
    /**
     * When this Managed Database was last updated.
     */
    updated: string;
    /**
     * The Managed Database engine version.
     */
    version: string;
}

export interface GetDatabasesFilter {
    /**
     * The method to match the field by. (`exact`, `regex`, `substring`; default `exact`)
     */
    matchBy?: string;
    /**
     * The name of the field to filter by.
     */
    name: string;
    /**
     * A list of values for the filter to allow. These values should all be in string form.
     */
    values: string[];
}

export interface GetFirewallDevice {
    /**
     * The ID of the underlying entity this device references (i.e. the Linode's ID).
     */
    entityId: number;
    /**
     * The Firewall's ID.
     */
    id: number;
    /**
     * The label of the underlying entity this device references.
     */
    label: string;
    /**
     * The type of Firewall Device.
     */
    type: string;
    url: string;
}

export interface GetFirewallInbound {
    /**
     * Controls whether traffic is accepted or dropped by this rule. Overrides the Firewall’s inboundPolicy if this is an inbound rule, or the outboundPolicy if this is an outbound rule.
     */
    action: string;
    /**
     * A list of IPv4 addresses or networks. Must be in IP/mask format.
     */
    ipv4s: string[];
    /**
     * A list of IPv6 addresses or networks. Must be in IP/mask format.
     */
    ipv6s: string[];
    /**
     * The label of the underlying entity this device references.
     */
    label: string;
    /**
     * A string representation of ports and/or port ranges (i.e. "443" or "80-90, 91").
     */
    ports: string;
    /**
     * The network protocol this rule controls. (`TCP`, `UDP`, `ICMP`)
     */
    protocol: string;
}

export interface GetFirewallOutbound {
    /**
     * Controls whether traffic is accepted or dropped by this rule. Overrides the Firewall’s inboundPolicy if this is an inbound rule, or the outboundPolicy if this is an outbound rule.
     */
    action: string;
    /**
     * A list of IPv4 addresses or networks. Must be in IP/mask format.
     */
    ipv4s: string[];
    /**
     * A list of IPv6 addresses or networks. Must be in IP/mask format.
     */
    ipv6s: string[];
    /**
     * The label of the underlying entity this device references.
     */
    label: string;
    /**
     * A string representation of ports and/or port ranges (i.e. "443" or "80-90, 91").
     */
    ports: string;
    /**
     * The network protocol this rule controls. (`TCP`, `UDP`, `ICMP`)
     */
    protocol: string;
}

export interface GetImagesFilter {
    /**
     * The method to match the field by. (`exact`, `regex`, `substring`; default `exact`)
     */
    matchBy?: string;
    /**
     * The name of the field to filter by. See the Filterable Fields section for a complete list of filterable fields.
     */
    name: string;
    /**
     * A list of values for the filter to allow. These values should all be in string form.
     */
    values: string[];
}

export interface GetImagesImage {
    /**
     * When this Image was created.
     */
    created: string;
    /**
     * The name of the User who created this Image, or "linode" for official Images.
     */
    createdBy: string;
    /**
     * Whether or not this Image is deprecated. Will only be true for deprecated public Images.
     */
    deprecated: boolean;
    /**
     * A detailed description of this Image.
     */
    description: string;
    expiry: string;
    /**
     * The unique ID of this Image.  The ID of private images begin with `private/` followed by the numeric identifier of the private image, for example `private/12345`.
     */
    id: string;
    /**
     * True if the Image is public.
     */
    isPublic: boolean;
    /**
     * A short description of the Image.
     */
    label: string;
    /**
     * The minimum size this Image needs to deploy. Size is in MB. example: 2500
     */
    size: number;
    /**
     * The current status of this image. (`creating`, `pendingUpload`, `available`)
     */
    status: string;
    /**
     * How the Image was created. Manual Images can be created at any time. "Automatic" Images are created automatically from a deleted Linode. (`manual`, `automatic`)
     */
    type: string;
    /**
     * The upstream distribution vendor. `None` for private Images.
     */
    vendor: string;
}

export interface GetInstanceBackupsAutomatic {
    /**
     * A list of the labels of the Configuration profiles that are part of the Backup.
     */
    configs: string[];
    /**
     * The date the Backup was taken.
     */
    created: string;
    disks: outputs.GetInstanceBackupsAutomaticDisk[];
    /**
     * The date the Backup completed.
     */
    finished: string;
    /**
     * The unique ID of this Backup.
     */
    id: number;
    /**
     * The label of this disk.
     */
    label: string;
    /**
     * The current state of a specific Backup. (`paused`, `pending`, `running`, `needsPostProcessing`, `successful`, `failed`, `userAborted`)
     */
    status: string;
    /**
     * This indicates whether the Backup is an automatic Backup or manual snapshot taken by the User at a specific point in time. (`auto`, `snapshot`)
     */
    type: string;
    /**
     * The date the Backup was most recently updated.
     */
    updated: string;
}

export interface GetInstanceBackupsAutomaticDisk {
    /**
     * The filesystem of this disk.
     */
    filesystem: string;
    /**
     * The label of this disk.
     */
    label: string;
    /**
     * The size of this disk.
     */
    size: number;
}

export interface GetInstanceBackupsCurrent {
    /**
     * A list of the labels of the Configuration profiles that are part of the Backup.
     */
    configs: string[];
    /**
     * The date the Backup was taken.
     */
    created: string;
    disks: outputs.GetInstanceBackupsCurrentDisk[];
    /**
     * The date the Backup completed.
     */
    finished: string;
    /**
     * The unique ID of this Backup.
     */
    id: number;
    /**
     * The label of this disk.
     */
    label: string;
    /**
     * The current state of a specific Backup. (`paused`, `pending`, `running`, `needsPostProcessing`, `successful`, `failed`, `userAborted`)
     */
    status: string;
    /**
     * This indicates whether the Backup is an automatic Backup or manual snapshot taken by the User at a specific point in time. (`auto`, `snapshot`)
     */
    type: string;
    /**
     * The date the Backup was most recently updated.
     */
    updated: string;
}

export interface GetInstanceBackupsCurrentDisk {
    /**
     * The filesystem of this disk.
     */
    filesystem: string;
    /**
     * The label of this disk.
     */
    label: string;
    /**
     * The size of this disk.
     */
    size: number;
}

export interface GetInstanceBackupsInProgress {
    /**
     * A list of the labels of the Configuration profiles that are part of the Backup.
     */
    configs: string[];
    /**
     * The date the Backup was taken.
     */
    created: string;
    disks: outputs.GetInstanceBackupsInProgressDisk[];
    /**
     * The date the Backup completed.
     */
    finished: string;
    /**
     * The unique ID of this Backup.
     */
    id: number;
    /**
     * The label of this disk.
     */
    label: string;
    /**
     * The current state of a specific Backup. (`paused`, `pending`, `running`, `needsPostProcessing`, `successful`, `failed`, `userAborted`)
     */
    status: string;
    /**
     * This indicates whether the Backup is an automatic Backup or manual snapshot taken by the User at a specific point in time. (`auto`, `snapshot`)
     */
    type: string;
    /**
     * The date the Backup was most recently updated.
     */
    updated: string;
}

export interface GetInstanceBackupsInProgressDisk {
    /**
     * The filesystem of this disk.
     */
    filesystem: string;
    /**
     * The label of this disk.
     */
    label: string;
    /**
     * The size of this disk.
     */
    size: number;
}

export interface GetInstanceTypeAddons {
    backups: outputs.GetInstanceTypeAddonsBackups;
}

export interface GetInstanceTypeAddonsBackups {
    price: outputs.GetInstanceTypeAddonsBackupsPrice;
}

export interface GetInstanceTypeAddonsBackupsPrice {
    hourly: number;
    monthly: number;
}

export interface GetInstanceTypePrice {
    hourly: number;
    monthly: number;
}

export interface GetInstanceTypesFilter {
    /**
     * The method to match the field by. (`exact`, `regex`, `substring`; default `exact`)
     */
    matchBy?: string;
    /**
     * The name of the field to filter by. See the Filterable Fields section for a complete list of filterable fields.
     */
    name: string;
    /**
     * A list of values for the filter to allow. These values should all be in string form.
     */
    values: string[];
}

export interface GetInstanceTypesType {
    addons: outputs.GetInstanceTypesTypeAddon[];
    /**
     * The class of the Linode Type. See all classes [here](https://www.linode.com/docs/api/linode-types/#type-view__responses).
     */
    class: string;
    /**
     * The Disk size, in MB, of the Linode Type.
     */
    disk: number;
    /**
     * The ID representing the Linode Type.
     */
    id: string;
    /**
     * The Linode Type's label is for display purposes only.
     */
    label: string;
    /**
     * The amount of RAM included in this Linode Type.
     */
    memory: number;
    /**
     * The Mbits outbound bandwidth allocation.
     */
    networkOut: number;
    prices: outputs.GetInstanceTypesTypePrice[];
    /**
     * The monthly outbound transfer amount, in MB.
     */
    transfer: number;
    /**
     * The number of VCPU cores this Linode Type offers.
     */
    vcpus: number;
}

export interface GetInstanceTypesTypeAddon {
    backups: outputs.GetInstanceTypesTypeAddonBackup[];
}

export interface GetInstanceTypesTypeAddonBackup {
    prices: outputs.GetInstanceTypesTypeAddonBackupPrice[];
}

export interface GetInstanceTypesTypeAddonBackupPrice {
    hourly: number;
    monthly: number;
}

export interface GetInstanceTypesTypePrice {
    hourly: number;
    monthly: number;
}

export interface GetInstancesFilter {
    /**
     * The method to match the field by. (`exact`, `regex`, `substring`; default `exact`)
     */
    matchBy?: string;
    /**
     * The name of the field to filter by. See the Filterable Fields section for a list of filterable fields.
     */
    name: string;
    /**
     * A list of values for the filter to allow. These values should all be in string form.
     */
    values: string[];
}

export interface GetInstancesInstance {
    alerts: outputs.GetInstancesInstanceAlerts;
    backups: outputs.GetInstancesInstanceBackup[];
    bootConfigLabel: string;
    configs: outputs.GetInstancesInstanceConfig[];
    disks: outputs.GetInstancesInstanceDisk[];
    /**
     * The display group of the Linode instance.
     */
    group: string;
    /**
     * The ID of the disk in the Linode API.
     */
    id: number;
    /**
     * An Image ID to deploy the Disk from. Official Linode Images start with linode/, while your Images start with `private/`. See [images](https://api.linode.com/v4/images) for more information on the Images available for you to use. Examples are `linode/debian9`, `linode/fedora28`, `linode/ubuntu16.04lts`, `linode/arch`, and `private/12345`. See all images [here](https://api.linode.com/v4/linode/images) (Requires a personal access token; docs [here](https://developers.linode.com/api/v4/images)). *This value can not be imported.* *Changing `image` forces the creation of a new Linode Instance.*
     */
    image: string;
    /**
     * A string containing the Linode's public IP address.
     */
    ipAddress: string;
    /**
     * This Linode's IPv4 Addresses. Each Linode is assigned a single public IPv4 address upon creation, and may get a single private IPv4 address if needed. You may need to open a support ticket to get additional IPv4 addresses.
     */
    ipv4s: string[];
    /**
     * This Linode's IPv6 SLAAC addresses. This address is specific to a Linode, and may not be shared.  The prefix (`/64`) is included in this attribute.
     */
    ipv6: string;
    /**
     * (Optional) The name of this interface. If the interface is a `vlan`, a label is required. Must be undefined for `public` purpose interfaces.
     */
    label: string;
    /**
     * This Linode's Private IPv4 Address, if enabled.  The regional private IP address range, 192.168.128.0/17, is shared by all Linode Instances in a region.
     */
    privateIpAddress: string;
    /**
     * This is the location where the Linode is deployed. Examples are `"us-east"`, `"us-west"`, `"ap-south"`, etc. See all regions [here](https://api.linode.com/v4/regions).
     */
    region: string;
    specs: outputs.GetInstancesInstanceSpec[];
    /**
     * The status of the instance, indicating the current readiness state. (`running`, `offline`, ...)
     */
    status: string;
    /**
     * When deploying from an Image, this field is optional with a Linode API default of 512mb, otherwise it is ignored. This is used to set the swap disk size for the newly-created Linode.
     */
    swapSize: number;
    /**
     * A list of tags applied to this object. Tags are for organizational purposes only.
     */
    tags: string[];
    /**
     * The Linode type defines the pricing, CPU, disk, and RAM specs of the instance. Examples are `"g6-nanode-1"`, `"g6-standard-2"`, `"g6-highmem-16"`, `"g6-dedicated-16"`, etc. See all types [here](https://api.linode.com/v4/linode/types).
     */
    type: string;
    /**
     * The watchdog, named Lassie, is a Shutdown Watchdog that monitors your Linode and will reboot it if it powers off unexpectedly. It works by issuing a boot job when your Linode powers off without a shutdown job being responsible. To prevent a loop, Lassie will give up if there have been more than 5 boot jobs issued within 15 minutes.
     */
    watchdogEnabled: boolean;
}

export interface GetInstancesInstanceAlerts {
    cpu: number;
    io: number;
    networkIn: number;
    networkOut: number;
    transferQuota: number;
}

export interface GetInstancesInstanceBackup {
    /**
     * If this Linode has the Backup service enabled.
     */
    enabled: boolean;
    schedules: outputs.GetInstancesInstanceBackupSchedule[];
}

export interface GetInstancesInstanceBackupSchedule {
    /**
     * The day of the week that your Linode's weekly Backup is taken. If not set manually, a day will be chosen for you. Backups are taken every day, but backups taken on this day are preferred when selecting backups to retain for a longer period.  If not set manually, then when backups are initially enabled, this may come back as "Scheduling" until the day is automatically selected.
     */
    day: string;
    /**
     * The window ('W0'-'W22') in which your backups will be taken, in UTC. A backups window is a two-hour span of time in which the backup may occur. For example, 'W10' indicates that your backups should be taken between 10:00 and 12:00. If you do not choose a backup window, one will be selected for you automatically.  If not set manually, when backups are initially enabled this may come back as Scheduling until the window is automatically selected.
     */
    window: string;
}

export interface GetInstancesInstanceConfig {
    /**
     * Arbitrary user comments about this `config`.
     */
    comments: string;
    /**
     * A list of `disk` or `volume` attachments for this `config`.  If the `bootConfigLabel` omits a `devices` block, the Linode will not be booted.
     */
    devices: outputs.GetInstancesInstanceConfigDevice[];
    /**
     * Helpers enabled when booting to this Linode Config.
     */
    helpers: outputs.GetInstancesInstanceConfigHelper[];
    interfaces: outputs.GetInstancesInstanceConfigInterface[];
    /**
     * A Kernel ID to boot a Linode with. Default is based on image choice. Examples are `linode/latest-64bit`, `linode/grub2`, `linode/direct-disk`, etc. See all kernels [here](https://api.linode.com/v4/linode/kernels). Note that this is a paginated API endpoint ([docs](https://developers.linode.com/api/v4/linode-kernels)).
     */
    kernel: string;
    /**
     * (Optional) The name of this interface. If the interface is a `vlan`, a label is required. Must be undefined for `public` purpose interfaces.
     */
    label: string;
    /**
     * Defaults to the total RAM of the Linode
     */
    memoryLimit: number;
    /**
     * The root device to boot.
     */
    rootDevice: string;
    /**
     * Defines the state of your Linode after booting.
     */
    runLevel: string;
    /**
     * Controls the virtualization mode.
     */
    virtMode: string;
}

export interface GetInstancesInstanceConfigDevice {
    sdas: outputs.GetInstancesInstanceConfigDeviceSda[];
    sdbs: outputs.GetInstancesInstanceConfigDeviceSdb[];
    sdcs: outputs.GetInstancesInstanceConfigDeviceSdc[];
    sdds: outputs.GetInstancesInstanceConfigDeviceSdd[];
    sdes: outputs.GetInstancesInstanceConfigDeviceSde[];
    sdfs: outputs.GetInstancesInstanceConfigDeviceSdf[];
    sdgs: outputs.GetInstancesInstanceConfigDeviceSdg[];
    sdhs: outputs.GetInstancesInstanceConfigDeviceSdh[];
}

export interface GetInstancesInstanceConfigDeviceSda {
    /**
     * The Disk ID of the associated `diskLabel`, if used
     */
    diskId: number;
    /**
     * The `label` of the `disk` to map to this `device` slot.
     */
    diskLabel?: string;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface GetInstancesInstanceConfigDeviceSdb {
    /**
     * The Disk ID of the associated `diskLabel`, if used
     */
    diskId: number;
    /**
     * The `label` of the `disk` to map to this `device` slot.
     */
    diskLabel?: string;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface GetInstancesInstanceConfigDeviceSdc {
    /**
     * The Disk ID of the associated `diskLabel`, if used
     */
    diskId: number;
    /**
     * The `label` of the `disk` to map to this `device` slot.
     */
    diskLabel?: string;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface GetInstancesInstanceConfigDeviceSdd {
    /**
     * The Disk ID of the associated `diskLabel`, if used
     */
    diskId: number;
    /**
     * The `label` of the `disk` to map to this `device` slot.
     */
    diskLabel?: string;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface GetInstancesInstanceConfigDeviceSde {
    /**
     * The Disk ID of the associated `diskLabel`, if used
     */
    diskId: number;
    /**
     * The `label` of the `disk` to map to this `device` slot.
     */
    diskLabel?: string;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface GetInstancesInstanceConfigDeviceSdf {
    /**
     * The Disk ID of the associated `diskLabel`, if used
     */
    diskId: number;
    /**
     * The `label` of the `disk` to map to this `device` slot.
     */
    diskLabel?: string;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface GetInstancesInstanceConfigDeviceSdg {
    /**
     * The Disk ID of the associated `diskLabel`, if used
     */
    diskId: number;
    /**
     * The `label` of the `disk` to map to this `device` slot.
     */
    diskLabel?: string;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface GetInstancesInstanceConfigDeviceSdh {
    /**
     * The Disk ID of the associated `diskLabel`, if used
     */
    diskId: number;
    /**
     * The `label` of the `disk` to map to this `device` slot.
     */
    diskLabel?: string;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface GetInstancesInstanceConfigHelper {
    devtmpfsAutomount: boolean;
    /**
     * Controls the behavior of the Linode Config's Distribution Helper setting.
     */
    distro: boolean;
    /**
     * Creates a modules dependency file for the Kernel you run.
     */
    modulesDep: boolean;
    /**
     * Controls the behavior of the Linode Config's Network Helper setting, used to automatically configure additional IP addresses assigned to this instance.
     */
    network: boolean;
    /**
     * Disables updatedb cron job to avoid disk thrashing.
     */
    updatedbDisabled: boolean;
}

export interface GetInstancesInstanceConfigInterface {
    /**
     * (Optional) This Network Interface’s private IP address in Classless Inter-Domain Routing (CIDR) notation.
     */
    ipamAddress?: string;
    /**
     * (Optional) The name of this interface. If the interface is a `vlan`, a label is required. Must be undefined for `public` purpose interfaces.
     */
    label?: string;
    /**
     * (Required) The type of interface. (`public`, `vlan`)
     */
    purpose?: string;
}

export interface GetInstancesInstanceDisk {
    filesystem: string;
    /**
     * The ID of the disk in the Linode API.
     */
    id: number;
    /**
     * (Optional) The name of this interface. If the interface is a `vlan`, a label is required. Must be undefined for `public` purpose interfaces.
     */
    label: string;
    /**
     * The size of the Disk in MB.
     */
    size: number;
}

export interface GetInstancesInstanceSpec {
    disk: number;
    memory: number;
    transfer: number;
    vcpus: number;
}

export interface GetLkeClusterControlPlane {
    highAvailability: boolean;
}

export interface GetLkeClusterPool {
    /**
     * The configuration options for the autoscaler. This field only contains an autoscaler configuration if autoscaling is enabled on this cluster.
     */
    autoscalers: outputs.GetLkeClusterPoolAutoscaler[];
    /**
     * The number of nodes in the Node Pool.
     */
    count: number;
    /**
     * The LKE Cluster's ID.
     */
    id: number;
    /**
     * The nodes in the Node Pool.
     */
    nodes: outputs.GetLkeClusterPoolNode[];
    /**
     * The linode type for all of the nodes in the Node Pool. See all node types [here](https://api.linode.com/v4/linode/types).
     */
    type: string;
}

export interface GetLkeClusterPoolAutoscaler {
    /**
     * The maximum number of nodes to autoscale to.
     */
    max: number;
    /**
     * The minimum number of nodes to autoscale to.
     */
    min: number;
}

export interface GetLkeClusterPoolNode {
    /**
     * The LKE Cluster's ID.
     */
    id: string;
    /**
     * The ID of the underlying Linode instance.
     */
    instanceId: number;
    /**
     * The status of the node. (`ready`, `notReady`)
     */
    status: string;
}

export interface GetNodeBalancerConfigNodeStatus {
    /**
     * The number of backends considered to be 'DOWN' and unhealthy. These are not in rotation, and not serving requests.
     */
    down: number;
    /**
     * The number of backends considered to be 'UP' and healthy, and that are serving requests.
     */
    up: number;
}

export interface GetNodeBalancerTransfer {
    /**
     * The total transfer, in MB, used by this NodeBalancer for the current month
     */
    in: number;
    /**
     * The total inbound transfer, in MB, used for this NodeBalancer for the current month
     */
    out: number;
    /**
     * The total outbound transfer, in MB, used for this NodeBalancer for the current month
     */
    total: number;
}

export interface GetProfileReferrals {
    code: string;
    completed: number;
    credit: number;
    pending: number;
    total: number;
    url: string;
}

export interface GetStackScriptUserDefinedField {
    /**
     * The default value. If not specified, this value will be used.
     */
    default: string;
    /**
     * An example value for the field.
     */
    example: string;
    /**
     * A human-readable label for the field that will serve as the input prompt for entering the value during deployment.
     */
    label: string;
    /**
     * A list of acceptable values for the field in any quantity, combination or order.
     */
    manyOf: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A list of acceptable single values for the field.
     */
    oneOf: string;
}

export interface GetStackScriptsFilter {
    /**
     * The method to match the field by. (`exact`, `regex`, `substring`; default `exact`)
     */
    matchBy?: string;
    /**
     * The name of the field to filter by. See the Filterable Fields section for a complete list of filterable fields.
     */
    name: string;
    /**
     * A list of values for the filter to allow. These values should all be in string form.
     */
    values: string[];
}

export interface GetStackScriptsStackscript {
    /**
     * The date this StackScript was created.
     */
    created: string;
    /**
     * Count of currently active, deployed Linodes created from this StackScript.
     */
    deploymentsActive: number;
    /**
     * The total number of times this StackScript has been deployed.
     */
    deploymentsTotal: number;
    /**
     * A description for the StackScript.
     */
    description: string;
    /**
     * The unique ID of the StackScript.
     */
    id: number;
    /**
     * An array of Image IDs representing the Images that this StackScript is compatible for deploying with.
     */
    images: string[];
    /**
     * This determines whether other users can use your StackScript. Once a StackScript is made public, it cannot be made private.
     */
    isPublic: boolean;
    /**
     * A human-readable label for the field that will serve as the input prompt for entering the value during deployment.
     */
    label: string;
    /**
     * This field allows you to add notes for the set of revisions made to this StackScript.
     */
    revNote: string;
    /**
     * The script to execute when provisioning a new Linode with this StackScript.
     */
    script: string;
    /**
     * The date this StackScript was updated.
     */
    updated: string;
    /**
     * This is a list of fields defined with a special syntax inside this StackScript that allow for supplying customized parameters during deployment.
     */
    userDefinedFields: outputs.GetStackScriptsStackscriptUserDefinedField[];
    /**
     * The Gravatar ID for the User who created the StackScript.
     */
    userGravatarId: string;
    /**
     * The User who created the StackScript.
     */
    username: string;
}

export interface GetStackScriptsStackscriptUserDefinedField {
    /**
     * The default value. If not specified, this value will be used.
     */
    default: string;
    /**
     * An example value for the field.
     */
    example: string;
    /**
     * A human-readable label for the field that will serve as the input prompt for entering the value during deployment.
     */
    label: string;
    /**
     * A list of acceptable values for the field in any quantity, combination or order.
     */
    manyOf: string;
    /**
     * The name of the field to filter by. See the Filterable Fields section for a complete list of filterable fields.
     */
    name: string;
    /**
     * A list of acceptable single values for the field.
     */
    oneOf: string;
}

export interface GetVlansFilter {
    /**
     * The method to match the field by. (`exact`, `regex`, `substring`; default `exact`)
     */
    matchBy?: string;
    /**
     * The name of the field to filter by. See the Filterable Fields section for a complete list of filterable fields.
     */
    name: string;
    /**
     * A list of values for the filter to allow. These values should all be in string form.
     */
    values: string[];
}

export interface GetVlansVlan {
    /**
     * When the VLAN was created.
     */
    created: string;
    /**
     * The unique label of the VLAN.
     */
    label: string;
    /**
     * The running Linodes currently attached to the VLAN.
     */
    linodes: number[];
    /**
     * The region the VLAN is located in. See all regions [here](https://api.linode.com/v4/regions).
     */
    region: string;
}

export interface InstanceAlerts {
    cpu: number;
    io: number;
    networkIn: number;
    networkOut: number;
    transferQuota: number;
}

export interface InstanceBackups {
    /**
     * If this Linode has the Backup service enabled.
     */
    enabled: boolean;
    schedule: outputs.InstanceBackupsSchedule;
}

export interface InstanceBackupsSchedule {
    /**
     * The day of the week that your Linode's weekly Backup is taken. If not set manually, a day will be chosen for you. Backups are taken every day, but backups taken on this day are preferred when selecting backups to retain for a longer period.  If not set manually, then when backups are initially enabled, this may come back as "Scheduling" until the day is automatically selected.
     */
    day: string;
    /**
     * The window ('W0'-'W22') in which your backups will be taken, in UTC. A backups window is a two-hour span of time in which the backup may occur. For example, 'W10' indicates that your backups should be taken between 10:00 and 12:00. If you do not choose a backup window, one will be selected for you automatically.  If not set manually, when backups are initially enabled this may come back as Scheduling until the window is automatically selected.
     */
    window: string;
}

export interface InstanceConfig {
    /**
     * - Arbitrary user comments about this `config`.
     */
    comments?: string;
    /**
     * A list of `disk` or `volume` attachments for this `config`.  If the `bootConfigLabel` omits a `devices` block, the Linode will not be booted.
     */
    devices: outputs.InstanceConfigDevices;
    /**
     * Helpers enabled when booting to this Linode Config.
     */
    helpers: outputs.InstanceConfigHelpers;
    interfaces?: outputs.InstanceConfigInterface[];
    /**
     * - A Kernel ID to boot a Linode with. Default is based on image choice. Examples are `linode/latest-64bit`, `linode/grub2`, `linode/direct-disk`, etc. See all kernels [here](https://api.linode.com/v4/linode/kernels). Note that this is a paginated API endpoint ([docs](https://developers.linode.com/api/v4/linode-kernels)).
     */
    kernel?: string;
    /**
     * The name of this interface. If the interface is a VLAN, a label is required.
     */
    label: string;
    /**
     * - Defaults to the total RAM of the Linode
     */
    memoryLimit?: number;
    /**
     * - The root device to boot. The corresponding disk must be attached to a `device` slot.  Example: `"/dev/sda"`
     */
    rootDevice: string;
    /**
     * - Defines the state of your Linode after booting. Defaults to `"default"`.
     */
    runLevel?: string;
    /**
     * - Controls the virtualization mode. Defaults to `"paravirt"`.
     */
    virtMode?: string;
}

export interface InstanceConfigDevices {
    /**
     * ... `sdh` - (Optional) The SDA-SDH slots, represent the Linux block device nodes for the first 8 disks attached to the Linode.  Each device must be suplied sequentially.  The device can be either a Disk or a Volume identified by `diskId` or `volumeId`. Only one disk identifier is permitted per slot. Devices mapped from `sde` through `sdh` are unavailable in `"fullvirt"` `virtMode`.
     */
    sda?: outputs.InstanceConfigDevicesSda;
    sdb?: outputs.InstanceConfigDevicesSdb;
    sdc?: outputs.InstanceConfigDevicesSdc;
    sdd?: outputs.InstanceConfigDevicesSdd;
    sde?: outputs.InstanceConfigDevicesSde;
    sdf?: outputs.InstanceConfigDevicesSdf;
    sdg?: outputs.InstanceConfigDevicesSdg;
    sdh?: outputs.InstanceConfigDevicesSdh;
}

export interface InstanceConfigDevicesSda {
    /**
     * The Disk ID to map to this `device` slot
     */
    diskId?: number;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface InstanceConfigDevicesSdb {
    /**
     * The Disk ID to map to this `device` slot
     */
    diskId?: number;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface InstanceConfigDevicesSdc {
    /**
     * The Disk ID to map to this `device` slot
     */
    diskId?: number;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface InstanceConfigDevicesSdd {
    /**
     * The Disk ID to map to this `device` slot
     */
    diskId?: number;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface InstanceConfigDevicesSde {
    /**
     * The Disk ID to map to this `device` slot
     */
    diskId?: number;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface InstanceConfigDevicesSdf {
    /**
     * The Disk ID to map to this `device` slot
     */
    diskId?: number;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface InstanceConfigDevicesSdg {
    /**
     * The Disk ID to map to this `device` slot
     */
    diskId?: number;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface InstanceConfigDevicesSdh {
    /**
     * The Disk ID to map to this `device` slot
     */
    diskId?: number;
    /**
     * The Volume ID to map to this `device` slot.
     */
    volumeId?: number;
}

export interface InstanceConfigHelper {
    /**
     * Populates the /dev directory early during boot without udev. (default `true`)
     */
    devtmpfsAutomount?: boolean;
    /**
     * Helps maintain correct inittab/upstart console device. (default `true`)
     */
    distro?: boolean;
    /**
     * Creates a modules dependency file for the Kernel you run. (default `true`)
     */
    modulesDep?: boolean;
    /**
     * Automatically configures static networking. (default `true`)
     */
    network?: boolean;
    /**
     * Disables updatedb cron job to avoid disk thrashing. (default `true`)
     */
    updatedbDisabled?: boolean;
}

export interface InstanceConfigHelpers {
    devtmpfsAutomount?: boolean;
    /**
     * Controls the behavior of the Linode Config's Distribution Helper setting.
     */
    distro?: boolean;
    /**
     * Creates a modules dependency file for the Kernel you run.
     */
    modulesDep?: boolean;
    /**
     * Controls the behavior of the Linode Config's Network Helper setting, used to automatically configure additional IP addresses assigned to this instance.
     */
    network?: boolean;
    /**
     * Disables updatedb cron job to avoid disk thrashing.
     */
    updatedbDisabled?: boolean;
}

export interface InstanceConfigInterface {
    /**
     * This Network Interface’s private IP address in Classless Inter-Domain Routing (CIDR) notation. (e.g. `10.0.0.1/24`)
     */
    ipamAddress?: string;
    /**
     * The name of this interface.
     */
    label?: string;
    /**
     * The type of interface. (`public`, `vlan`)
     */
    purpose: string;
}

export interface InstanceDisk {
    /**
     * A list of SSH public keys to deploy for the root user on the newly created Linode. Only accepted if `image` is provided. *This value can not be imported.* *Changing `authorizedKeys` forces the creation of a new Linode Instance.*
     */
    authorizedKeys?: string[];
    /**
     * A list of Linode usernames. If the usernames have associated SSH keys, the keys will be appended to the `root` user's `~/.ssh/authorized_keys` file automatically. *This value can not be imported.* *Changing `authorizedUsers` forces the creation of a new Linode Instance.*
     */
    authorizedUsers?: string[];
    /**
     * The Disk filesystem can be one of: `"raw"`, `"swap"`, `"ext3"`, `"ext4"`, or `"initrd"` which has a max size of 32mb and can be used in the config `initrd` (not currently supported in this provider).
     */
    filesystem: string;
    /**
     * The ID of the disk in the Linode API.
     */
    id: number;
    /**
     * An Image ID to deploy the Disk from. Official Linode Images start with linode/, while your Images start with private/. See /images for more information on the Images available for you to use. Examples are `linode/debian9`, `linode/fedora28`, `linode/ubuntu16.04lts`, `linode/arch`, and `private/12345`. See all images [here](https://api.linode.com/v4/images). *Changing `image` forces the creation of a new Linode Instance.*
     */
    image: string;
    /**
     * The name of this interface. If the interface is a VLAN, a label is required.
     */
    label: string;
    /**
     * If true, this Disk is read-only.
     */
    readOnly: boolean;
    /**
     * The initial password for the `root` user account. *This value can not be imported.* *Changing `rootPass` forces the creation of a new Linode Instance.* *If omitted, a random password will be generated but will not be stored in state.*
     */
    rootPass?: string;
    /**
     * The size of the Disk in MB.
     */
    size: number;
    /**
     * An object containing responses to any User Defined Fields present in the StackScript being deployed to this Linode. Only accepted if 'stackscript_id' is given. The required values depend on the StackScript being deployed.  *This value can not be imported.* *Changing `stackscriptData` forces the creation of a new Linode Instance.*
     */
    stackscriptData: {[key: string]: any};
    /**
     * The StackScript to deploy to the newly created Linode. If provided, 'image' must also be provided, and must be an Image that is compatible with this StackScript. *This value can not be imported.* *Changing `stackscriptId` forces the creation of a new Linode Instance.*
     */
    stackscriptId: number;
}

export interface InstanceInterface {
    /**
     * This Network Interface’s private IP address in Classless Inter-Domain Routing (CIDR) notation.
     */
    ipamAddress?: string;
    /**
     * The name of this interface. If the interface is a VLAN, a label is required.
     */
    label?: string;
    /**
     * The type of interface. (`public`, `vlan`)
     */
    purpose?: string;
}

export interface InstanceSpecs {
    disk: number;
    memory: number;
    transfer: number;
    vcpus: number;
}

export interface LkeClusterControlPlane {
    /**
     * Defines whether High Availability is enabled for the cluster Control Plane. This is an **irreversible** change.
     */
    highAvailability: boolean;
}

export interface LkeClusterPool {
    autoscaler?: outputs.LkeClusterPoolAutoscaler;
    /**
     * The number of nodes in the Node Pool.
     */
    count: number;
    /**
     * The ID of the node.
     */
    id: number;
    nodes: outputs.LkeClusterPoolNode[];
    /**
     * A Linode Type for all of the nodes in the Node Pool. See all node types [here](https://api.linode.com/v4/linode/types).
     */
    type: string;
}

export interface LkeClusterPoolAutoscaler {
    /**
     * The maximum number of nodes to autoscale to.
     */
    max: number;
    /**
     * The minimum number of nodes to autoscale to.
     */
    min: number;
}

export interface LkeClusterPoolNode {
    /**
     * The ID of the node.
     */
    id: string;
    /**
     * The ID of the underlying Linode instance.
     */
    instanceId: number;
    /**
     * The status of the node. (`ready`, `notReady`)
     */
    status: string;
}

export interface NodeBalancerConfigNodeStatus {
    /**
     * The number of backends considered to be 'DOWN' and unhealthy. These are not in rotation, and not serving requests.
     */
    down: number;
    /**
     * The number of backends considered to be 'UP' and healthy, and that are serving requests.
     */
    up: number;
}

export interface NodeBalancerTransfer {
    /**
     * The total transfer, in MB, used by this NodeBalancer for the current month
     */
    in: number;
    /**
     * The total inbound transfer, in MB, used for this NodeBalancer for the current month
     */
    out: number;
    /**
     * The total outbound transfer, in MB, used for this NodeBalancer for the current month
     */
    total: number;
}

export interface ObjectStorageBucketCert {
    /**
     * The Base64 encoded and PEM formatted SSL certificate.
     */
    certificate: string;
    /**
     * The private key associated with the TLS/SSL certificate.
     */
    privateKey: string;
}

export interface ObjectStorageBucketLifecycleRule {
    /**
     * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
     */
    abortIncompleteMultipartUploadDays?: number;
    /**
     * Specifies whether the lifecycle rule is active.
     */
    enabled: boolean;
    expiration?: outputs.ObjectStorageBucketLifecycleRuleExpiration;
    /**
     * The unique identifier for the rule.
     */
    id: string;
    noncurrentVersionExpiration?: outputs.ObjectStorageBucketLifecycleRuleNoncurrentVersionExpiration;
    /**
     * The object key prefix identifying one or more objects to which the rule applies.
     */
    prefix?: string;
}

export interface ObjectStorageBucketLifecycleRuleExpiration {
    /**
     * Specifies the date after which you want the corresponding action to take effect.
     */
    date?: string;
    /**
     * Specifies the number of days non-current object versions expire.
     */
    days?: number;
    /**
     * On a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Linode Object Storage to delete expired object delete markers. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
     */
    expiredObjectDeleteMarker?: boolean;
}

export interface ObjectStorageBucketLifecycleRuleNoncurrentVersionExpiration {
    /**
     * Specifies the number of days non-current object versions expire.
     */
    days: number;
}

export interface ObjectStorageKeyBucketAccess {
    /**
     * The unique label of the bucket to which the key will grant limited access.
     */
    bucketName: string;
    /**
     * The Object Storage cluster where a bucket to which the key is granting access is hosted.
     */
    cluster: string;
    /**
     * This Limited Access Key’s permissions for the selected bucket. *Changing `permissions` forces the creation of a new Object Storage Key.* (`readWrite`, `readOnly`)
     */
    permissions: string;
}

export interface StackScriptUserDefinedField {
    /**
     * The default value. If not specified, this value will be used.
     */
    default: string;
    /**
     * An example value for the field.
     */
    example: string;
    /**
     * The StackScript's label is for display purposes only.
     */
    label: string;
    /**
     * A list of acceptable values for the field in any quantity, combination or order.
     */
    manyOf: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A list of acceptable single values for the field.
     */
    oneOf: string;
}

export interface UserDomainGrant {
    id: number;
    permissions: string;
}

export interface UserFirewallGrant {
    id: number;
    permissions: string;
}

export interface UserGlobalGrants {
    accountAccess?: string;
    addDomains?: boolean;
    addFirewalls?: boolean;
    addImages?: boolean;
    addLinodes?: boolean;
    addLongview?: boolean;
    addNodebalancers?: boolean;
    addStackscripts?: boolean;
    addVolumes?: boolean;
    cancelAccount?: boolean;
    longviewSubscription?: boolean;
}

export interface UserImageGrant {
    id: number;
    permissions: string;
}

export interface UserLinodeGrant {
    id: number;
    permissions: string;
}

export interface UserLongviewGrant {
    id: number;
    permissions: string;
}

export interface UserNodebalancerGrant {
    id: number;
    permissions: string;
}

export interface UserStackscriptGrant {
    id: number;
    permissions: string;
}

export interface UserVolumeGrant {
    id: number;
    permissions: string;
}
