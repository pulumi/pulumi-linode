"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const asset = require("../asset");
const metadata_1 = require("../metadata");
const resource_1 = require("../resource");
const settings_1 = require("./settings");
/**
 * rootPulumiStackTypeName is the type name that should be used to construct the root component in the tree of Pulumi
 * resources allocated by a deployment.  This must be kept up to date with
 * `github.com/pulumi/pulumi/pkg/resource/stack.RootPulumiStackTypeName`.
 */
exports.rootPulumiStackTypeName = "pulumi:pulumi:Stack";
/**
 * runInPulumiStack creates a new Pulumi stack resource and executes the callback inside of it.  Any outputs
 * returned by the callback will be stored as output properties on this resulting Stack object.
 */
function runInPulumiStack(init) {
    const stack = new Stack(init);
    return stack.outputs.promise();
}
exports.runInPulumiStack = runInPulumiStack;
/**
 * Stack is the root resource for a Pulumi stack. Before invoking the `init` callback, it registers itself as the root
 * resource with the Pulumi engine.
 */
class Stack extends resource_1.ComponentResource {
    constructor(init) {
        super(exports.rootPulumiStackTypeName, `${metadata_1.getProject()}-${metadata_1.getStack()}`);
        this.outputs = resource_1.output(this.runInit(init));
    }
    /**
     * runInit invokes the given init callback with this resource set as the root resource. The return value of init is
     * used as the stack's output properties.
     *
     * @param init The callback to run in the context of this Pulumi stack
     */
    runInit(init) {
        const _super = Object.create(null, {
            registerOutputs: { get: () => super.registerOutputs }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const parent = yield settings_1.getRootResource();
            if (parent) {
                throw new Error("Only one root Pulumi Stack may be active at once");
            }
            yield settings_1.setRootResource(this);
            let outputs;
            try {
                outputs = init();
            }
            finally {
                // We want to expose stack outputs as simple pojo objects (including Resources).  This
                // helps ensure that outputs can point to resources, and that that is stored and
                // presented as something reasonable, and not as just an id/urn in the case of
                // Resources.
                const massaged = resource_1.output(outputs).apply(v => massage(v, new Set()));
                _super.registerOutputs.call(this, massaged);
            }
            return outputs;
        });
    }
}
function massage(prop, seenObjects) {
    return __awaiter(this, void 0, void 0, function* () {
        if (prop === undefined ||
            prop === null ||
            typeof prop === "boolean" ||
            typeof prop === "number" ||
            typeof prop === "string") {
            return prop;
        }
        if (prop instanceof Promise) {
            return yield massage(yield prop, seenObjects);
        }
        if (resource_1.Output.isInstance(prop)) {
            return yield massage(yield prop.promise(), seenObjects);
        }
        // from this point on, we have complex objects.  If we see them again, we don't want to emit
        // them again fully or else we'd loop infinitely.
        if (seenObjects.has(prop)) {
            // Note: for Resources we hit again, emit their urn so cycles can be easily understood
            // in the pojo objects.
            if (resource_1.Resource.isInstance(prop)) {
                return yield massage(prop.urn, seenObjects);
            }
            return undefined;
        }
        seenObjects.add(prop);
        if (asset.Asset.isInstance(prop)) {
            if (prop.path !== undefined) {
                return { path: prop.path };
            }
            else if (prop.uri !== undefined) {
                return { uri: prop.uri };
            }
            else if (prop.text !== undefined) {
                return { text: "..." };
            }
            return undefined;
        }
        if (asset.Archive.isInstance(prop)) {
            if (prop.assets) {
                return { assets: massage(prop.assets, seenObjects) };
            }
            else if (prop.path !== undefined) {
                return { path: prop.path };
            }
            else if (prop.uri !== undefined) {
                return { uri: prop.uri };
            }
            return undefined;
        }
        if (resource_1.Resource.isInstance(prop)) {
            // Emit a resource as a normal pojo.  But filter out all our internal properties so that
            // they don't clutter the display/checkpoint with values not relevant to the application.
            return serializeAllKeys(n => !n.startsWith("__"));
        }
        if (prop instanceof Array) {
            const result = [];
            for (let i = 0; i < prop.length; i++) {
                result[i] = yield massage(prop[i], seenObjects);
            }
            return result;
        }
        return yield serializeAllKeys(n => true);
        function serializeAllKeys(include) {
            return __awaiter(this, void 0, void 0, function* () {
                const obj = {};
                for (const k of Object.keys(prop)) {
                    if (include(k)) {
                        obj[k] = yield massage(prop[k], seenObjects);
                    }
                }
                return obj;
            });
        }
    });
}
