"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const grpc = require("grpc");
const log = require("../log");
const resource_1 = require("../resource");
const debuggable_1 = require("./debuggable");
const rpc_1 = require("./rpc");
const settings_1 = require("./settings");
const gstruct = require("google-protobuf/google/protobuf/struct_pb.js");
const resproto = require("../proto/resource_pb.js");
/**
 * Reads an existing custom resource's state from the resource monitor.  Note that resources read in this way
 * will not be part of the resulting stack's state, as they are presumed to belong to another.
 */
function readResource(res, t, name, props, opts) {
    const id = opts.id;
    if (!id) {
        throw new Error("Cannot read resource whose options are lacking an ID value");
    }
    const label = `resource:${name}[${t}]#...`;
    log.debug(`Reading resource: id=${id}, t=${t}, name=${name}`);
    const monitor = settings_1.getMonitor();
    const resopAsync = prepareResource(label, res, true, props, opts);
    const preallocError = new Error();
    debuggable_1.debuggablePromise(resopAsync.then((resop) => __awaiter(this, void 0, void 0, function* () {
        const resolvedID = yield rpc_1.serializeProperty(label, id, []);
        log.debug(`ReadResource RPC prepared: id=${resolvedID}, t=${t}, name=${name}` +
            (settings_1.excessiveDebugOutput ? `, obj=${JSON.stringify(resop.serializedProps)}` : ``));
        // Create a resource request and do the RPC.
        const req = new resproto.ReadResourceRequest();
        req.setType(t);
        req.setName(name);
        req.setId(resolvedID);
        req.setParent(resop.parentURN);
        req.setProvider(resop.providerRef);
        req.setProperties(gstruct.Struct.fromJavaScript(resop.serializedProps));
        req.setDependenciesList(Array.from(resop.dependencies));
        // Now run the operation, serializing the invocation if necessary.
        const opLabel = `monitor.readResource(${label})`;
        runAsyncResourceOp(opLabel, () => __awaiter(this, void 0, void 0, function* () {
            const resp = yield debuggable_1.debuggablePromise(new Promise((resolve, reject) => monitor.readResource(req, (err, innerResponse) => {
                log.debug(`ReadResource RPC finished: ${label}; err: ${err}, resp: ${innerResponse}`);
                if (err) {
                    preallocError.message =
                        `failed to read resource #${resolvedID} '${name}' [${t}]: ${err.message}`;
                    reject(preallocError);
                }
                else {
                    resolve(innerResponse);
                }
            })), opLabel);
            // Now resolve everything: the URN, the ID (supplied as input), and the output properties.
            resop.resolveURN(resp.getUrn());
            resop.resolveID(resolvedID, resolvedID !== undefined);
            yield resolveOutputs(res, t, name, props, resp.getProperties(), resop.resolvers);
        }));
    })), label);
}
exports.readResource = readResource;
/**
 * registerResource registers a new resource object with a given type t and name.  It returns the auto-generated
 * URN and the ID that will resolve after the deployment has completed.  All properties will be initialized to property
 * objects that the registration operation will resolve at the right time (or remain unresolved for deployments).
 */
function registerResource(res, t, name, custom, props, opts) {
    const label = `resource:${name}[${t}]`;
    log.debug(`Registering resource: t=${t}, name=${name}, custom=${custom}`);
    const monitor = settings_1.getMonitor();
    const resopAsync = prepareResource(label, res, custom, props, opts);
    // In order to present a useful stack trace if an error does occur, we preallocate potential
    // errors here. V8 captures a stack trace at the moment an Error is created and this stack
    // trace will lead directly to user code. Throwing in `runAsyncResourceOp` results in an Error
    // with a non-useful stack trace.
    const preallocError = new Error();
    debuggable_1.debuggablePromise(resopAsync.then((resop) => __awaiter(this, void 0, void 0, function* () {
        log.debug(`RegisterResource RPC prepared: t=${t}, name=${name}` +
            (settings_1.excessiveDebugOutput ? `, obj=${JSON.stringify(resop.serializedProps)}` : ``));
        const req = new resproto.RegisterResourceRequest();
        req.setType(t);
        req.setName(name);
        req.setParent(resop.parentURN);
        req.setCustom(custom);
        req.setObject(gstruct.Struct.fromJavaScript(resop.serializedProps));
        req.setProtect(opts.protect);
        req.setProvider(resop.providerRef);
        req.setDependenciesList(Array.from(resop.dependencies));
        const propertyDependencies = req.getPropertydependenciesMap();
        for (const key of Object.keys(resop.propertyDependencies)) {
            const deps = new resproto.RegisterResourceRequest.PropertyDependencies();
            deps.setUrnsList(resop.propertyDependencies[key]);
            propertyDependencies.set(key, deps);
        }
        // Now run the operation, serializing the invocation if necessary.
        const opLabel = `monitor.registerResource(${label})`;
        runAsyncResourceOp(opLabel, () => __awaiter(this, void 0, void 0, function* () {
            const resp = yield debuggable_1.debuggablePromise(new Promise((resolve, reject) => monitor.registerResource(req, (err, innerResponse) => {
                log.debug(`RegisterResource RPC finished: ${label}; err: ${err}, resp: ${innerResponse}`);
                if (err) {
                    // If the monitor is unavailable, it is in the process of shutting down or has already
                    // shut down. Don't emit an error and don't do any more RPCs, just exit.
                    if (err.code === grpc.status.UNAVAILABLE) {
                        log.debug("Resource monitor is terminating");
                        process.exit(0);
                    }
                    // Node lets us hack the message as long as we do it before accessing the `stack` property.
                    preallocError.message = `failed to register new resource ${name} [${t}]: ${err.message}`;
                    reject(preallocError);
                }
                else {
                    resolve(innerResponse);
                }
            })), opLabel);
            resop.resolveURN(resp.getUrn());
            // Note: 'id || undefined' is intentional.  We intentionally collapse falsy values to
            // undefined so that later parts of our system don't have to deal with values like 'null'.
            if (resop.resolveID) {
                const id = resp.getId() || undefined;
                resop.resolveID(id, id !== undefined);
            }
            // Now resolve the output properties.
            yield resolveOutputs(res, t, name, props, resp.getObject(), resop.resolvers);
        }));
    })), label);
}
exports.registerResource = registerResource;
/**
 * Prepares for an RPC that will manufacture a resource, and hence deals with input and output properties.
 */
function prepareResource(label, res, custom, props, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        // Simply initialize the URN property and get prepared to resolve it later on.
        // Note: a resource urn will always get a value, and thus the output property
        // for it can always run .apply calls.
        let resolveURN;
        res.urn = new resource_1.Output(res, debuggable_1.debuggablePromise(new Promise(resolve => resolveURN = resolve), `resolveURN(${label})`), 
        /*performApply:*/ Promise.resolve(true));
        // If a custom resource, make room for the ID property.
        let resolveID;
        if (custom) {
            let resolveValue;
            let resolvePerformApply;
            res.id = new resource_1.Output(res, debuggable_1.debuggablePromise(new Promise(resolve => resolveValue = resolve), `resolveID(${label})`), debuggable_1.debuggablePromise(new Promise(resolve => resolvePerformApply = resolve), `resolveIDPerformApply(${label})`));
            resolveID = (v, performApply) => {
                resolveValue(v);
                resolvePerformApply(performApply);
            };
        }
        // Now "transfer" all input properties into unresolved Promises on res.  This way,
        // this resource will look like it has all its output properties to anyone it is
        // passed to.  However, those promises won't actually resolve until the registerResource
        // RPC returns
        const resolvers = rpc_1.transferProperties(res, label, props);
        /** IMPORTANT!  We should never await prior to this line, otherwise the Resource will be partly uninitialized. */
        // Before we can proceed, all our dependencies must be finished.
        const explicitDependencies = yield gatherExplicitDependencies(opts.dependsOn);
        // Serialize out all our props to their final values.  In doing so, we'll also collect all
        // the Resources pointed to by any Dependency objects we encounter, adding them to 'propertyDependencies'.
        const propertyDependencies = {};
        const serializedProps = yield rpc_1.serializeResourceProperties(label, props, propertyDependencies);
        let parentURN;
        if (opts.parent) {
            parentURN = yield opts.parent.urn.promise();
        }
        else {
            // If no parent was provided, parent to the root resource.
            parentURN = yield settings_1.getRootResource();
        }
        let providerRef;
        if (custom && opts.provider) {
            const provider = opts.provider;
            const providerURN = yield provider.urn.promise();
            const providerID = (yield provider.id.promise()) || rpc_1.unknownValue;
            providerRef = `${providerURN}::${providerID}`;
        }
        const dependencies = new Set(explicitDependencies);
        const propertyDeps = {};
        for (const key of Object.keys(propertyDependencies)) {
            const urns = new Set();
            for (const dep of propertyDependencies[key]) {
                const urn = yield dep.urn.promise();
                urns.add(urn);
                dependencies.add(urn);
            }
            propertyDeps[key] = Array.from(urns);
        }
        return {
            resolveURN: resolveURN,
            resolveID: resolveID,
            resolvers: resolvers,
            serializedProps: serializedProps,
            parentURN: parentURN,
            providerRef: providerRef,
            dependencies: dependencies,
            propertyDependencies: propertyDeps,
        };
    });
}
/**
 * Gathers explicit dependency URNs from a list of Resources (possibly Promises and/or Outputs).
 */
function gatherExplicitDependencies(dependsOn) {
    return __awaiter(this, void 0, void 0, function* () {
        if (dependsOn) {
            if (Array.isArray(dependsOn)) {
                const dos = [];
                for (const d of dependsOn) {
                    dos.push(...(yield gatherExplicitDependencies(d)));
                }
                return dos;
            }
            else if (dependsOn instanceof Promise) {
                return gatherExplicitDependencies(yield dependsOn);
            }
            else if (resource_1.Output.isInstance(dependsOn)) {
                // Recursively gather dependencies, await the promise, and append the output's dependencies.
                const dos = dependsOn.apply(gatherExplicitDependencies);
                const urns = yield dos.promise();
                const implicits = yield gatherExplicitDependencies([...dos.resources()]);
                return urns.concat(implicits);
            }
            else {
                return [yield dependsOn.urn.promise()];
            }
        }
        return [];
    });
}
/**
 * Finishes a resource creation RPC operation by resolving its outputs to the resulting RPC payload.
 */
function resolveOutputs(res, t, name, props, outputs, resolvers) {
    return __awaiter(this, void 0, void 0, function* () {
        // Produce a combined set of property states, starting with inputs and then applying
        // outputs.  If the same property exists in the inputs and outputs states, the output wins.
        const allProps = {};
        if (outputs) {
            Object.assign(allProps, rpc_1.deserializeProperties(outputs));
        }
        const label = `resource:${name}[${t}]#...`;
        for (const key of Object.keys(props)) {
            if (!allProps.hasOwnProperty(key)) {
                // input prop the engine didn't give us a final value for.  Just use the value passed into the resource
                // after round-tripping it through serialization. We do the round-tripping primarily s.t. we ensure that
                // Output values are handled properly w.r.t. unknowns.
                const inputProp = yield rpc_1.serializeProperty(label, props[key], []);
                if (inputProp === undefined) {
                    continue;
                }
                allProps[key] = rpc_1.deserializeProperty(inputProp);
            }
        }
        rpc_1.resolveProperties(res, resolvers, t, name, allProps);
    });
}
/**
 * registerResourceOutputs completes the resource registration, attaching an optional set of computed outputs.
 */
function registerResourceOutputs(res, outputs) {
    // Now run the operation. Note that we explicitly do not serialize output registration with
    // respect to other resource operations, as outputs may depend on properties of other resources
    // that will not resolve until later turns. This would create a circular promise chain that can
    // never resolve.
    const opLabel = `monitor.registerResourceOutputs(...)`;
    runAsyncResourceOp(opLabel, () => __awaiter(this, void 0, void 0, function* () {
        // The registration could very well still be taking place, so we will need to wait for its URN.
        // Additionally, the output properties might have come from other resources, so we must await those too.
        const urn = yield res.urn.promise();
        const resolved = yield rpc_1.serializeProperties(opLabel, { outputs }, {});
        const outputsObj = gstruct.Struct.fromJavaScript(resolved.outputs);
        log.debug(`RegisterResourceOutputs RPC prepared: urn=${urn}` +
            (settings_1.excessiveDebugOutput ? `, outputs=${JSON.stringify(outputsObj)}` : ``));
        // Fetch the monitor and make an RPC request.
        const monitor = settings_1.getMonitor();
        const req = new resproto.RegisterResourceOutputsRequest();
        req.setUrn(urn);
        req.setOutputs(outputsObj);
        const label = `monitor.registerResourceOutputs(${urn}, ...)`;
        yield debuggable_1.debuggablePromise(new Promise((resolve, reject) => monitor.registerResourceOutputs(req, (err, innerResponse) => {
            log.debug(`RegisterResourceOutputs RPC finished: urn=${urn}; ` +
                `err: ${err}, resp: ${innerResponse}`);
            if (err) {
                // If the monitor is unavailable, it is in the process of shutting down or has already
                // shut down. Don't emit an error and don't do any more RPCs, just exit.
                if (err.code === grpc.status.UNAVAILABLE) {
                    log.debug("Resource monitor is terminating");
                    process.exit(0);
                }
                log.error(`Failed to end new resource registration '${urn}': ${err.stack}`);
                reject(err);
            }
            else {
                resolve();
            }
        })), label);
    }), false);
}
exports.registerResourceOutputs = registerResourceOutputs;
/**
 * resourceChain is used to serialize all resource requests.  If we don't do this, all resource operations will be
 * entirely asynchronous, meaning the dataflow graph that results will determine ordering of operations.  This
 * causes problems with some resource providers, so for now we will serialize all of them.  The issue
 * pulumi/pulumi#335 tracks coming up with a long-term solution here.
 */
let resourceChain = Promise.resolve();
let resourceChainLabel = undefined;
// runAsyncResourceOp runs an asynchronous resource operation, possibly serializing it as necessary.
function runAsyncResourceOp(label, callback, serial) {
    // Serialize the invocation if necessary.
    if (serial === undefined) {
        serial = settings_1.serialize();
    }
    const resourceOp = debuggable_1.debuggablePromise(resourceChain.then(() => __awaiter(this, void 0, void 0, function* () {
        if (serial) {
            resourceChainLabel = label;
            log.debug(`Resource RPC serialization requested: ${label} is current`);
        }
        return callback();
    })), label + "-initial");
    // Ensure the process won't exit until this RPC call finishes and resolve it when appropriate.
    const done = settings_1.rpcKeepAlive();
    const finalOp = debuggable_1.debuggablePromise(resourceOp.then(() => { done(); }, () => { done(); }), label + "-final");
    // Set up another promise that propagates the error, if any, so that it triggers unhandled rejection logic.
    resourceOp.catch((err) => Promise.reject(err));
    // If serialization is requested, wait for the prior resource operation to finish before we proceed, serializing
    // them, and make this the current resource operation so that everybody piles up on it.
    if (serial) {
        resourceChain = finalOp;
        if (resourceChainLabel) {
            log.debug(`Resource RPC serialization requested: ${label} is behind ${resourceChainLabel}`);
        }
    }
}
