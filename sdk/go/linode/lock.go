// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package linode

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-linode/sdk/v5/go/linode/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// > **Early Access** Locks are in Early Access and may not be available to all users.
//
// > **Important** Only unrestricted users can create and delete locks. Restricted users cannot manage locks even if they have read/write permissions for the resource.
//
// Manages a Linode Lock which prevents accidental deletion and modification of resources. Locks protect against deletion, rebuild operations, and service transfers. The `cannotDeleteWithSubresources` lock type also protects subresources such as disks, configs, interfaces, and IP addresses.
//
// For more information, see the Linode APIv4 docs (TBD).
//
// > **Note** Only one lock can exist per resource at a time. You cannot have both `cannotDelete` and `cannotDeleteWithSubresources` locks on the same resource simultaneously.
//
// ## Example Usage
//
// Create a basic lock that prevents a Linode from being deleted:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-linode/sdk/v5/go/linode"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			my_inst, err := linode.NewInstance(ctx, "my-inst", &linode.InstanceArgs{
//				Label:  pulumi.String("my-inst"),
//				Region: pulumi.String("us-east"),
//				Type:   pulumi.String("g6-nanode-1"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = linode.NewLock(ctx, "my-lock", &linode.LockArgs{
//				EntityId:   my_inst.ID(),
//				EntityType: pulumi.String("linode"),
//				LockType:   pulumi.String("cannot_delete"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// Create a lock that prevents a Linode and its subresources (disks, configs, etc.) from being deleted:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-linode/sdk/v5/go/linode"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			my_inst, err := linode.NewInstance(ctx, "my-inst", &linode.InstanceArgs{
//				Label:  pulumi.String("my-inst"),
//				Region: pulumi.String("us-east"),
//				Type:   pulumi.String("g6-nanode-1"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = linode.NewLock(ctx, "my-lock", &linode.LockArgs{
//				EntityId:   my_inst.ID(),
//				EntityType: pulumi.String("linode"),
//				LockType:   pulumi.String("cannot_delete_with_subresources"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Locks can be imported using the Lock's ID, e.g.
//
// ```sh
// $ pulumi import linode:index/lock:Lock my-lock 1234567
// ```
type Lock struct {
	pulumi.CustomResourceState

	// The ID of the entity to lock.
	EntityId pulumi.IntOutput `pulumi:"entityId"`
	// The label of the locked entity.
	EntityLabel pulumi.StringOutput `pulumi:"entityLabel"`
	// The type of the entity to lock. Currently only `linode` is supported. Note: Linodes that are part of an LKE cluster cannot be locked.
	EntityType pulumi.StringOutput `pulumi:"entityType"`
	// The URL of the locked entity.
	EntityUrl pulumi.StringOutput `pulumi:"entityUrl"`
	// The type of lock to apply. Only one lock type can exist per resource at a time. Valid values are:
	LockType pulumi.StringOutput `pulumi:"lockType"`
}

// NewLock registers a new resource with the given unique name, arguments, and options.
func NewLock(ctx *pulumi.Context,
	name string, args *LockArgs, opts ...pulumi.ResourceOption) (*Lock, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.EntityId == nil {
		return nil, errors.New("invalid value for required argument 'EntityId'")
	}
	if args.EntityType == nil {
		return nil, errors.New("invalid value for required argument 'EntityType'")
	}
	if args.LockType == nil {
		return nil, errors.New("invalid value for required argument 'LockType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Lock
	err := ctx.RegisterResource("linode:index/lock:Lock", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLock gets an existing Lock resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLock(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LockState, opts ...pulumi.ResourceOption) (*Lock, error) {
	var resource Lock
	err := ctx.ReadResource("linode:index/lock:Lock", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Lock resources.
type lockState struct {
	// The ID of the entity to lock.
	EntityId *int `pulumi:"entityId"`
	// The label of the locked entity.
	EntityLabel *string `pulumi:"entityLabel"`
	// The type of the entity to lock. Currently only `linode` is supported. Note: Linodes that are part of an LKE cluster cannot be locked.
	EntityType *string `pulumi:"entityType"`
	// The URL of the locked entity.
	EntityUrl *string `pulumi:"entityUrl"`
	// The type of lock to apply. Only one lock type can exist per resource at a time. Valid values are:
	LockType *string `pulumi:"lockType"`
}

type LockState struct {
	// The ID of the entity to lock.
	EntityId pulumi.IntPtrInput
	// The label of the locked entity.
	EntityLabel pulumi.StringPtrInput
	// The type of the entity to lock. Currently only `linode` is supported. Note: Linodes that are part of an LKE cluster cannot be locked.
	EntityType pulumi.StringPtrInput
	// The URL of the locked entity.
	EntityUrl pulumi.StringPtrInput
	// The type of lock to apply. Only one lock type can exist per resource at a time. Valid values are:
	LockType pulumi.StringPtrInput
}

func (LockState) ElementType() reflect.Type {
	return reflect.TypeOf((*lockState)(nil)).Elem()
}

type lockArgs struct {
	// The ID of the entity to lock.
	EntityId int `pulumi:"entityId"`
	// The type of the entity to lock. Currently only `linode` is supported. Note: Linodes that are part of an LKE cluster cannot be locked.
	EntityType string `pulumi:"entityType"`
	// The type of lock to apply. Only one lock type can exist per resource at a time. Valid values are:
	LockType string `pulumi:"lockType"`
}

// The set of arguments for constructing a Lock resource.
type LockArgs struct {
	// The ID of the entity to lock.
	EntityId pulumi.IntInput
	// The type of the entity to lock. Currently only `linode` is supported. Note: Linodes that are part of an LKE cluster cannot be locked.
	EntityType pulumi.StringInput
	// The type of lock to apply. Only one lock type can exist per resource at a time. Valid values are:
	LockType pulumi.StringInput
}

func (LockArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*lockArgs)(nil)).Elem()
}

type LockInput interface {
	pulumi.Input

	ToLockOutput() LockOutput
	ToLockOutputWithContext(ctx context.Context) LockOutput
}

func (*Lock) ElementType() reflect.Type {
	return reflect.TypeOf((**Lock)(nil)).Elem()
}

func (i *Lock) ToLockOutput() LockOutput {
	return i.ToLockOutputWithContext(context.Background())
}

func (i *Lock) ToLockOutputWithContext(ctx context.Context) LockOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LockOutput)
}

// LockArrayInput is an input type that accepts LockArray and LockArrayOutput values.
// You can construct a concrete instance of `LockArrayInput` via:
//
//	LockArray{ LockArgs{...} }
type LockArrayInput interface {
	pulumi.Input

	ToLockArrayOutput() LockArrayOutput
	ToLockArrayOutputWithContext(context.Context) LockArrayOutput
}

type LockArray []LockInput

func (LockArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Lock)(nil)).Elem()
}

func (i LockArray) ToLockArrayOutput() LockArrayOutput {
	return i.ToLockArrayOutputWithContext(context.Background())
}

func (i LockArray) ToLockArrayOutputWithContext(ctx context.Context) LockArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LockArrayOutput)
}

// LockMapInput is an input type that accepts LockMap and LockMapOutput values.
// You can construct a concrete instance of `LockMapInput` via:
//
//	LockMap{ "key": LockArgs{...} }
type LockMapInput interface {
	pulumi.Input

	ToLockMapOutput() LockMapOutput
	ToLockMapOutputWithContext(context.Context) LockMapOutput
}

type LockMap map[string]LockInput

func (LockMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Lock)(nil)).Elem()
}

func (i LockMap) ToLockMapOutput() LockMapOutput {
	return i.ToLockMapOutputWithContext(context.Background())
}

func (i LockMap) ToLockMapOutputWithContext(ctx context.Context) LockMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LockMapOutput)
}

type LockOutput struct{ *pulumi.OutputState }

func (LockOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Lock)(nil)).Elem()
}

func (o LockOutput) ToLockOutput() LockOutput {
	return o
}

func (o LockOutput) ToLockOutputWithContext(ctx context.Context) LockOutput {
	return o
}

// The ID of the entity to lock.
func (o LockOutput) EntityId() pulumi.IntOutput {
	return o.ApplyT(func(v *Lock) pulumi.IntOutput { return v.EntityId }).(pulumi.IntOutput)
}

// The label of the locked entity.
func (o LockOutput) EntityLabel() pulumi.StringOutput {
	return o.ApplyT(func(v *Lock) pulumi.StringOutput { return v.EntityLabel }).(pulumi.StringOutput)
}

// The type of the entity to lock. Currently only `linode` is supported. Note: Linodes that are part of an LKE cluster cannot be locked.
func (o LockOutput) EntityType() pulumi.StringOutput {
	return o.ApplyT(func(v *Lock) pulumi.StringOutput { return v.EntityType }).(pulumi.StringOutput)
}

// The URL of the locked entity.
func (o LockOutput) EntityUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *Lock) pulumi.StringOutput { return v.EntityUrl }).(pulumi.StringOutput)
}

// The type of lock to apply. Only one lock type can exist per resource at a time. Valid values are:
func (o LockOutput) LockType() pulumi.StringOutput {
	return o.ApplyT(func(v *Lock) pulumi.StringOutput { return v.LockType }).(pulumi.StringOutput)
}

type LockArrayOutput struct{ *pulumi.OutputState }

func (LockArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Lock)(nil)).Elem()
}

func (o LockArrayOutput) ToLockArrayOutput() LockArrayOutput {
	return o
}

func (o LockArrayOutput) ToLockArrayOutputWithContext(ctx context.Context) LockArrayOutput {
	return o
}

func (o LockArrayOutput) Index(i pulumi.IntInput) LockOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Lock {
		return vs[0].([]*Lock)[vs[1].(int)]
	}).(LockOutput)
}

type LockMapOutput struct{ *pulumi.OutputState }

func (LockMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Lock)(nil)).Elem()
}

func (o LockMapOutput) ToLockMapOutput() LockMapOutput {
	return o
}

func (o LockMapOutput) ToLockMapOutputWithContext(ctx context.Context) LockMapOutput {
	return o
}

func (o LockMapOutput) MapIndex(k pulumi.StringInput) LockOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Lock {
		return vs[0].(map[string]*Lock)[vs[1].(string)]
	}).(LockOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LockInput)(nil)).Elem(), &Lock{})
	pulumi.RegisterInputType(reflect.TypeOf((*LockArrayInput)(nil)).Elem(), LockArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LockMapInput)(nil)).Elem(), LockMap{})
	pulumi.RegisterOutputType(LockOutput{})
	pulumi.RegisterOutputType(LockArrayOutput{})
	pulumi.RegisterOutputType(LockMapOutput{})
}
